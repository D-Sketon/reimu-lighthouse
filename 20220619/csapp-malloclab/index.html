<!DOCTYPE html><html lang="zh-CN"><head><link rel="stylesheet" href="/css/bilicard.css"><link rel="stylesheet" href="/source/midijs.css"><script src="https://www.midijs.net/lib/midi.js"></script><meta charset="utf-8"><script>!function(t,e,n,c,s,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(s=e.createElement(c)).async=1,s.src="https://www.clarity.ms/tag/l21x0dspxn",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(s,a)}(window,document,"clarity","script")</script><script async src="https://hm.baidu.com/hm.js?55ca897d064d6eb98df32d62c6984cc0"></script><script data-pjax>var _hmt=_hmt||[];_hmt.push(["_trackPageview",location.pathname])</script><script>window.icon_font="4552607_09mhdxci6yrk",window.clipboard_tips={success:"复制成功(*^▽^*)",fail:"复制失败 (ﾟ⊿ﾟ)ﾂ"}</script><title>CSAPP - MallocLab | 拔剑Sketon</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CUbuntu%20Mono:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/loader.css"><meta name="description" content="深入理解计算机系统（CSAPP）中MallocLab的实验详解。"><meta property="og:type" content="article"><meta property="og:title" content="CSAPP - MallocLab"><meta property="og:url" content="https://d-sketon.github.io/20220619/csapp-malloclab/index.html"><meta property="og:site_name" content="拔剑Sketon"><meta property="og:description" content="深入理解计算机系统（CSAPP）中MallocLab的实验详解。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/0.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/1.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/2.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/3.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/4.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/5.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/6.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/7.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/8.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/9.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/10.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/11.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/12.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/13.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/14.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/15.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/25.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/26.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/16.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/17.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/18.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/19.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/20.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/21.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/22.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/23.png"><meta property="og:image" content="https://d-sketon.top/img/csapp-malloclab/24.png"><meta property="article:published_time" content="2022-06-19T07:59:51.000Z"><meta property="article:modified_time" content="2023-01-17T03:28:59.770Z"><meta property="article:author" content="D-Sketon"><meta property="article:tag" content="CSAPP"><meta property="article:tag" content="深入理解计算机系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://d-sketon.top/img/csapp-malloclab/0.png"><link rel="alternate" href="/atom.xml" title="拔剑Sketon" type="application/atom+xml"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"><link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.9/dist/katex.min.css"><link rel="stylesheet" href="https://npm.webcache.cn/@waline/client@v2/dist/waline.css"><script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://npm.webcache.cn/wowjs@1.1.3/css/libs/animate.css"><script src="https://npm.webcache.cn/wowjs@1.1.3/dist/wow.min.js"></script><script>new WOW({offset:0,mobile:!0,live:!1}).init()</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loader"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="loading-taichi"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision"><path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="#ff6e6b"/><path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z" fill="#fd0d00"/><path d="M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95" fill="#fd0d00"/></svg></div><div class="loading-word">少女祈祷中...</div></div></div><script>var time=null,startLoading=()=>{time=Date.now(),document.getElementById("loader").classList.remove("loading")},endLoading=()=>{time?500<Date.now()-time?(time=null,document.body.style.overflow="auto",document.getElementById("loader").classList.add("loading")):(setTimeout(endLoading,500-(Date.now()-time)),time=null):(document.body.style.overflow="auto",document.getElementById("loader").classList.add("loading"))};window.addEventListener("DOMContentLoaded",endLoading),document.getElementById("loader").addEventListener("click",endLoading)</script><div id="copy-tooltip" style="pointer-events:none;opacity:0;transition:all .2s ease;position:fixed;top:50%;left:50%;z-index:999;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,.5);padding:10px 15px;border-radius:10px"></div><div id="container"><div id="wrap"><div id="header-nav"><nav id="main-nav"><span class="main-nav-link-wrap"><span class="main-nav-icon"></span> <a class="main-nav-link" href="/">首页</a> </span><span class="main-nav-link-wrap"><span class="main-nav-icon"></span> <a class="main-nav-link" href="/archives">归档</a> </span><span class="main-nav-link-wrap"><span class="main-nav-icon"></span> <a class="main-nav-link" href="/about">关于</a> </span><span class="main-nav-link-wrap"><span class="main-nav-icon"></span> <a class="main-nav-link" href="/friend">友链</a> </span><a id="main-nav-toggle" class="nav-icon"></a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a> <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a></nav></div><header id="header"><img fetchpriority="high" src="/images/banner.webp" alt="CSAPP - MallocLab"><div id="header-outer" class="outer"><div id="header-title" class="inner"><div id="logo-wrap"><a href="/" id="logo"><h1>CSAPP - MallocLab</h1></a></div><h2 id="subtitle-wrap"></h2></div></div></header><div id="content" class="outer"><aside id="sidebar"><div class="sidebar-wrap wow fadeInRight wrap-sticky"><div class="sidebar-toc-sidebar"><div class="sidebar-toc"><h3 class="toc-title">文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%84%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">代码预览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">函数及全局变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">mm_init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extend_heap%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">extend_heap函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_malloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">mm_malloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_free%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">mm_free函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_realloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">mm_realloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#judge%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">judge函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#place%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">place函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#coalesce%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">coalesce函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find_fit%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">find_fit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#relink%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">relink函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updatenode%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">updatenode函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">优化原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">实验过程及分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">完整代码</span></a></li></ol></div></div></div><div class="sidebar-common-sidebar hidden"><div class="sidebar-author"><img data-src="/avatar/avatar.webp" data-sizes="auto" alt="D-Sketon" class="lazyload"><div class="sidebar-author-name">D-Sketon</div><div class="sidebar-description">D-Sketon&#39;s blog</div></div><div class="sidebar-state"><div class="sidebar-state-article"><div>文章</div><div class="sidebar-state-number">53</div></div><div class="sidebar-state-category"><div>分类</div><div class="sidebar-state-number">10</div></div><div class="sidebar-state-tag"><div>标签</div><div class="sidebar-state-number">19</div></div></div><div class="sidebar-social"><div class="icon-github"><a href="https://github.com/D-Sketon" itemprop="url" target="_blank" aria-label="github"></a></div><div class="icon-bilibili"><a href="https://space.bilibili.com/20339857" itemprop="url" target="_blank" aria-label="bilibili"></a></div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">首页</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">归档</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">关于</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">友链</div></div></div></div><div class="sidebar-btn-wrapper" style="position:static"><div class="sidebar-toc-btn current"></div><div class="sidebar-common-btn"></div></div></div></aside><section id="main"><article id="post-CSAPP - MallocLab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-inner"><div class="article-meta"><div class="article-date wow slideInLeft"><a href="/20220619/csapp-malloclab/" class="article-date-link"><time datetime="2022-06-19T07:59:51.000Z" itemprop="datePublished">2022-06-19</time></a></div><div class="article-category wow slideInLeft"><a class="article-category-link" href="/categories/%E8%AE%A1%E8%BD%AF%E6%9D%82%E8%B0%88/">计软杂谈</a></div></div><div class="hr-line"></div><div class="e-content article-entry" itemprop="articleBody"><blockquote><p>所有代码只针对测试数据进行特别优化，可能不具有普适性</p></blockquote><h2 id="代码预览"><a class="markdownIt-Anchor" href="#代码预览"></a> 代码预览</h2><p>显式空闲链表+分离适配+realloc_bal测试点优化+binary_bal测试点优化</p><h3 id="宏定义"><a class="markdownIt-Anchor" href="#宏定义"></a> 宏定义</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/0.png" alt="0"><br>宏定义和书本基本相同，但增加了PRED和SUCC两个宏用作定位空闲块中的前驱指针和后继指针，前驱指针保存在空闲块首起4个字节，而后继指针保存在后4个字节</p><h3 id="函数及全局变量声明"><a class="markdownIt-Anchor" href="#函数及全局变量声明"></a> 函数及全局变量声明</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/1.png" alt="1"><br>root指针数组用作分离适配器的空闲链表数组，维护着链表头<br>MAX_SIZE为root数组的大小<br>heap_listp为堆顶指针<br>根据2的幂划分块的大小：{0<sub>8}，{9</sub>16}，{17<sub>32}，…，{2049</sub>4096}，{4097~∞}</p><h3 id="mm_init函数"><a class="markdownIt-Anchor" href="#mm_init函数"></a> mm_init函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/2.png" alt="2"><br>相比于书上代码增加了对root的初始化，同时改变初始扩展堆的大小（原为CHUNKSIZE/WSIZE，现改为115字节），经过测试，改后代码能比原代码增加5分</p><h3 id="extend_heap函数"><a class="markdownIt-Anchor" href="#extend_heap函数"></a> extend_heap函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/3.png" alt="3"><br>和书上代码相同</p><h3 id="mm_malloc函数"><a class="markdownIt-Anchor" href="#mm_malloc函数"></a> mm_malloc函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/4.png" alt="4"><br>和书上代码基本相同，但由于place函数由void类型改为void*类型，同时改变形参数量，所以对place函数有关代码做出了调整</p><h3 id="mm_free函数"><a class="markdownIt-Anchor" href="#mm_free函数"></a> mm_free函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/5.png" alt="5"><br>相比于书上代码增加了对于空闲块的前驱指针和后继指针的初始化操作</p><h3 id="mm_realloc函数"><a class="markdownIt-Anchor" href="#mm_realloc函数"></a> mm_realloc函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/6.png" alt="6"><br>ptr为空时直接调用mm_malloc函数，size为0时直接调用mm_free函数，否则<br>首先将输入的size进行8字节对齐，得到asize<br>接着判断ptr本身大小是否大于asize，如果小于等于则直接返回ptr指针（抛弃空闲区域），否则判断ptr后是否为空闲块且空闲块是最后一块，如果是则判断两者合并后是否放的下，如果放得下则直接更新ptr并返回，否则进行堆扩展并更新返回<br>如果不满足上述所有情况则进行常规mm_malloc并进行内存复制</p><h3 id="judge函数"><a class="markdownIt-Anchor" href="#judge函数"></a> judge函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/7.png" alt="7"><br>用于判断size大小的空闲块应该被放置在哪个空闲链表数组中</p><h3 id="place函数"><a class="markdownIt-Anchor" href="#place函数"></a> place函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/8.png" alt="8"><br>flag用于判断调用者来源于malloc还是realloc函数（realloc函数无需进行relink操作）<br>对于剩余部分大于2*DSIZE的情况，对asize进行判断，如果小于96（实际范围可以在80~110之间浮动，分数相同），则将空闲块放在右边，否则则将空闲块放在左边，放置的同时将空闲块的前驱和后继初始化并插入空闲链表中<br>对于剩余部分小于2*DSIZE的情况，抛弃剩余空闲区域<br>返回指针为分配块所对应指针</p><h3 id="coalesce函数"><a class="markdownIt-Anchor" href="#coalesce函数"></a> coalesce函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/9.png" alt="9"><br>和书上代码基本类似，只是在对应情况下加上relink对应空闲块<br>最后加上updatenode函数更新新的空闲块到对于空闲链表中</p><h3 id="find_fit函数"><a class="markdownIt-Anchor" href="#find_fit函数"></a> find_fit函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/10.png" alt="10"><br>从对应空闲链表数组中开始寻找，首次适配，如果当前数组中没有找到则跳入下一下标中继续寻找，如果所有空闲块都无法放入则返回NULL</p><h3 id="relink函数"><a class="markdownIt-Anchor" href="#relink函数"></a> relink函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/11.png" alt="11"><br>基础的空闲链表删除节点函数，最后对bp进行初始化</p><h3 id="updatenode函数"><a class="markdownIt-Anchor" href="#updatenode函数"></a> updatenode函数</h3><p><img src="https://d-sketon.top/img/csapp-malloclab/12.png" alt="12"><br>基础的空闲链表（OrderedList）插入节点函数，链表为升序排列，分头部插入和非头部插入两种情况</p><h2 id="优化原理"><a class="markdownIt-Anchor" href="#优化原理"></a> 优化原理</h2><ul><li>采用<strong>显式空闲链表</strong>相对于隐式空闲链表，在插入的过程中只需遍历空闲链表而非整个堆，能大大加快速度</li><li>采用<strong>分离适配</strong>，将将近大小的块放入一个链表中，类似于链式哈希表，能大大加快检索速度，同时由于优先遍历相近的块，所以相近大小的分配块会被分配到相近大小的空闲块中，提升内存利用率</li><li>链表采用<strong>升序排列</strong>，<strong>首次适配</strong>，所以每次都能适配到最接近大小的空闲块，即最佳适配，能在牺牲一小部分速度的同时大大提升内存利用率</li><li>针对realloc_bal和realloc2_bal测试点进行优化，注意到测试点中对同一块区域进行反复realloc，size升序排列，同时内部穿插alloc和free，此时若对于realloc的块直接向后扩展堆，同时抛弃空闲块，则不会打乱堆中的顺序，使内存利用率上升</li><li>针对binary_bal和binary2_bal测试点进行优化，注意到测试点中先反复alloc小块和大块，之后一次性free大块并alloc更大的块，如果不进行优化，则由于之后alloc的块并不能被插入到之前free的块中（大小不够），所以会造成空间的大量浪费，而选择将大块的空闲块放在左边，小块的空闲块放在右边，当free大块时，小块的空闲块，大块的空闲块和大块free的空间都能相合并，形成一个更大的空间并能容纳下之后alloc的块，能大大提升内存利用率</li><li>其他优化：改变mm_init中初始堆的大小，经测试，当初始堆的大小为115字节时有最大内存利用率（<strong>仅对测试点进行优化，无普适性</strong>）</li></ul><h2 id="实验过程及分析"><a class="markdownIt-Anchor" href="#实验过程及分析"></a> 实验过程及分析</h2><blockquote><p>详细注释请见完整代码</p></blockquote><ul><li>使用书本上代码（隐式空闲链表）进行首次尝试<br><img src="https://d-sketon.top/img/csapp-malloclab/13.png" alt="13"><br>可以发现内存的利用率只有74%，而且速度也很慢</li><li>随后尝试将隐式改为显式空闲链表（LIFO）<br><img src="https://d-sketon.top/img/csapp-malloclab/14.png" alt="14"><br>时间方面已经到达满分，之后需要对空间进行进一步优化</li><li>考虑采用分离适配方法（LIFO），将块大小分解到131072大小<br><img src="https://d-sketon.top/img/csapp-malloclab/15.png" alt="15"><br>内存利用率只有2%的提升，这也在意料之中，因为分离适配主要提升速度<br>首先观察到最后4个测试点的内存利用率非常低，首先考虑优化最后两个测试点（realloc_bal和realloc2_bal）</li><li>通过观察测试点后选择修改realloc函数如下<br><img src="https://d-sketon.top/img/csapp-malloclab/25.png" alt="25"><br><img src="https://d-sketon.top/img/csapp-malloclab/26.png" alt="26"><br>即首先判断asize是否和copySize相等，如果相等则直接返回ptr，如果小于则调用place函数对分配块进行重新分配，否则则调用coalesce2函数（和coalesce函数类似），对于原块的前后寻找是否存在空闲块，如果存在则对其进行合并并重新分配，否则则重新alloc并内存复制</li><li>此外修改updatenode函数代码，使其变为升序排列，这样就可以配合哈希表达到不损耗太多速度的同时进行最优适配<br><img src="https://d-sketon.top/img/csapp-malloclab/16.png" alt="16"><br>此时内存利用率有了部分的提升</li><li>接着考虑对后部空闲块直接扩展堆，即判断</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( !GET_ALLOC(HDRP(NEXT_BLKP(ptr)))&amp;&amp;!GET_SIZE(HDRP(NEXT_BLKP(NEXT_BLKP(ptr))))))</span><br></pre></td></tr></table></figure><ul><li>在修改完代码并确认代码无误后却一直发生段错误<br><img src="https://d-sketon.top/img/csapp-malloclab/17.png" alt="17"><br>在尝试了许多办法后发现将CHUNKSIZE的大小缩减到256字节后就不再发生段错误，推测可能是代码之间仍然存在逻辑错误，或是由于测试点的特殊性导致段错误，而将CHUNKSIZE进行了修改后正好改变了分配块在内存中的排布顺序，从而消除了段错误</li><li>同时最后的测试点有了较大幅度的提升，已经到 97%<br><img src="https://d-sketon.top/img/csapp-malloclab/18.png" alt="18"><br>随后尝试对binary_bal和binary2_bal测试点进行优化<br>考虑按照块的大小选择place分配方式，即大块分在右边，而小块分在左边，分界线介于80~110字节之间</li><li>但在修改完代码后发现<br><img src="https://d-sketon.top/img/csapp-malloclab/19.png" alt="19"><br>所有测试点均在第六行发生负载覆盖问题，通过查看测试点可以知道第一次malloc可以正常执行，但在进行第二次malloc后就覆盖掉了第一次malloc的内容</li><li>调试发现<br><img src="https://d-sketon.top/img/csapp-malloclab/20.png" alt="20"><br>发现第一次将分配块（0xf697c118）的ALLOC置为1，但在 第二次malloc时ALLOC被隐式地修改回了0<br>经过长时间的调试发现问题在于没有修改传入的bp指针，导致bp指针指向了错误的位置，而在之后malloc中影响到了之前的ALLOC<br>所以将place函数从void类型修改为void *类型，将修改后的bp指针传出，并在malloc函数中更新bp指针即可消除负载覆盖的问题</li><li>但这时又再次出现了段错误的问题<br><img src="https://d-sketon.top/img/csapp-malloclab/21.png" alt="21"><br>经过排查发现是coalesce2函数中判断块的前部是否存在空闲块和place函数发生了冲突<br>简单起见，直接暴力删除coalesce2中对于flag==2的情况，同时将CHUNKSIZE修改回4096</li><li>修改后最后两个测试点发生error<br><img src="https://d-sketon.top/img/csapp-malloclab/22.png" alt="22"></li><li>考虑coealesce2函数和其他许多函数可能发生了冲突，最后选择直接删除coalesce2整个函数<br><img src="https://d-sketon.top/img/csapp-malloclab/23.png" alt="23"><br>分数提升到了92分<br>最后通过重整代码和修改CHUNSIZE大小和初始堆的大小，成功再次提升5分</li><li>最终实验结果<br><img src="https://d-sketon.top/img/csapp-malloclab/24.png" alt="24"></li></ul><h2 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;ECNU SE&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;Jack Qiu&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2055272094@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)-WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRED(bp) ((char *)(bp))         <span class="comment">//返回前驱结点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp) ((char *)(bp) + WSIZE) <span class="comment">//返回后继结点</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">relink</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">updatenode</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">15</span>;                <span class="comment">//空闲链表数组大小</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *heap_listp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> *root[<span class="number">15</span>];          <span class="comment">//空闲链表数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//相比于采用log，考虑采用if-else语句提升速度</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">8</span>)          index = <span class="number">3</span>;  <span class="comment">//由于8字节对齐，size不可能小于8</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">16</span>)    index = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">32</span>)    index = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span>)    index = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">128</span>)   index = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span>)   index = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">512</span>)   index = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">1024</span>)  index = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">2048</span>)  index = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">4096</span>)  index = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">else</span>                    index  =<span class="number">13</span>;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">        root[i] = <span class="literal">NULL</span>;             <span class="comment">//初始化空闲链表数组</span></span><br><span class="line">    heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> (extend_heap(<span class="number">115</span>) == <span class="literal">NULL</span>)   <span class="comment">//对于测试点进行特别优化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * DSIZE : words * DSIZE;   <span class="comment">//WSIZE修改为DSIZE</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(PRED(bp), <span class="number">0</span>);       <span class="comment">//前驱结点初始化</span></span><br><span class="line">    PUT(SUCC(bp), <span class="number">0</span>);       <span class="comment">//后继节点初始化</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * (DSIZE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = (DSIZE) * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / (DSIZE));</span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bp = place(bp, asize, <span class="number">0</span>);   <span class="comment">//更新bp</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / DSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    bp = place(bp, asize, <span class="number">0</span>);       <span class="comment">//更新bp</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = judge(size); i &lt; MAX_SIZE; i++)    <span class="comment">//若查找不到依次向下一个下标移动</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> *bp = root[i];     <span class="comment">//空闲链表内部查找</span></span><br><span class="line">        <span class="keyword">while</span> (bp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">                <span class="keyword">return</span> bp;</span><br><span class="line">            bp = GET(SUCC(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (!flag)          <span class="comment">//malloc调用时需要relink，而realloc调用时不需要relink</span></span><br><span class="line">        relink(bp);</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE)) <span class="comment">//空闲区域变为空闲块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分割区间可在80字节~110字节之间浮动，对结果几乎无影响</span></span><br><span class="line">        <span class="keyword">if</span> (asize &lt; <span class="number">96</span>) <span class="comment">//小于96字节</span></span><br><span class="line">        &#123;</span><br><span class="line">            PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));          <span class="comment">//分配块置1</span></span><br><span class="line">            PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">            bp = NEXT_BLKP(bp);</span><br><span class="line">            PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));  <span class="comment">//空闲块置0</span></span><br><span class="line">            PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">            PUT(PRED(bp), <span class="number">0</span>);   <span class="comment">//前驱初始化</span></span><br><span class="line">            PUT(SUCC(bp), <span class="number">0</span>);   <span class="comment">//后继初始化</span></span><br><span class="line">            updatenode(bp);     <span class="comment">//将空闲块插入空闲链表中</span></span><br><span class="line">            <span class="keyword">return</span> PREV_BLKP(bp);   <span class="comment">//返回分配块指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">//大于等于96字节</span></span><br><span class="line">        &#123;</span><br><span class="line">            PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));  <span class="comment">//空闲块置0</span></span><br><span class="line">            PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, <span class="number">1</span>));   <span class="comment">//分配块置1</span></span><br><span class="line">            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, <span class="number">1</span>));</span><br><span class="line">            PUT(PRED(bp), <span class="number">0</span>);   <span class="comment">//前驱初始化</span></span><br><span class="line">            PUT(SUCC(bp), <span class="number">0</span>);   <span class="comment">//后继初始化</span></span><br><span class="line">            updatenode(bp);     <span class="comment">//将空闲块插入空闲链表中</span></span><br><span class="line">            <span class="keyword">return</span> NEXT_BLKP(bp);   <span class="comment">//返回分配块指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//丢弃空闲区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(SUCC(ptr), <span class="number">0</span>);  <span class="comment">//前驱初始化</span></span><br><span class="line">    PUT(PRED(ptr), <span class="number">0</span>);  <span class="comment">//后继初始化</span></span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">relink</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = judge(GET_SIZE(HDRP(bp)));</span><br><span class="line">    <span class="type">void</span> *before = GET(PRED(bp));</span><br><span class="line">    <span class="type">void</span> *after = GET(SUCC(bp));</span><br><span class="line">    <span class="keyword">if</span> (before == <span class="literal">NULL</span>)             <span class="comment">//头部插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (after != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PRED(after), <span class="number">0</span>);    <span class="comment">//后块前驱置0</span></span><br><span class="line">        root[index] = after;        <span class="comment">//空闲数组更新头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (after != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PRED(after), before);   <span class="comment">//后块前驱更新</span></span><br><span class="line">        PUT(SUCC(before), after);   <span class="comment">//前块后驱更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(PRED(bp), <span class="number">0</span>);   <span class="comment">//前驱初始化</span></span><br><span class="line">    PUT(SUCC(bp), <span class="number">0</span>);   <span class="comment">//后继初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//所有情况一律选择先删除后插入节点</span></span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)  <span class="comment">//Case 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        relink(NEXT_BLKP(bp));  <span class="comment">//删除前面的空闲块</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) <span class="comment">//Case 3 </span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        relink(PREV_BLKP(bp));  <span class="comment">//删除后面的空闲块</span></span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc)    <span class="comment">//Case 4 </span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        relink(PREV_BLKP(bp));  <span class="comment">//删除前面的空闲块</span></span><br><span class="line">        relink(NEXT_BLKP(bp));  <span class="comment">//删除后面的空闲块</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    updatenode(bp); <span class="comment">//插入新的空闲块</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">updatenode</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *now_root = root[judge(GET_SIZE(HDRP(bp)))];</span><br><span class="line">    <span class="type">char</span> *prevp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *nextp = now_root;</span><br><span class="line">    <span class="comment">//升序排列</span></span><br><span class="line">    <span class="keyword">while</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_SIZE(HDRP(nextp)) &gt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//确定插入位置</span></span><br><span class="line">        prevp = nextp;</span><br><span class="line">        nextp = GET(SUCC(nextp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prevp == <span class="literal">NULL</span>)  <span class="comment">//头部插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        root[judge(GET_SIZE(HDRP(bp)))] = bp;</span><br><span class="line">        PUT(SUCC(bp), nextp);</span><br><span class="line">        PUT(PRED(bp), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PRED(nextp), bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                <span class="comment">//中间插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(SUCC(prevp), bp);</span><br><span class="line">        PUT(PRED(bp), prevp);</span><br><span class="line">        PUT(SUCC(bp), nextp);</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PRED(nextp), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)    <span class="comment">//ptr == NULL 直接mm_malloc</span></span><br><span class="line">        <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)      <span class="comment">//size == 0 直接free</span></span><br><span class="line">    &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> copySize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)  <span class="comment">//8字节对齐</span></span><br><span class="line">        asize = <span class="number">2</span> * (DSIZE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = (DSIZE) * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / (DSIZE));</span><br><span class="line">    <span class="keyword">if</span> (copySize &gt;= asize)  <span class="comment">//小于原ptr大小抛弃空闲区域直接返回</span></span><br><span class="line">        <span class="keyword">return</span> ptr; </span><br><span class="line">    <span class="keyword">if</span> (!GET_ALLOC(HDRP(NEXT_BLKP(ptr))) &amp;&amp; !GET_SIZE(HDRP(NEXT_BLKP(NEXT_BLKP(ptr)))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断后块是否为空闲块且空闲块是否为最后一块</span></span><br><span class="line">        <span class="type">size_t</span> new_size = GET_SIZE(HDRP(ptr)) + GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        <span class="keyword">if</span> (new_size &lt; asize)   <span class="comment">//大小不够需要进行扩展堆</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (extend_heap(MAX(asize - new_size, CHUNKSIZE) == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//扩展失败</span></span><br><span class="line">            new_size += MAX(asize - new_size, CHUNKSIZE);   <span class="comment">//更新大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        relink(NEXT_BLKP(ptr)); <span class="comment">//删除空闲块</span></span><br><span class="line">        PUT(HDRP(ptr), PACK(new_size, <span class="number">1</span>));  <span class="comment">//更新原块大小</span></span><br><span class="line">        PUT(FTRP(ptr), PACK(new_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上述条件均不满足时选择原始方法</span></span><br><span class="line">    bp = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(bp, ptr, size);</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="article-footer"><blockquote class="article-copyright"><p><strong>本文作者：</strong>D-Sketon @ 拔剑Sketon</p><p><strong>本文链接：</strong><a href="https://d-sketon.github.io/20220619/csapp-malloclab/">https://d-sketon.github.io/20220619/csapp-malloclab/</a></p><p><strong>本文版权：</strong>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><span class="icon-creative-commons"></span>BY-NC-SA</a> 许可协议。转载请注明出处！</p></blockquote><a href="/20220619/csapp-malloclab/#comments" class="article-comment-link"><span class="post-comments-count waline-comment-count" data-path="/20220619/csapp-malloclab/" itemprop="commentCount"></span> 留言 </a><span class="article-visitor-link"><span class="waline-pageview-count" data-path="/20220619/csapp-malloclab/">0</span> <em class="post-meta-item-text">阅读量</em></span><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" rel="tag">深入理解计算机系统</a></li></ul></footer></div><nav id="article-nav" class="wow fadeInUp"><div class="article-nav-link-wrap article-nav-link-left"><img data-src="https://d-sketon.top/img/_backwebp/bg11.webp" data-sizes="auto" alt="CSAPP - BombLab" class="lazyload"> <a href="/20220619/csapp-bomblab/"></a><div class="article-nav-caption">前一篇</div><h3 class="article-nav-title">CSAPP - BombLab</h3></div><div class="article-nav-link-wrap article-nav-link-right"><img data-src="https://d-sketon.top/img/_backwebp/bg11.webp" data-sizes="auto" alt="CSAPP - AttackLab" class="lazyload"> <a href="/20220619/csapp-attacklab/"></a><div class="article-nav-caption">后一篇</div><h3 class="article-nav-title">CSAPP - AttackLab</h3></div></nav></article><div id="comments" class="wcomment"></div></section></div><footer id="footer" class="wow fadeInUp"><div style="width:100%;overflow:hidden"><div class="footer-line"></div></div><div class="outer"><div id="footer-info" class="inner"><div><span class="icon-copyright"></span> 2020-2024 <span class="footer-info-sep"></span> D-Sketon</div><div>基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp; Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" target="_blank">Reimu</a></div><div><span class="icon-brush"></span> 169.9k &nbsp;|&nbsp; <span class="icon-coffee"></span> 11:52</div><div><span class="icon-eye"></span> <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span> &nbsp;|&nbsp; <span class="icon-user"></span> <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span></div></div></div></footer><div class="sidebar-top"><img src="/images/taichi.png" height="50" width="50"><div class="arrow-up"></div></div><div id="mask"></div></div><nav id="mobile-nav"><div class="sidebar-wrap"><div class="sidebar-toc-sidebar"><div class="sidebar-toc"><h3 class="toc-title">文章目录</h3><div class="sidebar-toc-wrapper toc-div-class"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%84%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">代码预览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">函数及全局变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_init%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">mm_init函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extend_heap%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">extend_heap函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_malloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">mm_malloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_free%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">mm_free函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mm_realloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">mm_realloc函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#judge%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">judge函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#place%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">place函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#coalesce%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">coalesce函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find_fit%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">find_fit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#relink%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">relink函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updatenode%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">updatenode函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">优化原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">实验过程及分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">完整代码</span></a></li></ol></div></div></div><div class="sidebar-common-sidebar hidden"><div class="sidebar-author"><img data-src="/avatar/avatar.webp" data-sizes="auto" alt="D-Sketon" class="lazyload"><div class="sidebar-author-name">D-Sketon</div><div class="sidebar-description">D-Sketon&#39;s blog</div></div><div class="sidebar-state"><div class="sidebar-state-article"><div>文章</div><div class="sidebar-state-number">53</div></div><div class="sidebar-state-category"><div>分类</div><div class="sidebar-state-number">10</div></div><div class="sidebar-state-tag"><div>标签</div><div class="sidebar-state-number">19</div></div></div><div class="sidebar-social"><div class="icon-github"><a href="https://github.com/D-Sketon" itemprop="url" target="_blank" aria-label="github"></a></div><div class="icon-bilibili"><a href="https://space.bilibili.com/20339857" itemprop="url" target="_blank" aria-label="bilibili"></a></div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">首页</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">归档</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">关于</div></div><div class="sidebar-menu-link-wrap"><a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a> <span class="sidebar-menu-icon"></span><div class="sidebar-menu-link">友链</div></div></div></div></div><div class="sidebar-btn-wrapper"><div class="sidebar-toc-btn current"></div><div class="sidebar-common-btn"></div></div></nav></div><div class="site-search"><div class="reimu-popup popup"><div class="reimu-search"><span class="reimu-search-input-icon"></span><div class="reimu-search-input" id="reimu-search-input"></div></div><div class="reimu-results"><div id="reimu-stats"></div><div id="reimu-hits"></div><div id="reimu-pagination" class="reimu-pagination"></div></div><span class="popup-btn-close"></span></div></div><script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"></script><script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"></script><script src="/js/script.js"></script><script src="/js/pjax_script.js" data-pjax></script><script type="module" data-pjax>import PhotoSwipeLightbox from "https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.js";
  
  const pswp = () => {
    if (_$$('.article-entry a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-entry',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.js")
      }).init();
    }
    if(_$$('.article-gallery a.article-gallery-item').length > 0) {
      new PhotoSwipeLightbox({
        gallery: '.article-gallery',
        children: 'a.article-gallery-item',
        pswpModule: () => import("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.js")
      }).init();
    }
    window.lightboxStatus = 'done';
    window.removeEventListener('lightbox:ready', pswp);
  }
  if(window.lightboxStatus === 'ready') {
    pswp()
  } else {
    window.addEventListener('lightbox:ready', pswp);
  }</script><script data-pjax type="module">import { init } from "https://npm.webcache.cn/@waline/client@2.15.8/dist/waline.mjs";
    if(_$('.wcomment')) {
      init({
        el: '.wcomment',
        serverURL: 'https://reimu.d-sketon.top',
        lang: 'zh-CN',
        locale: {},
        emoji: ["https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/alus","https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/qq","https://unpkg.com/@waline/emojis@1.2.0/tieba","https://unpkg.com/@waline/emojis@1.2.0/tw-emoji"],
        meta: ["nick","mail","link"],
        requiredMeta: ["nick","mail"],
        wordLimit: JSON.parse('0'),
        comment: true,
        pageSize: JSON.parse('10'),
        dark: 'html[data-theme="dark"]',
        pageview: JSON.parse('true'),
    });
    }</script><script src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js"></script><script src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js"></script><script src="/js/algolia_search.js"></script><script>var CONFIG={root:"/",algolia:{applicationID:"AIE5T9AKYQ",apiKey:"2b855b06a058dd80bc84972874e020aa",indexName:"reimu_new_algoliasearch",hits:{per_page:parseInt("10")},labels:{input_placeholder:"搜索.....",hits_empty:"未发现与 「${query}」相关内容",hits_stats:"找到${hits}条结果（用时 ${time} ms）"}}}</script><script src="https://npm.webcache.cn/mouse-firework@0.0.4/dist/index.umd.js"></script><script>firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))</script><script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js"></script><script>function loadScripts(scripts,index){if(index<scripts.length){const script=scripts[index],src=script.getAttribute("src");src?fetch(src).then(t=>{if(t.ok)return t.text();throw new Error("Network response was not ok "+t.statusText)}).then(t=>{var e=document.createElement("script");e.text=t,document.head.appendChild(e),loadScripts(scripts,index+1)}).catch(t=>{console.error("Failed to load script:",src,t)}):(eval(script.textContent),loadScripts(scripts,index+1))}}new Pjax({selectors:["#header-title","#subtitle-wrap","#content","#mobile-nav","#lazy-script"],switches:{"#header-title":Pjax.switches.outerHTML,"#subtitle-wrap":Pjax.switches.outerHTML,"#content":function(t,e,r){loadScripts([...e.querySelectorAll("script")],0),t.outerHTML=e.outerHTML,this.onSwitch()},"#mobile-nav":Pjax.switches.outerHTML,"#lazy-script":function(t,e,r){loadScripts([...e.querySelectorAll("script")],0),t.innerHTML=e.innerHTML,this.onSwitch()}},cacheBust:!1})</script><script src="/js/pjax.js"></script><div id="lazy-script"><div></div></div><script>console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,"color: #ff5252;"),console.log("%c Theme.Reimu v0.2.0-beta.2 %c https://github.com/D-Sketon/hexo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script><script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" async></script><script src="/js/insert_highlight.js" data-pjax></script></body></html>